{"./":{"url":"./","title":"简介","keywords":"","body":"Bai-Yingjie.github.io 个人笔记汇总 https://bai-yingjie.github.io/ "},"notes/golang_汇编_arm64.html":{"url":"notes/golang_汇编_arm64.html","title":"汇编语法和arm64小知识","keywords":"","body":"golang汇编语法参考: https://go.dev/doc/asm pseudo寄存器 SB: Static base pointer 全局基地址. 比如foo(SB)就是foo这个symbol的地址 FP: 帧指针. 用来传参的, 比如 first_arg+0(FP): 第一个参数 second_arg+8(FP): 第二个参数(64bit CPU) SP: 栈指针. 指向栈顶. 用于局部变量. CPU都有物理SP, 语法上看前缀来区分: x-8(SP), y-4(SP): 使用pseudo SP -8(SP)使用物理SP PC: 程序指针 函数 格式: TEXT symbol(SB), [flags,] $framesize[-argsize] symbol: 函数名 SB: SB伪寄存器 flags: 可以是 NOSPLIT: 不让编译器插入栈分裂的代码 WRAPPER: 不增加函数帧计数 NEEDCTXT: 需要上下文参数, 一般用于闭包 framesize: 局部变量大小, 包含要传给子函数的参数部分 argsize: 参数+返回值的大小, 可以省略由编译器自己推导 比如 //go:nosplit func swap(a, b int) (int, int) 可以写为: TEXT ·swap(SB), NOSPLIT, $0-32 或者 TEXT ·swap(SB), NOSPLIT, $0 这里-32是4个8字节的int, 即入参a, b和两个出参.注意go并不区分入参和出参 func swap(a, b int) (int, int) 或 func swap(a, b, c, d int) 或 func swap() (a, b, c, d int) 或 func swap() (a, []int, d int) 汇编都一样 arm64汇编 https://pkg.go.dev/cmd/internal/obj/arm64#pkg-overview Register mapping rules All basic register names are written as Rn. Go uses ZR as the zero register and RSP as the stack pointer. Bn, Hn, Dn, Sn and Qn instructions are written as Fn in floating-point instructions and as Vn in SIMD instructions. ARM64异常处理过程 When an event which causes an exception occurs, the processor hardware automatically performs certain actions. The SPSR_ELn is updated, (where n is the Exception level where the exception is taken), to store the PSTATE information required to correctly return at the end of the exception. PSTATE is updated to reflect the new processor status (and this may mean that the Exception level is raised, or it may stay the same). The return address to be used at the end of the exception is stored in ELR_ELn. 异常发生的时候, CPU会自动的实施如下动作: 将PSTATE保存到SPSR_ELn比如异常发生在EL0, 一般会在EL1处理. 那PSTATE会保存在SPSR_EL1 更新PSTATE以反映新的CPU状态, 比如已经进入EL1 硬件会将返回地址保存在ELR_Eln.还是比如异常发生在EL0, 但在EL1处理, 那返回地址保存在ELR_EL1 The processor has to be told when to return from an exception by software. This is done by executing the ERET instruction. This restores the pre-exception PSTATE from SPSR_ELn and returns program execution back to the original location by restoring the PC from ELR_ELn. eret指令用来从异常处理返回: 从SPSR_ELn恢复异常前的PSTATE 从ELR_ELn恢复PC 异常返回, 从恢复的PC和PSTATE继续执行 ELR_ELn contains the return address which is preferred for the specific exception type. For some exceptions, this is the address of the next instruction after the one which generated the exception. For example, when an SVC (system call) instruction is executed, we simply wish to return to the following instruction in the application. In other cases, we may wish to re-execute the instruction that generated the exception. 在发生异常时, 硬件会自动更新ELR, 根据情况, 返回地址有几种可能: 比如SVC指令触发的同步异常, ELR里保存的是其下一条指令 比如异步异常(即外部中断), ELR里保存的是下一个没被执行(或完全执行)的指令 ELR可以在异常处理程序里面被更改. In addition to the SPSR and ELR registers, each Exception level has its own dedicated Stack Pointer register. These are named SP_EL0, SP_EL1, SP_EL2 and SP_EL3. These registers are used to point to a dedicated stack that can, for example, be used to store registers which are corrupted by the exception handler, so that they can be restored to their original value before returning to the original code. Handler code may switch from using SP_ELn to SP_EL0. For example, it may be that SP_EL1 points to a piece of memory which holds a small stack that the kernel can guarantee to always be valid. SP_EL0 might point to a kernel task stack which is larger, but not guaranteed to be safe from overflow. This switching is controlled by writing to the [SPSel] bit, as shown in the following code: MSR SPSel, #0 // switch to SP_EL0 MSR SPSel, #1 // switch to SP_ELn 每个EL都有独立的SP, 并且异常处理程序可以切换使用SP_EL0和SP_ELn. ARM64上下文切换 Processors that implement the ARMv8-A Architecture are typically used in systems running a complex operating system with many applications or tasks that run concurrently. Each process has its own unique translation tables residing in physical memory. When an application starts, the operating system allocates it a set of translation table entries that map both the code and data used by the application to physical memory. These tables can subsequently be modified by the kernel, for example, to map in extra space, and are removed when the application is no longer running. There might therefore be multiple tasks present in the memory system. The kernel scheduler periodically transfers execution from one task to another. This is called a context switch and requires the kernel to save all execution state associated with the process and to restore the state of the process to be run next. The kernel also switches translation table entries to those of the next process to be run. The memory of the tasks that are not currently running is completely protected from the task that is running. 每个进程都有自己的translation table, 这个table是kernel分配的, 把其物理地址配置到ttbr0寄存器. 上下文切换的时候, kernel会保存/恢复如下上下文: general-purpose registers X0-X30. Advanced SIMD and Floating-point registers V0 - V31. Some status registers. TTBR0_EL1 and TTBR0. Thread Process ID (TPIDxxx) Registers. Address Space ID (ASID). For EL0 and EL1, there are two translation tables. TTBR0_EL1 provides translations for the bottom of Virtual Address space, which is typically application space and TTBR1_EL1 covers the top of Virtual Address space, typically kernel space. This split means that the OS mappings do not have to be replicated in the translation tables of each task. EL0和EL1有两个translation table, TTBR0_EL1负责bottom空间(用户空间), TTBR1_EL1负责top空间(kernel空间). 大家都用TTBR1_EL1做kernel空间, 所以进程切换的时候, TTBR1_EL1不用变, 所以kernel的映射不用变. Translation table entries contain a non-global (nG) bit. If the nG bit is set for a particular page, it is associated with a specific task or application. If the bit is marked as 0, then the entry is global and applies to all tasks. 页表entry里有个nG位, 用来表示non-global, 为0的时候, 这个页表entry就是全局的, 对所有task都有效. For non-global entries, when the TLB is updated and the entry is marked as non-global, a value is stored in the TLB entry in addition to the normal translation information. This value is called the Address Space ID (ASID), which is a number assigned by the OS to each individual task. Subsequent TLB look-ups only match on that entry if the current ASID matches with the ASID that is stored in the entry. This permits multiple valid TLB entries to be present for a particular page marked as non-global, but with different ASID values. In other words, we do not necessarily need to flush the TLBs when we context switch. ASID(Address Space ID)寄存器用来标记页表entry所属的task, 由kernel分配. 当TLB更新的时候, TLB entry除了保存地址翻译信息, 还会包括这个ASID. TLB查询的时候, 只有当前的ASID和TLB entry保存的ASID匹配的时候, 才算TLB命中. 所以上下文切换的时候不需要flush TLB. In AArch64, this ASID value can be specified as either an 8-bit or 16-bit value, controlled by the TCR_EL1.AS bit. The current ASID value is specified in either TTBR0_EL1 or TTBR1_EL1. TCR_EL1 controls which TTBR holds the ASID, but it is normally TTBR0_EL1, as this corresponds to application space. ASID可以8位或16位. 一般配置在TTBR0_EL1中. Having the current value of the ASID stored in the translation table register means that you can atomically modify both the translation tables as well as the ASID in a single instruction. This simplifies the process of changing the table and ASID when compared with the ARMv7-A Architecture. 把ASID值放在TTBR0_EL1里的好处是, 一个指令就可以原子的更改ASID和页表. Additionally, the ARMv8-A Architecture provides Thread ID registers for use by operating system software. These have no hardware significance and are typically used by threading libraries as a base pointer to per-thread data. This is often referred to as Thread Local Storage (TLS). For example, the pthreads library uses this feature and includes the following registers: User Read and Write Thread ID Register (TPIDR_EL0). User Read-Only Thread ID Register (TPIDRRO_EL0). Thread ID Register, privileged accesses only (TPIDR_EL1). TPIDR(Thread ID registers)是给系统软件保存Thread Local Storage (TLS)用的. EL0可以用TPIDR_EL0 EL1还有TPIDR_EL1 什么是VHE Note: The DynamIQ processors (Cortex-A55, Cortex-A75 and Cortex-A76) support Virtualization Host Extensions (VHEs). 通常kernel运行在EL1, 一个同样的kernel, 如果运行在VHE使能了, 硬件会重定向寄存器访问: We saw in the section on Virtualizing generic timers that enabling VHE changes the layout of the EL2 virtual address space. However, we still have a problem with the configuration of the MMU. This is because our kernel will try to access _EL1 registers, such as TTBR0_EL1, rather than _EL2 registers such as TTBR0_EL2. To run the same binary at EL2, we need to redirect the accesses from the EL1 registers to the EL2 equivalents. Setting E2H will do this, so that accesses to _EL1 system registers are redirected to their EL2 equivalents. This redirection illustrated in the following diagram: "},"notes/rust_入门_brief.html":{"url":"notes/rust_入门_brief.html","title":"入门系列","keywords":"","body":"我在学习rust语法过程中的笔记, 大部分来自于网上摘录, 略有更改. "},"notes/rust_books.html":{"url":"notes/rust_books.html","title":"reference books","keywords":"","body":"参考书目: 文档汇总: https://www.rust-lang.org/learn 语法: https://doc.rust-lang.org/book 语法参考: https://doc.rust-lang.org/reference 标准库: https://doc.rust-lang.org/std/index.html 例子: https://doc.rust-lang.org/stable/rust-by-example cargo: https://doc.rust-lang.org/stable/cargo rustup: https://rust-lang.github.io/rustup 交叉编译: https://rust-lang.github.io/rustup/cross-compilation.html "},"notes/rust_入门1.html":{"url":"notes/rust_入门1.html","title":"安装和基础语法","keywords":"","body":"安装 使用rustup安装: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装了如下的文件: $ ls /home/yingjieb/.rustup downloads settings.toml tmp toolchains update-hashes $ ls /home/yingjieb/.cargo bin env $ ls /home/yingjieb/.cargo/bin cargo cargo-fmt clippy-driver rustc rustfmt rust-lldb cargo-clippy cargo-miri rls rustdoc rust-gdb rustup 在/home/yingjieb/.profile增加了 . \"$HOME/.cargo/env\" 在/home/yingjieb/.bashrc增加了 . \"$HOME/.cargo/env\" 这个env主要就是干了一件事: export PATH=\"$HOME/.cargo/bin:$PATH\" 组件 默认安装了如下组件: cargo 5.7 MiB clippy rust-docs rust-std 34.9 MiB rustc 74.2 MiB rustfmt 如果是在你的CI环境下只想用rustc来编译, 可以指定profile为minimal 比如 ## install RUST ARG RUST_TOOLCHAIN=\"1.60.0\" RUN mkdir $CARGO_HOME && chmod 777 $CARGO_HOME RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --profile minimal --default-toolchain \"$RUST_TOOLCHAIN\" \\ && rustup target add x86_64-unknown-linux-musl --toolchain \"$RUST_TOOLCHAIN\" \\ && rustup component add rustfmt \\ && rustup component add clippy rustup rustup是管理rust工具链的工具: $ rustup -V rustup 1.24.3 (ce5817a94 2021-05-31) info: This is the version for the rustup toolchain manager, not the rustc compiler. info: The currently active `rustc` version is `rustc 1.59.0 (9d1b2106e 2022-02-23) hello world $ cat hello.rs fn main() { println!(\"hello world!\"); } $ rustc hello.rs yingjieb@godev-server /repo/yingjieb/rust/practice $ ls hello hello.rs yingjieb@godev-server /repo/yingjieb/rust/practice $ ./hello hello world! yingjieb@godev-server /repo/yingjieb/rust/practice $ file hello hello: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ae53c8a4def1de8266d96cfe6dc8d8074ffa1d2b, with debug_info, not stripped $ llh hello -rwxr-xr-x 1 yingjieb platform 3.5M Mar 23 02:59 hello yingjieb@godev-server /repo/yingjieb/rust/practice $ ldd hello linux-vdso.so.1 (0x00007ffce327e000) libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fe769517000) librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007fe76930f000) libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fe7690f0000) libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fe768eec000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe768afb000) /lib64/ld-linux-x86-64.so.2 (0x00007fe769979000) $ strip hello yingjieb@godev-server /repo/yingjieb/rust/practice $ llh total 300K -rwxr-xr-x 1 yingjieb platform 295K Mar 23 03:05 hello -rw-r--r-- 1 yingjieb platform 44 Mar 23 02:59 hello.rs 可以看到编译出来的hello可执行程序达到3.5M, 而且还动态链接了c库. strip后是295K. 这个大小正常 $ size -A hello hello : section size addr .interp 28 624 .note.ABI-tag 32 652 .note.gnu.build-id 36 684 .gnu.hash 28 720 .dynsym 1800 752 .dynstr 1232 2552 .gnu.version 150 3784 .gnu.version_r 224 3936 .rela.dyn 16776 4160 .rela.plt 96 20936 .init 23 21032 .plt 80 21056 .plt.got 8 21136 .text 217583 21152 .fini 9 238736 .rodata 20335 238752 .eh_frame_hdr 3772 259088 .eh_frame 21392 262864 .gcc_except_table 2972 284256 .tdata 40 2384528 .tbss 57 2384576 .init_array 16 2384576 .fini_array 8 2384592 .data.rel.ro 9280 2384600 .dynamic 576 2393880 .got 1696 2394456 .data 56 2396160 .bss 456 2396216 .comment 41 0 .debug_aranges 37632 0 .debug_pubnames 401408 0 .debug_info 785107 0 .debug_abbrev 3086 0 .debug_line 413191 0 .debug_frame 96 0 .debug_str 1057897 0 .debug_pubtypes 144 0 .debug_ranges 514768 0 Total 3512131 实际上是debug信息占了绝大部分size. 基础语法 用//或/**/来注释 函数声明fn Foo( input1 : i32, input2 : u32) -> i32 { ... } 局部变量声明使用let关键字开头，用双引号包含起来的部分是字符串常量 分号结尾 最简单的标准输出是使用println！宏来完成. println后面的感叹号，它代表这是一个宏，而不是一个函数。 代码组织: crate: 类似项目概念 mod: 类似namespace概念 std: 标准库. 编译器会为用户写的每个crate自动插入一句话 use std::prelude::*; 函数可以在使用的位置后面声明 格式化输出 fn main() { println!(\"{}\", 1); // 打印变量的默认格式 println!(\"{:o}\", 9); // 八进制 println!(\"{:x}\", 255); // 十六进制 小写 println!(\"{:X}\", 255); // 十六进制 大写 println!(\"{:p}\", &0); // 指针 println!(\"{:b}\", 15); // 二进制 println!(\"{:e}\", 10000f32); // 科学计数(小写) println!(\"{:E}\", 10000f32); // 科学计数(大写) println!(\"{:?}\", \"test\"); // 打印Debug println!(\"{:#?}\", (\"test1\", \"test2\")); // 带换行和缩进的Debug打印 println!(\"{a} {b} {b}\", a = \"x\", b = \"y\"); // 命名参数 } 从属于std::fmt模块, 这些是宏可以做编译时检查, 最终是调用std::io里面的函数输出. 语法糖 ..表示rangefn main() { let r = 1..10; // r是一个Range,中间是两个点,代表[1,10)这个区间 for i in r { print!(\"{:?}\\t\", i); } } 两个小数点的语法仅仅是一个“语法糖”而已，用它构造出来的变量 是Range类型use std::ops::Range; fn main() { let r = Range { start: 1, end: 10 }; // r是一个Range for i in r { print!(\"{:?}\\t\", i); } } 这个类型本身实现了Iterator trait，因此它可以直接应用到循环语句中。Range具有迭代器的全部功能，因此它能调用迭代器的成员方法。fn main() { use std::iter::Iterator; // 先用rev方法把这个区间反过来,然后用map方法把每个元素乘以10 let r = (1i32..11).rev().map(|i| i * 10); for i in r { print!(\"{:?}\\t\", i); } } 左闭右开: start..end 左闭右闭: start..=end 变量 Rust的变量必须先声明后使用, 变量必须初始化, 不初始化会报错。对于局部变量，最常见的声明语法为： let variable : i32 = 100; 类型推导 变量类型可以推导: let x = 5; 而且类型推导比较强大: fn main() { // 没有明确标出变量的类型,但是通过字面量的后缀, // 编译器知道elem的类型为u8 let elem = 5u8; // 创建一个动态数组,数组内包含的是什么元素类型可以不写 let mut vec = Vec::new(); vec.push(elem); // 到后面调用了push函数,通过elem变量的类型, // 编译器可以推导出vec的实际类型是 Vec println!(\"{:?}\", vec); } 我们甚至还可以只写一部分类型，剩下的部分让编译器去推导，比如下面的这个程序，我们只知道players变量是Vec动态数组类型，但是里面包含什么元素类型并不清楚，可以在尖括号中用下划线来代替： fn main() { let player_scores = [ (\"Jack\", 20), (\"Jane\", 23), (\"Jill\", 18), (\"John\", 19), ]; // players 是动态数组,内部成员的类型没有指定,交给编译器自动推导 let players : Vec = player_scores .iter() .map(|&(player, _score)| { player }) .collect(); println!(\"{:?}\", players); } 默认只读 默认变量是只读的, 重新赋值会出错: fn main() { let x = 5; x = 10; //编译错误: re-assignment of immutable variable`x` } 加mut关键字才能可写: let mut x = 5; // mut x: i32 x = 10; 按照我的理解, 第一次赋值叫变量绑定, 后面再修改需要加mut fn test(condition: bool) { let x: i32; // 声明 x,不必使用 mut 修饰 if condition { x = 1; // 初始化 x,不需要 x 是 mut 的,因为这是初始化,不是修改 println!(\"{}\", x); } // 如果条件不满足,x 没有被初始化 // 但是没关系,只要这里不使用 x 就没事 } 类型没有“默认构造函数”，变量没有“默认值”。对于let x：i32；如果没有显式赋值，它就没有被初始化，不要想当然地以为它的值是0。编译器会做变量检查, 没有\"绑定\"的使用会报错. 变量遮蔽 比如 fn main() { let x = \"hello\"; println!(\"x is {}\", x); let x = 5; println!(\"x is {}\", x); } 第二个let x中的x把前面的x遮蔽了, 这两个x是两个变量, 类型和在内存里的空间都不一样; 前面的x实际上从此不能再次被访问到 变量遮蔽在类型转换, 改变变量读写属性时很有用: // 注意：这段代码只是演示变量遮蔽功能,并不是Vec类型的最佳初始化方法 fn main() { let mut v = Vec::new(); // v 必须是mut修饰,因为我们需要对它写入数据 v.push(1); v.push(2); v.push(3); let v = v; // 从这里往下,v成了只读变量,可读写变量v已经被遮蔽,无法再访问 for i in &v { println!(\"{}\", i); } } 反过来也行 fn main() { let v = Vec::new(); //v是不可变的 let mut v = v; //这个v可变, 这个v和上面的v已经不是一个v了 v.push(1); println!(\"{:?}\", v); } 类型别名 type Age = u32; fn grow(age: Age, year: u32) -> Age { age + year } fn main() { let x : Age = 20; println!(\"20 years later: {}\", grow(x, 20)); } 或者用在泛型场景里: type Double = (T, Vec); // 小括号包围的是一个 tuple,请参见后文中的复合数据类型 // 那么以后使用Double的时候，就等同于（i32，Vec） 全局变量 比如: static GLOBAL: i32 = 0; 全局变量必须是静态变量 全局变量必须在声明的时候马上初始化 全局变量的初始化必须是编译期可确定的常量，不能包括执行期才能确定的表达式、语句和函数调用// 这样是允许的 static array : [i32; 3] = [1,2,3]; // 这样是不允许的 static vec : Vec = { let mut v = Vec::new(); v.push(1); v }; 但使用const fn是可以的:#![feature(const_fn)] fn main() { use std::sync::atomic::AtomicBool; static FLAG: AtomicBool = AtomicBool::new(true); } 带有mut修饰的全局变量，在使用的时候必须使用unsafe关键字 fn main() { //局部变量声明,可以留待后面初始化,只要保证使用前已经初始化即可 let x; let y = 1_i32; x = 2_i32; println!(\"{} {}\", x, y); //全局变量必须声明的时候初始化,因为全局变量可以写到函数外面,被任意一个函数使用 static G1 : i32 = 3; println!(\"{}\", G1); //可变全局变量无论读写都必须用 unsafe修饰 static mut G2 : i32 = 4; unsafe { G2 = 5; println!(\"{}\", G2); } //全局变量的内存不是分配在当前函数栈上,函数退出的时候,并不会销毁全局变量占用的内存空间,程序退出才会回收 } 基本数据类型 boolfn main() { let x = true; let y: bool = !x; // 取反运算 let z = x && y; // 逻辑与,带短路功能 println!(\"{}\", z); let z = x || y; // 逻辑或,带短路功能 println!(\"{}\", z); let z = x & y; // 按位与,不带短路功能 println!(\"{}\", z); let z = x | y; // 按位或,不带短路功能 println!(\"{}\", z); let z = x ^ y; // 按位异或,不带短路功能 println!(\"{}\", z); } charlet love = '❤'; // 可以直接嵌入任何 unicode 字符 let c1 = '\\n'; // 换行符 let c2 = '\\x7f'; // 8 bit 字符变量 let c3 = '\\u{7FFF}'; // unicode字符 因为char类型的设计目的是描述任意一个unicode字符，因此它占据的内存空间不是1个字节，而是4个字节 用u8或者前面加b前缀来表示1个字节的ASCII字符let x :u8 = 1; let y :u8 = b'A'; let s :&[u8;5] = b\"hello\"; let r :&[u8;14] = br#\"hello \\n world\"#; //这里表示byte的raw string, 好像去掉前后的#也行 注意这里的b\"hello\"和\"hello\"不一样:fn print_type_of(t: &T) { println!(\"{:#?}: {}\", t, std::any::type_name::()) } fn main() { print_type_of(&\"hello\"); print_type_of(&b\"hello\"); } //结果 \"hello\": &str [ 104, 101, 108, 108, 111, ]: &[u8; 5] 整型 用i或者u加位位宽表示, 比如i32 u64 i128等. 指针用isize或者usize表示, 在32位机器上是32位, 在64位机器上是64位.let var1 : i32 = 32; // 十进制表示 let var2 : i32 = 0xFF; // 以0x开头代表十六进制表示 let var3 : i32 = 0o55; // 以0o开头代表八进制表示 let var4 : i32 = 0b1001; // 以0b开头代表二进制表示 let var5 = 0x_1234_ABCD; //使用下划线分割数字,不影响语义,但是极大地提升了阅读体验。 let var6 = 123usize; // i6变量是usize类型 let var7 = 0x_ff_u8; // i7变量是u8类型 let var8 = 32; // 不写类型,默认为 i32 类型 rust可以在整型溢出时panic, 但需要\"debug\"版本编译, 比如rustc test.rs, 而rustc -O test.rs产生的\"release\"版本则不会panic, 而是自动截断. 通过开关rustc -C overflow-checks=no test.rs可以控制这个行为. 浮点let f1 = 123.0f64; // type f64 let f2 = 0.1f64; // type f64 let f3 = 0.1f32; // type f32 let f4 = 12E+99_f64; // type f64 科学计数法 let f5 : f64 = 2.; // type f64 指针 类型名 简介 Box 指向类型T的, 具有所有权的指针, 有权释放内存; T在堆中分配 &T 指向类型T的借用指针, 也称为引用, 无权释放内存, 无权写数据 &mut T 指向类型T的mut借用指针, 无权释放内存, 有权写数据 *const T 指向类型T的只读指针, 没有生命周期信息, 无权写数据 *mut T 指向类型T的读写指针, 没有生命周期信息, 有权写数据 注: &T是借用指针, 而*T实际上也存在的, 叫raw pointer. 但是必须以*mut T或*const T存在. 一般raw pointer不常用. 除此之外，在标准库中还有一种封装起来的可以当作指针使用的类型，叫“智能指针”（smart pointer） 类型名 简介 Rc 指向类型T的引用计数指针, 共享所有权, 线程不安全 Arc 指向类型T的原子引用计数指针, 共享所有权, 线程安全 Cow clone on write, 写时复制指针. 可能是借用指针, 也可能是具有所有权的指针 什么是Box Box是指向堆中类型为T的变量的指针. 这个T可以是unsized的. All values in Rust are stack allocated by default. Values can be boxed (allocated on the heap) by creating a Box. A box is a smart pointer to a heap allocated value of type T. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed. 默认变量是分配在栈上的, 用Box可以指定分配到堆上. 除了在堆上分配内存, Box没有其他的性能损失. 比如下面的代码: fn main() { let b = Box::new(5); //在堆中分配int32类型的5, Box这个\"指针\"是在栈上. 当b离开scope的时候, 堆上的数字5会被回收. println!(\"b = {}\", b); } 这个例子在堆里分配一个i32并没有实际意义, 只是演示Box的分配原理. Box的使用情况: When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so 在堆里分配的数据在转移所有权的时候不拷贝. When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type 什么是Rc To enable multiple ownership, Rust has a type called Rc, which is an abbreviation for reference counting. The Rc type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid. We use the Rc type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. 比如b和c都\"拥有\"a这个链表 如果用Box是不行的: enum List { Cons(i32, Box), Nil, } use crate::List::{Cons, Nil}; fn main() { let a = Cons(5, Box::new(Cons(10, Box::new(Nil)))); let b = Cons(3, Box::new(a)); let c = Cons(4, Box::new(a)); // 当a move进b的时候, 所有权已经转给b了. a就不能再访问了. } The Cons variants own the data they hold, so when we create the b list, a is moved into b and b owns a. Then, when we try to use a again when creating c, we’re not allowed to because a has been moved. 下面的代码把Box换成了Rc Instead, we’ll change our definition of List to use Rc in place of Box, as shown in Listing 15-18. Each Cons variant will now hold a value and an Rc pointing to a List. When we create b, instead of taking ownership of a, we’ll clone the Rc that a is holding, thereby increasing the number of references from one to two and letting a and b share ownership of the data in that Rc. We’ll also clone a when creating c, increasing the number of references from two to three. Every time we call Rc::clone, the reference count to the data within the Rc will increase, and the data won’t be cleaned up unless there are zero references to it. enum List { Cons(i32, Rc), Nil, } use crate::List::{Cons, Nil}; use std::rc::Rc; fn main() { let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(&a)); //这里是clone应该只是clone包装, 而不是clone里面的数据, 但增加引用计数. let c = Cons(4, Rc::clone(&a)); } 注: 用Rc::clone(&a)和a.clone()是一样的. 前者更隐含了是浅拷贝的意思, 开销非常小. 类型转换 Rust对不同类型之间的转换控制得非常严格。即便是下面这样的程序，也会出现编译错误 fn main() { let var1 : i8 = 41; let var2 : i16 = var1; } Rust提供了一个关键字as，专门用于这样的类型转换 fn main() { let var1 : i8 = 41; let var2 : i16 = var1 as i16; } 类型不能随便转换: let a = \"some string\"; let b = a as u32; // 编译错误 有时必须用多个as转换 fn main() { let i = 42; // 先转为 *const i32,再转为 *mut i32 let p = &i as *const i32 as *mut i32; println!(\"{:p}\", p); } 字符串 Rust的字符串涉及两种类型，一种是&str，另外一种是String.str是Rust的内置类型。&str是对str的借用。Rust的字符串内部默认是使用utf-8编码格式的。而内置的char类型是4字节长度的，存储的内容是Unicode Scalar Value。所以，Rust里面的字符串不能视为char类型的数组，而更接近u8类型的数组. [T]是DST类型，对应的str是DST类型。 &[T]是数组切片类型，对应的&str是字符串切片类型.下面的代码能编过 &str是个胖指针, 它对指向的字符串没有所有权. let greeting : &str = \"Hello\"; fn main() { let greeting: &str = \"Hello\"; let substr: &str = &greeting[2..]; println!(\"{}\", substr); } &greeting[2..]去掉&就编译不过 我们没办法扩大greeting所引用的范围，在它后面增加内容。但是String类型可以: fn main() { let mut s = String::from(\"Hello\"); s.push(' '); s.push_str(\"World.\"); println!(\"{}\", s); } &String类型可以被编译器自动转换为&str类型: fn capitalize(substr: &mut str) { substr.make_ascii_uppercase(); } fn main() { let mut s = String::from(\"Hello World\"); capitalize(&mut s); println!(\"{}\", s); } 在这个例子中，capitalize函数调用的时候，形式参数要求是&mut str类型，而实际参数是&mut String类型，这里编译器给我们做了自动类型转换。在capitalize函数内部，它有权修改&mut str所指向的内容，但是无权给这个字符串扩容或者释放内存。 复合数据类型 tuple 元组用一对 () 包括的一组数据，可以包含不同种类的数据 let a = (1i32, false); // 元组中包含两个元素,第一个是i32类型,第二个是bool类型 let b = (\"a\", (1i32, 2i32)); // 元组中包含两个元素,第二个元素本身也是元组,它又包含了两个元素 只有一个元素要加逗号 let a = (0,); // a是一个元组,它有一个元素 let b = (0); // b是一个括号表达式,它是i32类型 访问tuple可以用模式匹配 let p = (1i32, 2i32); let (a, b) = p; //模式匹配 let x = p.0; //数字索引 let y = p.1; //数字索引 println!(\"{} {} {} {}\", a, b, x, y); 空元组占用0内存空间: let empty : () = (); fn main() { println!(\"size of i8 {}\" , std::mem::size_of::()); println!(\"size of char {}\" , std::mem::size_of::()); println!(\"size of '()' {}\" , std::mem::size_of::()); } 注: size_of的原型是 pub const fn size_of() -> usize 这个函数没有入参, 但需要实例化类型参数T 本例中这样调用: std::mem::size_of::() 用了双冒号实例化类型参数的方式. 数组 用一对 [] 包括的同类型数据 数组是一个容器，它在一块连续空间内存中，存储了一系列的同样类型的数据。数组中元素的占用空间大小必须是编译期确定的。数组本身所容纳的元素个数也必须是编译期确定的，执行阶段不可变。如果需要使用变长的容器，可以使用标准库中的Vec/LinkedList等。数组类型的表示方式为[T;n]。其中T代表元素类型；n代表元素个数；它必须是编译期常量整数；中间用分号隔开。 let a = [1, 2, 3, 4, 5]; // a 是一个长度为 5 的整型数组 let b = [\"January\", \"February\", \"March\"]; // b 是一个长度为 3 的字符串数组 let c: [i32; 5] = [1, 2, 3, 4, 5]; // c 是一个长度为 5 的 i32 数组 let d = [3; 5]; // 等同于 let d = [3, 3, 3, 3, 3]; let first = a[0]; let second = a[1]; // 数组访问 a[0] = 123; // 错误：数组 a 不可变 let mut a = [1, 2, 3]; a[0] = 4; // 正确 只有元素类型和元素个数都完全相同，这两个数组才是同类型的。数组与指针之间不能隐式转换。同类型的数组之间可以互相赋值 fn main() { let mut xs: [i32; 5] = [1, 2, 3, 4, 5]; let ys: [i32; 5] = [6, 7, 8, 9, 10]; xs = ys; xs[0] = 111; println!(\"new array {:?}\", xs); println!(\"old array {:?}\", ys); } //output new array [111, 7, 8, 9, 10] old array [6, 7, 8, 9, 10] 把数组xs作为参数传给一个函数，这个数组并不会退化成一个指针。而是会将这个数组完整复制进这个函数。函数体内对数组的改动不会影响到外面的数组。 这里再解释一下, rust的数组赋值(或者说是move), 是拷贝完整数组. rust默认在栈上分配变量, 如果想在退出作用域的时候继续使用数据, 用Box来声明变量. 数组可以直接比较: fn main() { let v1 = [1, 2, 3]; let v2 = [1, 2, 4]; println!(\"{:?}\", v1 数组支持for in fn main() { let v = [0_i32; 10]; for i in &v { println!(\"{:?}\", i); } } 数组切片 对数组取借用borrow操作，可以生成一个“数组切片”（Slice）。数组切片对数组没有“所有权”，我们可以把数组切片看作专门用于指向数组的指针，是对数组的另外一个“视图”。比如，我们有一个数组[T; n]，它的借用指针的类型就是&[T; n]。它可以通过编译器内部魔法转换为数组切片类型&[T]。数组切片实质上还是指针，它不过是在类型系统中丢弃了编译阶段定长数组类型的长度信息，而将此长度信息存储为运行期的值。示例如下: fn main() { fn mut_array(a: &mut [i32]) { a[2] = 5; } println!(\"size of &[i32; 3] : {:?}\", std::mem::size_of::()); println!(\"size of &[i32] : {:?}\", std::mem::size_of::()); let mut v: [i32; 3] = [1, 2, 3]; { let s: &mut [i32; 3] = &mut v; mut_array(s); } println!(\"{:?}\", v); } 变量v是[i32; 3]类型；变量s是&mut[i32; 3]类型，占用的空间大小与指针相同。它可以自动转换为&mut[i32]数组切片类型传入函数 mut_array，占用的空间大小等于两个指针的空间大小。通过这个指针，在函数内部，修改了外部的数组v的值。 数组切片是指向一个数组的指针，而它比指针又多了一点东西——它不止包含有一个指向数组的指针，切片本身还含带长度信息。又叫胖指针.由于不定长数组类型[T]在编译阶段是无法判断该类型占用空间的大小的，目前我们不能在栈上声明一个不定长大小数组的变量实例，也不能用它作为函数的参数、返回值。但是，指向不定长数组的胖指针的大小是确定的，&[T]类型可以用做变量实例、函数参数、返回值。 字符串切片 fn main() { let s = String::from(\"broadcast\"); let part1 = &s[0..5]; let part2 = &s[5..9]; println!(\"{}={}+{}\", s, part1, part2); } // broadcast=broad+cast 非字符串切片 fn main() { let arr = [1, 3, 5, 7, 9]; let part = &arr[0..3]; for i in part.iter() { println!(\"{}\", i); } } 索引和边界检查 rust的索引是会边界检查的. 如果越界会panic 数组的index操做执行的是下面的代码: impl ops::Index for [T] { type Output = T; fn index(&self, index: usize) -> &T { assert!(index 实际上, 自己也可以定义index操做, 只要满足 std::ops::Index trait //索引读操做 std::ops::IndexMut trait //索引写操做 一般情况下，Rust不鼓励大量使用“索引”操作。正常的“索引”操作 都会执行一次“边界检查”。从执行效率上来说，Rust比C/C++的数组索引效率低一点，因为C/C++的索引操作是不执行任何安全性检查的，它们对应的Rust代码相当于调用get_unchecked()函数更推荐使用迭代器 fn main() { use std::iter::Iterator; let v = &[10i32, 20, 30, 40, 50]; // 如果我们同时需要index和内部元素的值,调用enumerate()方法 for (index, value) in v.iter().enumerate() { println!(\"{} {}\", index, value); } // filter方法可以执行过滤,nth函数可以获取第n个元素 let item = v.iter().filter(|&x| *x % 2 == 0).nth(2); println!(\"{:?}\", item); } 注: filter的原型如下, 可以看到闭包的入参是引用&Self::Item fn filter(self, predicate: P) -> Filter where Self: Sized, P: FnMut(&Self::Item) -> bool, { Filter::new(self, predicate) } FnMut原型如下, 闭包都会自动实现FnMut. pub trait FnMut: FnOnce { extern \"rust-call\" fn call_mut( &mut self, args: Args ) -> Self::Output; } struct 普通结构体定义: struct Site { domain: String, name: String, nation: String, found: u32 } 普通结构体实例化: let runoob = Site { domain: String::from(\"www.runoob.com\"), name: String::from(\"RUNOOB\"), nation: String::from(\"China\"), found: 2013 }; 举例: struct Point { x: i32, y: i32, } fn main() { let p = Point { x: 0, y: 0}; println!(\"Point is at {} {}\", p.x, p.y); } fn main() { // 刚好局部变量名字和结构体成员名字一致 let x = 10; let y = 20; // 下面是简略写法,等同于 Point { x: x, y: y },同名字的相对应 let p = Point { x, y }; println!(\"Point is at {} {}\", p.x, p.y); } 访问struct内部的元素: fn main() { let p = Point { x: 0, y: 0}; // 声明了px 和 py,分别绑定到成员 x 和成员 y let Point { x : px, y : py } = p; println!(\"Point is at {} {}\", px, py); // 同理,在模式匹配的时候,如果新的变量名刚好和成员名字相同,可以使用简写方式 let Point { x, y } = p; println!(\"Point is at {} {}\", x, y); } 部分初始化 Rust设计了一个语法糖，允许用一种简化的语法赋值使用另外一个 struct的部分成员。比如： struct Point3d { x: i32, y: i32, z: i32, } fn default() -> Point3d { Point3d { x: 0, y: 0, z: 0 } } // 可以使用default()函数初始化其他的元素 // ..expr 这样的语法,只能放在初始化表达式中,所有成员的最后最多只能有一个 let origin = Point3d { x: 5, ..default()}; let point = Point3d { z: 1, x: 2, ..origin }; 输出结构体 调试中，完整地显示出一个结构体实例是非常有用的。但如果我们手动的书写一个格式会非常的不方便。所以 Rust 提供了一个方便地输出一整个结构体的方法： #[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(\"rect1 is {:?}\", rect1); } 如第一行所示：一定要导入调试库 #[derive(Debug)] ，之后在 println 和 print 宏中就可以用 {:?} 占位符输出一整个结构体： rect1 is Rectangle { width: 30, height: 50 } 如果属性较多的话可以使用另一个占位符 {:#?} rect1 is Rectangle { width: 30, height: 50 } tuple struct 元组结构体 有一种更简单的定义和使用结构体的方式：元组结构体。 元组结构体是一种形式是元组的结构体。 与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据： struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); \"颜色\"和\"点坐标\"是常用的两种数据类型，但如果实例化时写个大括号再写上两个名字就为了可读性牺牲了便捷性，Rust不会遗留这个问题。元组结构体对象的使用方式和元组一样，通过. 和下标来进行访问： fn main() { struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); println!(\"black = ({}, {}, {})\", black.0, black.1, black.2); println!(\"origin = ({}, {})\", origin.0, origin.1); } 举例 //以下三种都可以,内部可以没有成员: 空struct struct Foo1; struct Foo2(); struct Foo3{} // struct有名字, 但成员不用名字, 这种类型的叫tuple struct struct Color(i32, i32, i32); struct Point(i32, i32, i32); // 可以类似下面的结构体: struct Color{ 0: i32, 1: i32, 2: i32, } struct Point { 0: i32, 1: i32, 2: i32, } 举例: // define struct struct T1 { v: i32 } // define tuple struct struct T2(i32); fn main() { let v1 = T1 { v: 1 }; let v2 = T2(1); // init tuple struct let v3 = T2 { 0: 1 }; // init tuple struct let i1 = v1.v; let i2 = v2.0; let i3 = v3.0; } fn main() { struct Inches(i32); fn f1(value : Inches) {} fn f2(value : i32) {} let v : i32 = 0; f1(v); // 编译不通过,'mismatched types' f2(v); } fn type_alias() { type I = i32; fn f1(v : I) {} fn f2(v : i32) {} let v : i32 = 0; f1(v); //可以编译过, 因为type只是别名 f2(v); } 结构体方法 第一个入参是&self的函数就是这个结构体方法, 用impl块包住: struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(&self) -> u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(\"rect1's area is {}\", rect1.area()); } //结果 //rect1's area is 1500 请注意，在调用结构体方法的时候不需要填写 self ，这是出于对使用方便性的考虑。 结构体关联函数 impl块里面的没有用&self的函数就是关联函数, 使用的时候要加这个结构体的前缀:: #[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn create(width: u32, height: u32) -> Rectangle { Rectangle { width, height } } } fn main() { let rect = Rectangle::create(30, 50); println!(\"{:?}\", rect); } //结果 //Rectangle { width: 30, height: 50 } 普遍方法 在Rust中，我们可以为任何一个类型添加方法，整型也不例外。比如在标准库中，整数类型有一个方法是pow，它可以计算n次幂，于是我们可以这么使用： let x : i32 = 9; println!(\"9 power 3 = {}\", x.pow(3)); println!(\"9 power 3 = {}\", 9_i32.pow(3)); //也可以直接使用字面量来调用方法 静态方法 没有receiver参数的方法（第一个参数不是self参数的方法）称作“静态方法”。静态方法可以通过Type::FunctionName()的方式调用。 需要注意的是，即便我们的第一个参数是Self相关类型，只要变量名字不是self，就不能使用小数点的语法调用函数。 struct T(i32); impl T { // 这是一个静态方法 fn func(this: &Self) { println!{\"value {}\", this.0}; } } fn main() { let x = T(42); // x.func(); 小数点方式调用是不合法的 T::func(&x); } trait也可以定义静态函数: pub trait Default { fn default() -> Self; } Default trait实际上可以看作一个针对无参数构造函数的统一抽象 impl Default for Vec { fn default() -> Vec { Vec::new() } } enum 枚举类在 Rust 中并不像其他编程语言中的概念那样简单，但依然可以十分简单的使用： #[derive(Debug)] enum Book { Papery, Electronic } fn main() { let book = Book::Papery; println!(\"{:?}\", book); } // 结果 // Papery 书分为纸质书（Papery book）和电子书（Electronic book）。 如果你现在正在开发一个图书管理系统，你需要描述两种书的不同属性（纸质书有索书号，电子书只有 URL），你可以为枚举类成员添加元组属性描述： enum Book { Papery(u32), Electronic(String), } let book = Book::Papery(1001); let ebook = Book::Electronic(String::from(\"url://...\")); 如果你想为属性命名，可以用结构体语法： enum Book { Papery { index: u32 }, Electronic { url: String }, } let book = Book::Papery{index: 1001}; 虽然可以如此命名，但请注意，并不能像访问结构体字段一样访问枚举类绑定的属性。访问的方法在 match 语法中。 enum有或的意思, 下面的Number就是或者是Int, 或者是Float enum Number { Int(i32), Float(f32), } fn read_num(num: &Number) { match num { // 如果匹配到了 Number::Int 这个成员,那么value的类型就是 i32 &Number::Int(value) => println!(\"Integer {}\", value), // 如果匹配到了 Number::Float 这个成员,那么value的类型就是 f32 &Number::Float(value) => println!(\"Float {}\", value), } } fn main() { let n: Number = Number::Int(10); read_num(&n); } 在Rust中，enum和struct为内部成员创建了新的名字空间。如果要访问内部成员，可以使用::符号 enum Message { Quit, ChangeColor(i32, i32, i32), Move { x: i32, y: i32 }, Write(String), } let x: Message = Message::Move { x: 3, y: 4 }; enum BoardGameTurn { Move { squares: i32 }, Pass, } let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 }; enum和match Rust 通过 match 语句来实现分支结构。先认识一下如何用 match 处理枚举类： fn main() { enum Book { Papery {index: u32}, Electronic {url: String}, } let book = Book::Papery{index: 1001}; let ebook = Book::Electronic{url: String::from(\"url...\")}; match book { Book::Papery { index } => { println!(\"Papery book {}\", index); }, Book::Electronic { url } => { println!(\"E-book {}\", url); } } } // 结果 //Papery book 1001 match 块也可以当作函数表达式来对待，它也是可以有返回值的： match 枚举类实例 { 分类1 => 返回值表达式, 分类2 => 返回值表达式, ... } 但是所有返回值表达式的类型必须一样！ 如果把枚举类附加属性定义成元组，在 match 块中需要临时指定一个名字： enum Book { Papery(u32), Electronic {url: String}, } let book = Book::Papery(1001); match book { Book::Papery(i) => { println!(\"{}\", i); }, Book::Electronic { url } => { println!(\"{}\", url); } } 经常出现的Option就是一种enum enum Option是个标准库里经常用到的类型, 已经被preclude了, 不用use能直接用: enum Option { None, Some(T), } 它表示的含义是“要么存在、要么不存在”。比如Option表达的意思 就是“可以是一个i32类型的值，或者没有任何值”。 Rust引入Option是为了解决Null指针问题 如果你想定义一个可以为空值的类，你可以这样： let opt = Option::Some(\"Hello\"); // 这个opt的类型是core::option::Option 如果你想针对 opt 执行某些操作，你必须先判断它是否是 Option::None： fn main() { let opt = Option::Some(\"Hello\"); match opt { Option::Some(something) => { println!(\"{}\", something); }, Option::None => { println!(\"opt is nothing\"); } } } //结果 //Hello 由于 Option 是 Rust 编译器默认引入的，在使用时可以省略 Option:: 直接写 None 或者 Some()。 fn main() { let t = Some(64); match t { Some(64) => println!(\"Yes\"), _ => println!(\"No\"), } } 总结一下: 如果从逻辑上说，我们需要一个变量确实是可空的，那么就应该显式标明其类型为Option，否则应该直接声明为T类型。从类型系 统的角度来说，这二者有本质区别，切不可混为一谈 不要轻易使用unwrap方法。这个方法可能会导致程序发生 panic。对于小工具来说无所谓，在正式项目中，最好是使用lint工具强制禁止调用这个方法 相对于裸指针，使用Option包装的指针类型的执行效率不会降低，这是“零开销抽象” 不必担心这样的设计会导致大量的match语句，使得程序可读性变差。因为Option类型有许多方便的成员函数，再配合上闭包功能，实际上在表达能力和可读性上要更胜一筹 if let代替match match需要强制做全匹配, 否则会编译报错. 用下划线可以解决编译错误, 但有点笨. 用if let可以更好的表达只关心一部分匹配的情况: if let 匹配值 = 源变量 { 语句块 } 比如 let i = 0; if let 0 = i { println!(\"zero\"); } 更完整的例子: fn main() { enum Book { Papery(u32), Electronic(String) } let book = Book::Electronic(String::from(\"url\")); if let Book::Papery(index) = book { println!(\"Papery {}\", index); } else { println!(\"Not papery book\"); } } 表达式 小知识: ! 按位取反或者逻辑取反, 按照operand类型决定Rust不支持++、--运算符，请使用+=1、-=1替代 rust里面每个表达式都是有类型的, 比如赋值表达式的类型为空的tuple (), 也叫unit fn main() { let x = 1; let mut y = 2; // 注意这里专门用括号括起来了 let z = (y = x); println!(\"{:?}\", z); //编译有警告, 但能运行, 结果为() } 连续语句块的类型是最后一个表达式的类型: // 语句块可以是表达式,注意后面有分号结尾,x的类型是() let x : () = { println!(\"Hello.\"); }; // Rust将按顺序执行语句块内的语句,并将最后一个表达式类型返回,y的类型是 i32 let y : i32 = { println!(\"Hello.\"); 5 }; 利用这个特点, 函数的返回可以不写return fn my_func() -> i32 { // ... blablabla 各种语句 100 //最后一个表达式是100, 是i32. 注意没有分号 } if else fn func(i : i32) { if n 0 { print!(\"{} is positive\", n); } else { print!(\"{} is zero\", n); } } if else也可以当作表达式: let x : i32 = if condition { 1 } else { 10 }; //注意1和10后面不加分号. 因为加了分号表达式的整体类型就变了 if let和while let while-let与if-let一样，提供了在while语句中使用“模式解构”的能力 if let Some(x) = optVal { doSomethingWith(x); } 相当于: match optVal { Some(x) => { doSomethingWith(x); } _ => {} } 也相当于: if optVal.is_some() { // 首先判断它一定是 Some(_) let x = optVal.unwrap(); // 然后取出内部的数据 doSomethingWith(x); } 循环 loop 没条件注意break和continue都可以跳转到外层 我们可以在loop while for循环前面加上“生命周期标识符”。该标识符以单引号开头，在内部的循环中可以使用break语句选择跳出到哪一层。 fn main() { // A counter variable let mut m = 1; let n = 1; 'a: loop { if m 50 { println!(\"break\"); break 'a; } else { continue 'a; } } } } } loop表达式也可以做右值: fn main() { let v = loop { break 10; }; println!(\"{}\", v); } 在loop内部break的后面可以跟一个表达式，这个表达式就是最终的 loop表达式的值。如果一个loop永远不返回，那么它的类型就是“发散类型”。示例如下： fn main() { let v = loop {}; println!(\"{}\", v); //永远到不了这里 } while是带条件的循环 for in是迭代器循环. 没有三段式的语法 函数 fn add1(t : (i32,i32)) -> i32 { t.0 + t.1 } // 模式解构传参 fn add2((x,y) : (i32,i32)) -> i32 { x + y //也可以用return x+y } 函数不写返回类型默认是unit () 函数是一等公民 函数内部可以定义函数, 类型, trait等 虽然add1和add2的入参和出参都一样, 但每个函数都有自己的类型fn main() { // 先让 func 指向 add1 let mut func = add1; // 再重新赋值,让 func 指向 add2 func = add2; //这样不行, 会编译报错. 原因就是函数名也是类型的一部分 } 上面的func声明改成下面的写法就不会出错了:// 写法一,用 as 类型转换 let mut func = add1 as fn((i32,i32))->i32; // 写法二,用显式类型标记 let mut func : fn((i32,i32))->i32 = add1; 但只有add1和add2形式一样的时候才行. 形式不同不能转换. 发散函数Diverging functions 返回类型是!的函数是发散函数, 比如: fn diverges() -> ! { panic!(\"This function never returns!\"); } !可以转换为任何类型 let x : i32 = diverges(); let y : String = diverges(); 比如下面的情况就很有用: let p = if x { panic!(\"error\"); } else { 100 }; 上面的代码能编译通过, 因为!也可以赋值给p 内置发散函数: panic! 以及基于它实现的各种函数/宏，比如unimplemented! unreachable! 死循环loop{} 进程退出函数std::process::exit以及类似的libc中的exec一类函数 main函数 main函数没有入参和返回值, 命令行参数用std::env::args() fn main() { for arg in std::env::args() { println!(\"Arg: {}\", arg); } std::process::exit(0); } const_fn 函数可以用const关键字修饰，这样的函数可以在编译阶段被编译器执行，返回值也被视为编译期常量 #![feature(const_fn)] const fn cube(num: usize) -> usize { num * num * num } fn main() { const DIM : usize = cube(2); const ARR : [i32; DIM] = [0; DIM]; println!(\"{:?}\", ARR); } trait trait的意思是特性 初看和go的interface差不多. trait Shape { fn area(&self) -> f64; } Rust中Self（大写S）和self（小写s）都是关键字，大写S的是类型名，小写s的是变量名 所有的trait中都有一个隐藏的类型Self（大写S），代表当前这个实现了此trait的具体类型 trait T { fn method1(self: Self); fn method2(self: &Self); fn method3(self: &mut Self); } // 上下两种写法是完全一样的 trait T { fn method1(self); fn method2(&self); fn method3(&mut self); } 上面定义的这个area方法的参数的名字为self，它的类型是&Self类型。我们可以把上面这个方法的声明看成： trait Shape { fn area(self: &Self) -> f64; } 假如我们有一个结构体类型Circle，它实现了这个trait，代码如下: struct Circle { radius: f64, } impl Shape for Circle { // Self 类型就是 Circle // self 的类型是 &Self,即 &Circle fn area(&self) -> f64 { // 访问成员变量,需要用 self.radius std::f64::consts::PI * self.radius * self.radius } } fn main() { let c = Circle { radius : 2f64}; // 第一个参数名字是 self,可以使用小数点语法调用 println!(\"The area is {}\", c.area()); } 默认trait 这是特性与接口的不同点：接口只能规范方法而不能定义方法，但特性可以定义方法作为默认方法，因为是\"默认\"，所以对象既可以重新定义方法，也可以不重新定义方法使用默认的方法 trait中可以包含方法的默认实现。如果这个方法在trait中已经有了方法体，那么在针对具体类型实现的时候，就可以选择不用重写 trait Descriptive { fn describe(&self) -> String { String::from(\"[Object]\") } } struct Person { name: String, age: u8 } impl Descriptive for Person { fn describe(&self) -> String { format!(\"{} {}\", self.name, self.age) } } fn main() { let cali = Person { name: String::from(\"Cali\"), age: 24 }; println!(\"{}\", cali.describe()); } //结果 //Cali 24 如果Person不实现describe, 则最后打印 [Object] trait做参数 fn output(object: impl Descriptive) { println!(\"{}\", object.describe()); } 任何实现了 Descriptive 特性的对象都可以作为这个函数的参数，这个函数没必要了解传入对象有没有其他属性或方法，只需要了解它一定有 Descriptive 特性规范的方法就可以了。当然，此函数内也无法使用其他的属性与方法。 特性参数还可以用这种等效语法实现： fn output(object: T) { println!(\"{}\", object.describe()); } 这是一种风格类似泛型的语法糖，这种语法糖在有多个参数类型均是特性的情况下十分实用： fn output_two(arg1: T, arg2: T) { println!(\"{}\", arg1.describe()); println!(\"{}\", arg2.describe()); } 特性作类型表示时如果涉及多个特性，可以用 + 符号表示，例如： fn notify(item: impl Summary + Display) fn notify(item: T) 复杂的实现关系可以使用 where 关键字简化，例如： fn some_function(t: T, u: U) 可以简化成: fn some_function(t: T, u: U) -> i32 where T: Display + Clone, U: Clone + Debug 匿名trait 针对一个类型，我们可以直接对它impl来增加成员方法，无须trait名字。比如： impl Circle { fn get_radius(&self) -> f64 { self.radius } } 我们可以把这段代码看作是为Circle类型impl了一个匿名的trait。用这种方式定义的方法叫作这个类型的“内在方法”（inherent methods）。 Box trait Shape { fn area(self: Box) -> f64; } struct Circle { radius: f64, } impl Shape for Circle { // Self 类型就是 Circle // self 的类型是 Box,即 Box fn area(self : Box) -> f64 { // 访问成员变量,需要用 self.radius std::f64::consts::PI * self.radius * self.radius } } fn main() { let c = Circle { radius : 2f64}; // 编译错误 // c.area(); let b = Box::new(Circle {radius : 4f64}); // 编译正确 b.area(); } impl trait for trait 语法: impl for Rust 同一个类可以实现多个特性，每个 impl 块只能实现一个。 trait Shape { fn area(&self) -> f64; } trait Round { fn get_radius(&self) -> f64; } struct Circle { radius: f64, } impl Round for Circle { fn get_radius(&self) -> f64 { self.radius } } // 注意这里是 impl Trait for Trait impl Shape for dyn Round { fn area(&self) -> f64 { std::f64::consts::PI * self.get_radius() * self.get_radius() } } fn main() { let c = Circle { radius : 2f64}; // 编译错误 // c.area(); // let b = Circle { radius : 2f64} as dyn Round; //这样也不行, error[E0620]: cast to unsized type: `Circle` as `dyn Round` let b = Box::new(Circle {radius : 4f64}) as Box; // 编译正确 b.area(); } 注: 以上代码在edition2021编译不过, 需要在Round前面加dyn关键词(已加)加了以后上面代码能编过, 但有个变量c没有使用的警告. 为别人的类型实现trait 比如下面的代码就给内置类型i32实现了Double方法: trait Double { fn double(&self) -> Self; } impl Double for i32 { fn double(&self) -> i32 { *self * 2 } } fn main() { // 可以像成员方法一样调用 let x : i32 = 10.double(); println!(\"{}\", x); } 要给别人的类型添加方法, 需要满足下面的条件:impl块要么与trait的声明在同一个的crate中，要么与类型的声明在同一个crate中 trait不能做为参数, 返回值, 实例变量等需要明确知道size的地方 Rust是一种用户可以对内存有精确控制能力的强类型语言。我们可以自由指定一个变量是在栈里面，还是在堆里面，变量和指针也是不同的类型。类型是有大小（Size）的。有些类型的大小是在编译阶段可以确定的，有些类型的大小是编译阶段无法确定的。目前版本的Rust规定，在函数参数传递、返回值传递等地方，都要求这个类型在编译阶段有确定的大小。否则，编译器就不知道该如何生成代码了。 而trait本身既不是具体类型，也不是指针类型，它只是定义了针对类型的、抽象的“约束”。不同的类型可以实现同一个trait，满足同一个trait的类型可能具有不同的大小。因此，trait在编译阶段没有固定大小，目前我们不能直接使用trait作为实例变量、参数、返回值。 下面的代码是不对的: let x: Shape = Circle::new(); // Shape 不能做局部变量的类型 fn use_shape(arg : Shape) {} // Shape 不能直接做参数的类型 fn ret_shape() -> Shape {} // Shape 不能直接做返回值的类型 调用trait trait Cook { fn start(&self); } trait Wash { fn start(&self); } struct Chef; impl Cook for Chef { fn start(&self) { println!(\"Cook::start\"); } } impl Wash for Chef { fn start(&self) { println!(\"Wash::start\"); } } fn main() { let me = Chef; me.start(); //这里编不过, 因为两个trait都有start方法 } //应该用下面的格式来调用: fn main() { let me = Chef; // 函数名字使用更完整的path来指定,同时,self参数需要显式传递 // 下面两种格式都可以 ::start(&me); ::start(&me); } 方法的点引用是语法糖: 和go一样, 通过小数点语法调用方法调用，有一个“隐藏着”的“取引用”步骤。虽然我们看起来源代码长的是这个样子 me.start()，但是大家心里要清楚，真正传递给start()方法的参数是 &me而不是me，这一步是编译器自动帮我们做的。不论这个方法接受的self参数究竟是Self、&Self还是&mut Self，最终在源码上，我们都是统一的写法：variable.method() 方法和函数没有本质不同? struct T(usize); impl T { fn get1(&self) -> usize { self.0 } fn get2(&self) -> usize { self.0 } } fn get3(t: &T) -> usize { t.0 } fn check_type(_: fn(&T) -> usize) {} fn main() { check_type(T::get1); check_type(T::get2); check_type(get3); } 可以看到，get1、get2和get3都可以自动转成fn（&T）-> usize类型 trait约束 use std::fmt::Debug; fn my_print(x: T) { println!(\"The value is {:?}.\", x); } fn main() { my_print(\"China\"); my_print(41_i32); my_print(true); my_print(['a', 'b', 'c']) } 上面的代码能编过, 是因为my_print需要泛型T满足Debug约束(因为使用了{:?}), 而字符串, i32, bool, 数组都实现了Debug trait. 如果一个自定义类型没有实现Debug trait, 编译就会报错. 上面的约束还可以写成: fn my_print(x: T) where T: Debug { println!(\"The value is {:?}.\", x); } trait继承 实现Derived trait的struct也被要求实现Base trait trait Base {} trait Derived : Base {} //等同于trait Derived where Self：Base{} struct T; impl Derived for T {} impl Base for T {} //需要再加上这句 fn main() { ... } derive derive是个特殊的编译指示: #[derive(Copy, Clone, Default, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Foo { data: i32, } fn main() { let v1 = Foo { data: 0 }; let v2 = v1; println!(\"{:?}\", v2); } 意思是编译器会自动生成如下的代码: impl Copy for Foo { ... } impl Clone for Foo { ... } impl Default for Foo { ... } impl Debug for Foo { ... } impl Hash for Foo { ... } impl PartialEq for Foo { ... } ... 从而让Foo能够继承列表里的trait. 能够被derive的trait有: Debug Clone Copy Hash RustcEncodable RustcDecodable PartialEq Eq ParialOrd Ord Default FromPrimitive Send Sync 常见trait 只有实现了Display trait的类型，才能用{}格式控制打印出来；只有实现了Debug trait的类型，才能用{:?} {:#?}格式控制打印出来 // std::fmt::Display pub trait Display { fn fmt(&self, f: &mut Formatter) -> Result; } // std::fmt::Debug pub trait Debug { fn fmt(&self, f: &mut Formatter) -> Result; } 带关联类型的trait 标准库中有一个trait叫FromStr，它有一个关联类型代表错误： pub trait FromStr { type Err; fn from_str(s: &str) -> Result; } 如果某些类型调用from_str方法永远不会出错，那么这个Err类型可以指定为! use std::mem::{size_of, size_of_val}; use std::str::FromStr; struct T(String); impl FromStr for T { type Err = !; fn from_str(s: &str) -> Result { Ok(T(String::from(s))) } } fn main() { let r: Result = T::from_str(\"hello\"); println!(\"Size of T: {}\", size_of::()); println!(\"Size of Result: {}\", size_of_val(&r)); // 将来甚至应该可以直接用 let 语句进行模式匹配而不发生编译错误 // 因为编译器有能力推理出 Err 分支没必要存在 // let Ok(T(ref s)) = r; // println!(\"{}\", s); } 模式解构 struct T1(i32, char); struct T2 { item1: T1, item2: bool, } fn main() { let x = T2 { item1: T1(0, 'A'), item2: false, }; let T2 { item1: T1(value1, value2), item2: value3, } = x; //从x解构出value1, value2, value3; 后者直接就当变量用了 println!(\"{} {} {}\", value1, value2, value3); } 下划线用来占位: struct P(f32, f32, f32); fn calc(arg: P) -> f32 { // 匹配 tuple struct,但是忽略第二个成员的值 let P(x, _, y) = arg; x * x + y * y } fn main() { let t = P(1.0, 2.0, 3.0); println!(\"{}\", calc(t)); } match rust的match初看和switch case意思差不多: enum Direction { East, West, South, North, } fn print(x: Direction) { match x { Direction::East => { println!(\"East\"); } Direction::West => { println!(\"West\"); } Direction::South => { println!(\"South\"); } Direction::North => { println!(\"North\"); } } } fn main() { let x = Direction::East; print(x); } 但match更严格, 比如我们删除North分支, 编译会报错. 解决办法就是把不需要的分支用_覆盖: fn print(x: Direction) { match x { Direction::East => { println!(\"East\"); } Direction::West => { println!(\"West\"); } Direction::South => { println!(\"South\"); } _ => { println!(\"Other\"); } } } 类似的, 下面的match如果没有下划线那个分支, 也是编译不过的: fn category(x: i32) { match x { -1 => println!(\"negative\"), 0 => println!(\"zero\"), 1 => println!(\"positive\"), _ => println!(\"error\"), } } fn main() { let x = 1; category(x); } match还支持|操做和..范围操做: fn category(x: i32) { match x { -1 | 1 => println!(\"true\"), 0 => println!(\"false\"), _ => println!(\"error\"), } } fn main() { let x = 1; category(x); } let x = 'X'; match x { 'a' ..= 'z' => println!(\"lowercase\"), 'A' ..= 'Z' => println!(\"uppercase\"), _ => println!(\"something else\"), } match还支持在分支内加if判断: match x { OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"), OptionalInt::Value(..) => println!(\"Got an int!\"), OptionalInt::Missing => println!(\"No such luck.\"), } fn intersect(arg: i32) { match arg { i if i println!(\"case 1\"), i if i println!(\"case 2\"), i if i * i println!(\"case 3\"), _ => println!(\"default case\"), } } 还可以用@绑定变量. @符号前面是新声明的变量，后面是需要匹配的模式： let x = 1; match x { e @ 1 ..= 5 => println!(\"got a range element {}\", e), _ => println!(\"anything\"), } ref和mut ref: 引用, 避免出现所有权转移 mut: 借用 let mut x: &mut i32; 以上两处的mut含义是不同的。第1处mut，代表这个变量x本身可变，因此它能够重新绑定到另外一个变量上去，具体到这个示例来说，就是指针的指向可以变化。第2处mut，修饰的是指针，代表这个指针对于所指向的内存具有修改能力，因此我们可以用*x=1;这样的语句，改变它所指向的内存的值。 知晓变量类型 方案一: 利用编译错误来获取变量类型 // 这个函数接受一个 unit 类型作为参数 fn type_id(_: ()) {} fn main() { let ref x = 5_i32; // 实际参数的类型肯定不是 unit,此处必定有编译错误,通过编译错误,我们可以看到实参的具体类型 type_id(x); } 方案二: 使用标准库 #![feature(core_intrinsics)] fn print_type_name(_arg: &T) { unsafe { println!(\"{}\", std::intrinsics::type_name::()); } } fn main() { let ref x = 5_i32; print_type_name(&x); } 比如要知道下面的变量类型: let x = 5_i32; // i32 let x = &5_i32; // &i32 let ref x = 5_i32; // ??? let ref x = &5_i32; // ??? 代码: #![feature(core_intrinsics)] fn print_type_name(_arg: &T) { println!(\"{}\", std::intrinsics::type_name::()); } fn main() { let x = 5_i32; print_type_name(&x); //i32 let x = &5_i32; print_type_name(&x); //&i32 let ref x = 5_i32; print_type_name(&x); //&i32 let ref x = &5_i32; print_type_name(&x); //&&i32 } 注: 上面代码只能在debug优化模式和nightly channel下编译通过 方案三: 不需要nightly版本 fn print_type_of(_: &T) { println!(\"{}\", std::any::type_name::()) } 问号操作符 用在Result或Option后面, 用于提前返回或者unwrap value用在Result上, 可以提前返回Err(From::from(e)); 没有Error时则unwrap返回T fn try_to_parse() -> Result { let x: i32 = \"123\".parse()?; // x = 123 let y: i32 = \"24a\".parse()?; // returns an Err() immediately Ok(x + y) // Doesn't run. } let res = try_to_parse(); println!(\"{:?}\", res); 用在Option上, 可以提前返回None; 有值则unwrap返回T: fn try_option_some() -> Option { let val = Some(1)?; Some(val) } assert_eq!(try_option_some(), Some(1)); fn try_option_none() -> Option { let val = None?; Some(val) } assert_eq!(try_option_none(), None); 问号操作背后 代码rust/library/core/src/ops/try_trait.rs 问号operator背后是Try这个trait pub trait Try: FromResidual { type Output; type Residual; fn from_output(output: Self::Output) -> Self; fn branch(self) -> ControlFlow; } "},"notes/rust_入门2.html":{"url":"notes/rust_入门2.html","title":"泛型和内存所有权","keywords":"","body":"宏 比如打印当前文件和行号: fn main() { println!(\"file {} line {} \", file!(), line!()); } 比如避免重复: add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 } 比如初始化一个动态数组: let v = vec![1, 2, 3, 4, 5]; 泛型 max函数的入参是泛型T的数组 fn max(array: &[T]) -> T { let mut max_index = 0; let mut i = 1; while i array[max_index] { max_index = i; } i += 1; } array[max_index] } 结构体的泛型 struct Point { x: T, y: T } 可以这样用: let p1 = Point {x: 1, y: 2}; let p2 = Point {x: 1.0, y: 2.0}; 但这样不行: let p = Point {x: 1, y: 2.0}; x 与 1 绑定时就已经将 T 设定为 i32，所以不允许再出现 f64 的类型。如果我们想让 x 与 y 用不同的数据类型表示，可以使用两个泛型标识符： struct Point { x: T1, y: T2 } 结构体泛型的具化 可以让编译器自动推断, 也可以指定类型, 在左侧和右侧都可以, 但在右侧不支持S的语法: fn print_type_of(_: &T) { println!(\"{}\", std::any::type_name::()) } struct S { data: T, } fn main() { //let four: u32 = \"4\".parse(); //println!(\"{:?}\", four); let x = S { data: 6 }; //编译器自动推断 let y = S { data: 5.5 }; //编译器自动推断 let y1: S = S { data: 5.5 }; //声明y1是S let y2: S:: = S { data: 5.5 }; //声明y2是S:: //let y3 = S {data: 5.5}; //NOK, 编译不过, 编译器认为<>是大于小于号. 据说是编译器图简单 let y3 = S:: { data: 5.5 }; //显式实例化y3, 在右侧只能用双冒号 print_type_of(&x); print_type_of(&y); print_type_of(&y1); print_type_of(&y2); print_type_of(&y3); print_type_of(&\"4\".parse::()); } //结果 playground::S playground::S playground::S playground::S playground::S core::result::Result 枚举的泛型 比如 enum Option { Some(T), None, } 这里的实际上是声明了一个“类型”参数。在这个Option内部，Some(T)是一个tuple struct，包含一个元素类型为T。这个泛型参数类型T，可以在使用时指定具体类型。 使用的时候: let x: Option = Some(42); let y: Option = None; 泛型参数可以有默认值 比如下面的泛型T默认是i32 struct S { data: T } fn main() { let v1 = S { data: 0}; let v2 = S:: { data: false}; println!(\"{} {}\", v1.data, v2.data); } 函数中的泛型 比如: fn compare_option(first: Option, second: Option) -> bool { match(first, second) { (Some(..), Some(..)) => true, (None, None) => true, _ => false } } 注:Some(..)中的双点表示ignore全部, Some(_)表示ignore第一个参数. 再举例: fn largest(list: &[T]) -> &T { let mut largest = &list[0]; for item in list.iter() { if item > largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(&number_list); println!(\"The largest number is {}\", result); let char_list = vec!['y', 'm', 'a', 'q']; let result = largest(&char_list); println!(\"The largest char is {}\", result); } //结果 The largest number is 100 The largest char is y 泛型实现重载 比如str的contains方法就接受不同类型的参数: fn main() { let s = \"hello\"; println!(\"{}\", s.contains('a')); println!(\"{}\", s.contains(\"abc\")); println!(\"{}\", s.contains(&['H'] as &[char])); println!(\"{}\", s.contains(|c : char| c.len_utf8() > 2)); } 这个contains的签名是: fn contains>(&'a self, pat: P) -> bool 第二个参数pat是个泛型P, 只要满足Pattern trait, 就能被contains所用. 重载需要判断类型 下面的代码编译不过, 因为let f = i.convert();中, 编译器无法知道f的类型, 于是无法推断出应该调用哪个. trait ConvertTo { fn convert(&self) -> T; } impl ConvertTo for i32 { fn convert(&self) -> f32 { *self as f32 } } impl ConvertTo for i32 { fn convert(&self) -> f64 { *self as f64 } } fn main() { let i = 1_i32; let f = i.convert(); // 这里编译不过 println!(\"{:?}\", f); } 要这样改: let f : f32 = i.convert(); // 或者 let f = ConvertTo::::convert(&i); impl块中的泛型 可以impl 某个trait for type, 也可以为trait impl trait. 即trait for trait. 这个impl trait for trait比如: impl Into for T where U: From, { fn into(self) -> U { U::from(self) } } 泛型的约束 下面的代码编译不通过: fn max(a: T, b: T) -> T { if a 因为并不是所有类型都实现了比较操作, 那么泛型T没有约束的话, 是编译不过的. 加约束有两个写法: 冒号方式 use std::cmp::PartialOrd; // 第一种写法：在泛型参数后面用冒号约束 fn max(a: T, b: T) -> T { where语法 // 第二种写法,在后面单独用 where 子句指定 fn max(a: T, b: T) -> T where T: PartialOrd where语法灵活性更好: trait Iterator { type Item; // Item 是一个关联类型 // 此处的where子句没办法在声明泛型参数的时候写出来 fn max(self) -> Option where Self: Sized, Self::Item: Ord, { ... } ... } 它要求Self类型满足Sized约束，同时关联类型Self::Item要满足Ord约束，这是用冒号语法写不出来的。 比较泛型的完整代码: use std::cmp::Ordering; use std::cmp::PartialOrd; fn max(a: T, b: T) -> T where T: PartialOrd, { if a Option { self.value.partial_cmp(&other.value) } } impl PartialEq for T { fn eq(&self, other: &T) -> bool { self.value == other.value } } fn main() { let t1 = T { value: 1 }; let t2 = T { value: 2 }; let m = max(t1, t2); } 注意由于标准库中的PartialOrd继承了PartialEq，因此单独实现PartialOrd 还是会产生编译错误，必须同时实现PartialEq才能编译通过。 关联类型 trait中不仅可以包含方法（包括静态方法）、常量，还可以包含“类型”。 比如迭代器中的Item就是个关联类型, 关联类型也必须指定才能实例化. pub trait Iterator { type Item; ... } 可以看到，我们希望参数是一个泛型迭代器，可以在约束条件中写Iterator。跟普通泛型参数比起来，关联类型参数必须使用名字赋值的方式。 use std::fmt::Debug; use std::iter::Iterator; fn use_iter(mut iter: ITER) where ITER: Iterator, ITEM: Debug, { while let Some(i) = iter.next() { println!(\"{:?}\", i); } } fn main() { let v: Vec = vec![1, 2, 3, 4, 5]; use_iter(v.iter()); } 也可以将ITEM ITER简化为一个, 因为满足ITER: Iterator, 就可以继续声明其关联类型需要满足的约束ITER::Item: Debug use std::fmt::Debug; use std::iter::Iterator; fn use_iter(mut iter: ITER) where ITER: Iterator, ITER::Item: Debug, { while let Some(i) = iter.next() { println!(\"{:?}\", i); } } fn main() { let v: Vec = vec![1, 2, 3, 4, 5]; use_iter(v.iter()); } trait for trait 下面的例子中, 为一个泛型T, 实现了ToString trait pub trait ToString { fn to_string(&self) -> String; } impl ToString for T { #[inline] fn to_string(&self) -> String { use core::fmt::Write; let mut buf = String::new(); let _ = buf.write_fmt(format_args!(\"{}\", self)); buf.shrink_to_fit(); buf } } 凡是实现了这个trait的类型，都可以调用to_string来得到一个String 类型的结果。同时，标准库中还存在一个std::fmt::Display trait， 也可以做到类似的事情。而且Display是可以通过#[derive（Display）]由 编译器自动实现的。所以，我们可以想到，针对所有满足T: Display的类型，我们可以为它们提供一个统一的实现. 泛型的方法 struct Point { x: T, y: T, } //注意下面的第一个是类型声明, 第二个是\"实例化\"这个Point, 虽然是用泛型来\"实例化\" //所以写成这样也可以的: impl Point:: { impl Point { fn x(&self) -> &T { &self.x } } fn main() { let p = Point { x: 1, y: 2 }; println!(\"p.x = {}\", p.x()); } 内存安全 生命周期 fn main() { let v = vec![1, 2, 3, 4, 5]; // --> v 的生命周期开始 { let center = v[2]; // --> center 的生命周期开始 println!(\"{}\", center); } // 生命周期标记 引用往往导致极其复杂的资源管理问题，首先认识一下垂悬引用： { let r; { let x = 5; r = &x; } println!(\"r: {}\", r); } 这段代码是不会通过 Rust 编译器的，原因是 r 所引用的值已经在使用之前被释放。上图中的绿色范围 'a 表示 r 的生命周期，蓝色范围 'b 表示 x 的生命周期。很显然，'b 比 'a 小得多，引用必须在值的生命周期以内才有效 下面的例子中 longer函数不能编译通过 fn longer(s1: &str, s2: &str) -> &str { if s2.len() > s1.len() { s2 } else { s1 } } 原因是返回值引用可能会返回过期的引用, 一般情况下, 编译器可以推导出返回值的生命周期标记, 比如函数只有唯一入参的时候; 但这里编译器不知道到底返回的引用是s1还是s2 fn main() { let r; { let s1 = \"rust\"; let s2 = \"ecmascript\"; r = longer(s1, s2); } println!(\"{} is longer\", r); } 把longer函数改成带生命周期声明的方式, 就可以成功运行了: fn longer(s1: &'a str, s2: &'a str) -> &'a str { if s2.len() > s1.len() { s2 } else { s1 } } fn main() { let r; { let s1 = \"rust\"; let s2 = \"ecmascript\"; r = longer(s1, s2); } println!(\"{} is longer\", r); //println!(\"s2: {}\", s2); } //ecmascript is longer 可以看到, r实际引用的s2, s2的内容在出了scope后还能被r引用. 但直接打印s2是不行的, 会报错误:cannot find value s2 in this scope 生命周期注释用单引号开头，跟着一个小写字母单词： &i32 // 常规引用 &'a i32 // 含有生命周期注释的引用 &'a mut i32 // 可变型含有生命周期注释的引用 'static // 特殊的生命周期标记, 表示静态, 好像是全局的意思 下面的写法是一样的: fn test(arg: &'a T) -> &'a i32 fn test(arg: &'a T) -> &'b i32 where 'a:'b //'a:'b表示'a比'b“活”得长 类型的生命周期标记 如果自定义类型中有成员包含生命周期参数，那么这个自定义类型 也必须有生命周期参数: struct Test { member: &'a str } 在使用impl的时候，也需要先声明再使用: impl Test { fn test(&self, s: &'a str) { } } 如果在泛型约束中有where T: 'a之类的条件，其意思是，类型T的所有生命周期参数必须大于等于'a。要特别说明的是，若是有where T: 'static的约束，意思则是，类型T里面不包含任何指向短生命周期的借用指针，意思是要么完全不包含任何借用，要么可以有指向'static的借用指针。 省略生命周期标记 fn get_str(s: &String) -> &str { s.as_ref() } 等同于 fn get_str(s: &'a String) -> &'a str { s.as_ref() } 所有权 下面的代码编译不过: fn main() { let s = String::from(\"hello\"); let s1 = s; println!(\"{}\", s); } 出现错误的原因是let s1 = s;导致了所有权转移, 转移后s就不能再访问了. 每个值只有一个所有者。变量s的生命周期从声明开始，到move给s1就结束了。变量s1的生命周期则是从它声明开始， 到函数结束。而字符串本身，由String::from函数创建出来，到函数结束的时候就会销毁。中间所有权的转换，并不会将这个字符串本身重新销毁再创建。在任意时刻，这个字符串只有一个所有者，要么是s， 要么是s1。 一个变量可以把它拥有的值转移给另外一个变量，称为“所有权转移”。赋值语句、函数调用、函数返回等，都有可能导致所有权转移。 Rust中的变量绑定操作，默认是move语义，执行了新的变量绑定后，原来的变量就不能再被使用！一定要记住！ 就是说rust里面的赋值语句实际上是移动语义.但是有例外: 比如下面的代码就可以编译通过: fn main() { let v1 : isize = 0; let v2 = v1; println!(\"{}\", v1); } 因为在Rust中有一部分“特殊照顾”的类型，其变量绑定操作是copy语义。实现了copy trait的类型就会在assign的时候使用copy. 所谓的copy语义，是指在执行变量绑定操作的时候，v2是对v1所属数据的一份复制。v1所管理的这块内存依然存在，并未失效，而v2是新开辟了一块内存，它的内容是从v1管理的内存中复制而来的。和手动调用clone方法效果一样，let v2=v1；等效于let v2=v1.clone() Rust中，在普通变量绑定、函数传参、模式匹配等场景下，凡是实 现了std::marker::Copy trait的类型，都会执行copy语义。基本类型，比如数字、字符、bool等，都实现了Copy trait，因此具备copy语 义。 对于自定义类型，默认是没有实现Copy trait的，但是我们可以手动添上。 要实现这个copy trait: #[derive(Copy, Clone)] struct Foo { data : i32 } fn main() { let v1 = Foo { data : 0 }; let v2 = v1; println!(\"{:?}\", v1.data); } Rust中的copy语义就是浅复制 所有权规则 Rust中的每一个值都有一个对应的变量作为它的所有者 。 在同一时间内，值有且仅有一个所有者。 Rc允许多个所有权的owner 当所有者离开自己的作用域时，它持有的值就会被释放掉。 数据赋值和拷贝 Rust永远不会自动地创 建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可以被视为高效的。 let s1 = String::from(\"hello\"); //s1在堆里 let s2 = s1; // s2是s1的浅拷贝, 同时s1失效 println!(\"{}, world!\", s1); //这里会报错, 因为所有权已经move了 //后面s2拥有对应的数据, s2退出作用域的时候, drop函数被自动调用以释放空间 但下面的代码也是对的, 因为i32有Copy trait let x = 5; let y = x; println!(\"x = {}, y = {}\", x, y); 有copy trait的类型有: 所有的整数类型，诸如u32 仅拥有两种值（true和false）的布尔类型：bool 字符类型：char 所有的浮点类型，诸如f64 如果元组包含的所有字段的类型都是Copy的，那么这个元组也 是Copy的。例如，(i32, i32)是Copy的，但(i32, String)则不是 所有权与函数 将值传递给函数在语义上类似于对变量进行赋值。将变量传递给 函数将会触发移动或复制，就像是赋值语句一样。 fn main() { let s = String::from(\"hello\"); // 变量s进入作用域 take_ownership(s); // s的值被移动进了函数 // 所以它从这里开始不再有效 let x = 5; // 变量x进入作用域 make_copy(x); // 变量x同样被传递进了函数 //但由于i32是copy的, 所以我们依然可以在这之后使用x } // x首先离开作用域, 随后是s. 但由于s的值已经发生了移动, 所以没什么特别的事情发生. fn take_ownership(some_string: String) { // some_string进入作用域 println!(\"{}\", some_string); } // some_string在这里离开作用域, 它的drop函数被自动调用, 其所占的内存也随之被释放了 fn make_copy(some_integer: i32) { // some_integer进入作用域 println!(\"{}\", some_integer); } // some_integer在这里离开了作用域, 没有什么特别的事情发生 返回值与作用域 函数在返回值的过程中也会发生所有权的转移。 fn main() { let s1 = give_ownership(); // 返回值移动至s1中 let s2 = String::from(\"hello\"); // s2进入作用域 let s3 = take_and_giveback(s2); // s2被移动进函数, 而这个函数的返回值又被移动到了s3上 } // s3在这里离开作用域并被销毁. 由于s2已经移动了, 所以它不会在离开作用域的时候发生任何事情. s1最后离开作用域并被销毁. // give_ownership 会将它的返回值移动至调用它的函数内 fn give_ownership() -> String { let some_string = String::from(\"hello\"); // some_string进入作用域 some_string // some_string做为返回值移动到调用函数 } // take_and_giveback 将取得一个String的所有权并将它做为结果返回 fn take_and_giveback(a_string: String) -> String { // a_string进入作用域 a_string // a_string做为返回值移动至调用函数 } println不会发生所有权转移(move) 因为println是宏, 比如下面的代码: fn main() { let x = 5; println!(\"{}\", x); } 用这个命令rustc -Z unstable-options --pretty expanded得到下面宏展开的代码: #![feature(prelude_import)] #[prelude_import] use std::prelude::v1::*; #[macro_use] extern crate std; fn main() { let x = 5; { ::std::io::_print(::core::fmt::Arguments::new_v1( &[\"\", \"\\n\"], &match (&x,) { (arg0,) => [::core::fmt::ArgumentV1::new( arg0, ::core::fmt::Display::fmt, )], }, )); }; } 化简后是借用传参的. use std::{fmt, io}; fn main() { let x = 5; io::_print(fmt::Arguments::new_v1( &[\"\", \"\\n\"], &[fmt::ArgumentV1::new(&x, fmt::Display::fmt)], // ^^ )); } Rc允许多个所有权拥有者 To enable multiple ownership, Rust has a type called Rc, which is an abbreviation for reference counting. The Rc type keeps track of the number of references to a value to determine whether or not the value is still in use. enum List { Cons(i32, Box), Nil, } use crate::List::{Cons, Nil}; fn main() { let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); println!(\"count after creating a = {}\", Rc::strong_count(&a)); let b = Cons(3, Rc::clone(&a)); println!(\"count after creating b = {}\", Rc::strong_count(&a)); { let c = Cons(4, Rc::clone(&a)); println!(\"count after creating c = {}\", Rc::strong_count(&a)); } println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a)); } //结果 $ cargo run Compiling cons-list v0.1.0 (file:///projects/cons-list) Finished dev [unoptimized + debuginfo] target(s) in 0.45s Running `target/debug/cons-list` count after creating a = 1 count after creating b = 2 count after creating c = 3 count after c goes out of scope = 2 注: 用Rc::clone(&a)和a.clone()是一样的. 前者更隐含了是浅拷贝的意思, 开销非常小. 引用和借用 引用方式传递也叫借用, 所有权不转移. 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。 引用总是有效的。 fn dangle() -> &String{ // dangle会返回一个指向String的引用 let s = String::from(\"hello\"); // s被绑定到新的String上 &s // 我们将指向s的引用返回给调用者 } // 变量s在这里离开作用域并随之被销毁, 它指向的内存自然也不再有效. // 危险! copy和clone copy是std::marker::Copy 带marker的都是特殊的trait, 编译器会有特殊处理一旦一个类型实现了Copy trait，那么它在变量绑定、函数参数传递、函数返回值传递等场景下，都是copy语义，而不再是默认的move语义。并不是所有的类型都可以实现Copy trait。Rust规定，对于自定义类型，只有所有成员都实现了Copy trait，这个类型才有资格实现Copy trait。常见的数字类型、bool类型、共享借用指针&，都是具有Copy属性的类型。而Box、Vec、可写借用指针&mut等类型都是不具备Copy属性的类型。 对于数组类型，如果它内部的元素类型是Copy，那么这个数组也是 Copy类型。 对于元组tuple类型，如果它的每一个元素都是Copy类型，那么这个 tuple也是Copy类型。 clone是std::clone::Clone pub trait Clone: Sized { fn clone(&self) -> Self; fn clone_from(&mut self, source: &Self) { *self = source.clone() } } 即使实现了clone trait的对象, 在赋值的时候也是move语义. 举例: // A unit struct without resources #[derive(Debug, Clone, Copy)] struct Unit; // A tuple struct with resources that implements the `Clone` trait #[derive(Clone, Debug)] struct Pair(Box, Box); fn main() { // Instantiate `Unit` let unit = Unit; // Copy `Unit`, there are no resources to move let copied_unit = unit; // Both `Unit`s can be used independently println!(\"original: {:?}\", unit); println!(\"copy: {:?}\", copied_unit); // Instantiate `Pair` let pair = Pair(Box::new(1), Box::new(2)); println!(\"original: {:?}\", pair); // Move `pair` into `moved_pair`, moves resources let moved_pair = pair; println!(\"moved: {:?}\", moved_pair); // Error! `pair` has lost its resources //println!(\"original: {:?}\", pair); // TODO ^ Try uncommenting this line // Clone `moved_pair` into `cloned_pair` (resources are included) let cloned_pair = moved_pair.clone(); // Drop the original pair using std::mem::drop drop(moved_pair); // Error! `moved_pair` has been dropped //println!(\"copy: {:?}\", moved_pair); // TODO ^ Try uncommenting this line // The result from .clone() can still be used! println!(\"clone: {:?}\", cloned_pair); } 总结: Copy内部没有方法，Clone内部有两个方法。 Copy trait是给编译器用的，告诉编译器这个类型默认采用copy语 义，而不是move语义。 Clone trait是给程序员用的，赋值操作还是move语义. 我们必须手动调用 clone方法，它才能发挥作用。 Copy trait不是想实现就能实现的，它对类型是有要求的，有些类型不可能impl Copy。而Clone trait则没有什么前提条件，任何类型都可以实现（unsized类型除外，因为无法使用unsized类型作为返回值） Copy trait规定了这个类型在执行变量绑定、函数参数传递、函数返回等场景下的操作方式。即这个类型在这种场景下，必然执行的 是“简单内存复制”操作，这是由编译器保证的，程序员无法控制。 Clone trait里面的clone方法究竟会执行什么操作，则是取决于程序员自己写的逻辑。一般情况下，clone方法应该执行一个“深复制”操作，但这不是强制性的，如果你愿意，在里面启动一个人工智能程序都是有可能的。 析构函数 rust没有构造函数, 但允许析构函数: 用户可以自己写满足std::ops::Drop的trait trait Drop { fn drop(&mut self); } 这个Drop会在变量声明周期结束的时候被调用. 自己调用Drop是非法的, 但可以间接调用标准库的drop函数: use std::mem::drop; fn main() { let mut v = vec![1, 2, 3]; // v的生命周期结束 v.push(4); // 错误的调用 } 其实, 标准库的drop就是入参是值传递的空函数: #[inline] pub fn drop(_x: T) { } 这里入参是值传递非常重要, 将对象的所有权移入函数中，什么都不用做，编译器就会自动释放掉这个对象了。 因为这个drop函数的关键在于使用move语义把参数传进来，使得变量的所有权从调用方移动到drop函数体内，参数类型一定要是T，而不是&T或者其他引用类型。函数体本身其实根本不重要，重要的是把变量的所有权move进入这个函数体中，函数调用结束的时候该变量的生命周期结束，变量的析构函数会自动调用，管理的内存空间也会自然释放。这个过程完全符合前面讲的生命周期、move语义，无须编译器做特殊处理。事实上，我们完全可以自己写一个类似的函数来实现同样的效果，只要保证参数传递是move语义即可。 因此, 有copy()语义的变量, 对其drop()是没有作用的, 因为这些变量是复制不是move. mut和&mut mut可以出现在绑定(=)的左右两侧 fn main() { let mut var = 0_i32; { let p1 = &mut var; // p1 指针本身不能被重新绑定,我们可以通过p1改变变量var的值 *p1 = 1; } { let temp = 2_i32; let mut p2 = &var; // 我们不能通过p2改变变量var的值,但p2指针本身指向的位置可以被改变 p2 = &temp; } { let mut temp = 3_i32; let mut p3 = &mut var; // 我们既可以通过p3改变变量var的值,而且p3指针本身指向的位置也可以改变 *p3 = 3; p3 = &mut temp; } } 借用指针 借用指针不能比它指向的变量存在的时间更长 &mut型借用只能指向本身具有mut修饰的变量，对于只读变量，不可以有&mut型借用 &mut型借用指针存在的时候，被借用的变量本身会处于“冻结”状态 如果只有&型借用指针，那么能同时存在多个；如果存在&mut型借用指针，那么只能存在一个；如果同时有其他的&或者&mut型借用指针存在，那么会出现编译错误 // 这里的参数采用的“引用传递”,意味着实参本身并未丢失对内存的管理权 fn borrow_semantics(v: &Vec) { // 打印参数占用空间的大小,在64位系统上,结果为8,表明该指针与普通裸指针的内部表示方法相同 println!(\"size of param: {}\", std::mem::size_of::>()); for item in v { print!(\"{} \", item); } println!(\"\"); } // 这里的参数采用的“值传递”,而Vec没有实现Copy trait,意味着它将执行move语义 fn move_semantics(v: Vec) { // 打印参数占用空间的大小,结果为24,表明实参中栈上分配的内存空间复制到了函数的形参中 println!(\"size of param: {}\", std::mem::size_of::>()); for item in v { print!(\"{} \", item); } println!(\"\"); } fn main() { let array = vec![1, 2, 3]; // 需要注意的是,如果使用引用传递,不仅在函数声明的地方需要使用&标记 // 函数调用的地方同样需要使用&标记,否则会出现语法错误 // 这样设计主要是为了显眼,不用去阅读该函数的签名就知道这个函数调用的时候发生了什么 // 而小数点方式的成员函数调用,对于self参数,会“自动转换”,不必显式借用,这里有个区别 borrow_semantics(&array); // 在使用引用传递给上面的函数后,array本身依然有效,我们还能在下面的函数中使用 move_semantics(array); // 在使用move语义传递后,array在这个函数调用后,它的生命周期已经完结 } 任何借用指针的存在，都会导致原来的变量被“冻结”（Frozen）: fn main() { let mut x = 1_i32; let p = &mut x; x = 2; // 因为p的存在，此时对x的改变被认为是非法的 println!(\"value of pointed : {}\", p); } 为什么rust是内存安全的? 比如c语言在迭代vector的时候, 改变vector自身, 编译的时候没问题, 但运行时会崩溃; 而rust在编译时就会报错, 因为rust的原则是: 共享不可变，可变不共享 首先我们介绍一下这两个概念Alias和Mutation。 Alias的意思是“别名”。如果一个变量可以通过多种Path来访问，那它们就可以互相看作alias。Alias意味着“共享”，我们可以通过多个入口访问同一块内存。 Mutation的意思是“改变”。如果我们通过某个变量修改了一块内存，就是发生了mutation。Mutation意味着拥有“修改”权限，我们可以写入数据。 Rust保证内存安全的一个重要原则就是，如果能保证alias和 mutation不同时出现，那么代码就一定是安全的. 为什么在Rust中永远不会出现迭代器失效这样的错误？因为通 过“mutation+alias”规则，就可以完全杜绝这样的现象，这个规则是Rust 内存安全的根，是解决内存安全问题的灵魂。 Rust防范“内存不安全”代码的原则极其清晰明了。如果你对同一块内存存在多个引用，就不要试图对这块内存做修改；如果你需要对一块内存做修改，就不要同时保留多个引用。只要保证了这个原则，我们就可以保证内存安全。它在实践中发挥了强大的作用，可以帮助我们尽早发现问题。这个原则是Rust的立身之本、生命之基、活力之源。 注: std::cell::Cell可以\"突破\"这个“唯一修改权”的原则. 但实际上, Cell被小心的设计成一个包裹, 支持多个共享引用, 可以内部可变. 解引用 和c一样, 用*解引用 自定义解引用 实现std::ops::Deref或者std::ops::DerefMut这两个trait就能自定义解引用 pub trait Deref { type Target: ?Sized; fn deref(&self) -> &Self::Target; } pub trait DerefMut: Deref { fn deref_mut(&mut self) -> &mut Self::Target; } *expr的类型是Target，而 deref()方法返回的类型却是&Target 常见指针类型 Box是“指针”，指向一个在堆上分配的对象 Vec是“指针”，指向一组同类型的顺序排列的堆上分配的对象，且携带有当前缓存空间总大小和元素个数大小的元数据 String是“指针”，指向的是一个堆上分配的字节数组，其中保存的内容是合法的utf8字符序列。且携带有当前缓存空间总大小和字符串实际长度的元数据 以上几个类型都对所指向的内容拥有所有权，管理着它们所指向的内存空间的分配和释放 Rc和Arc也是某种形式的、携带了额外元数据的“指针”，它们提供的是一种“共享”的所有权，当所有的引用计数指针都销毁之后，它们所指向的内存空间才会被释放 自动解引用 len的函数签名是:fn len(&self) -> usize 按理说只有形式是&str的参数才行, 但下面的代码都正确: fn main() { let s = \"hello\"; println!(\"length: {}\", str::len(&s)); println!(\"length: {}\", str::len(s)); println!(\"length: {}\", s.len()); println!(\"length: {}\", (&s).len()); println!(\"length: {}\", (&&&&&&&&&&&&&s).len()); } 这是因为Rust编译器帮我们做了隐式的deref调用，当它找不到这个成员方法的时候，会自动尝试使用deref方法后再找该方法，一 直循环下去。所以&&&&&&&&&&str会被正确解引用 自动deref的规则是，如果类型T可以解引用为U，即T：Deref， 则&T可以转为&U Rc的自动解引用 Rc是带引用计数的智能指针, 它实现了Deref trait impl Deref for Rc { type Target = T; #[inline(always)] fn deref(&self) -> &T { &self.inner().value } } 它的Target类型是它的泛型参数T。这么设计有什么好处呢？我们 看下面的用法： use std::rc::Rc; fn main() { let s = Rc::new(String::from(\"hello\")); println!(\"{:?}\", s.bytes()); } 我们创建了一个指向String类型的Rc指针，并调用了bytes()方 法。这里是不是有点奇怪？这里的机制是这样的：Rc类型本身并没有bytes()方法，所以编译器会尝试自动deref，试试s.deref().bytes()。 String类型其实也没有bytes()方法，但是String可以继续deref，于是再试试s.deref().deref().bytes()。 这次在str类型中找到了bytes()方法，于是编译通过。 我们实际上通过Rc类型的变量调用了str类型的方法，让这个智能指针透明。这就是自动Deref的意义。 这就是为什么String需要实现Deref trait，是为了让&String类型的变量可以在必要的时候自动转换为&str类型。所以String类型的变量可以直接调用str类型的方法。比如： let s = String::from(\"hello\"); let len = s.bytes(); 虽然s的类型是String，但它在调用bytes()方法的时候，编译器会自动查找并转换为s.deref().bytes()调用。所以String类型的变量就可以直接调用str类型的方法了。 同理：Vec类型也实现了Deref trait，目标类型是[T]，&Vec类型的变量就可以在必要的时候自动转换为&[T]数组切片类型；Rc类型也实现了Deref trait，目标类型是T，Rc类型的变量就可以直接调用T类型的方法。 引用计数 普通变量绑定自身消亡的时候，这块内存就会被释放。引用计数智能指针给我们提供了另外一种选择：一块不可变内存可以有多个所有者，当所有的所有者消亡后，这块内存才会被释放。 std：：rc：：Rc: Rc是普通的引用计数, 只能单线程使用 std：：sync：：Arc: Arc是atomic Rc, 多线程安全 一般Rust不允许多owner, 但Rc可以突破这个限制: use std::rc::Rc; struct SharedValue { value: i32, } fn main() { let shared_value: Rc = Rc::new(SharedValue { value: 42 }); let owner1 = shared_value.clone(); let owner2 = shared_value.clone(); //shared_value.value = 88; 这句编译不过, 因为Rc就被设计成引用计数, 而不是共享变量. 用Cell来解决变量共享问题. println!(\"value : {} {}\", owner1.value, owner2.value); println!(\"address : {:p} {:p}\", &owner1.value, &owner2.value); } 运行结果: $ ./test value : 42 42 address : 0x13958abdf20 0x13958abdf20 这说明，owner1 owner2里面包含的数据不仅值是相同的，而且地址也是相同的。这正是Rc的意义所在。 如果要创建指向同样 内存区域的多个Rc指针，需要显式调用clone函数。请注意，Rc指针是 没有实现Copy trait的。如果使用直接赋值方式，会执行move语义，导致前一个指针失效，后一个指针开始起作用，而且引用计数值不变。如果需要创造新的Rc指针，必须手工调用clone()函数，此时引用计数值才会加1。当某个Rc指针失效，会导致引用计数值减1。当引用计数值减到0的时候，共享内存空间才会被释放。 cow 写时拷贝. 它对指向的数据可能“拥有所有权”，或者 可能“不拥有所有权”。 当它只需要对所指向的数据进行只读访问的时候，它就只是一个借用指针；当它需要写数据功能时，它会先分配内存，执行复制操作，再对自己拥有所有权的内存进行写入操作。 在标准库里: pub enum Cow where B: ToOwned { /// Borrowed data. Borrowed(&'a B), /// Owned data. Owned(::Owned) } 它可以是Borrowed或者Owned两种状态。如果是Borrowed状态，可以通过调用to_mut()函数获取所有权。在这个过程中，它实际上会分配一块新的内存，并将原来Borrowed状态的数据通过调用to_owned()方法 构造出一个新的拥有所有权的对象，然后对这块拥有所有权的内存执行操作。 比如下面的remove_spaces()函数, 如果入参没有空格, 就只返回借用; 如果有空格, 就返回一个新申请的有所有权的对象buf. use std::borrow::Cow; fn remove_spaces(input: &'a str) -> Cow { if input.contains(' ') { let mut buf = String::with_capacity(input.len()); for c in input.chars() { if c != ' ' { buf.push(c); } } return Cow::Owned(buf); } return Cow::Borrowed(input); } fn main() { let s1 = \"no_spaces_in_string\"; let result1 = remove_spaces(s1); let s2 = \"spaces in string\"; let result2 = remove_spaces(s2); println!(\"{}\\n{}\", result1, result2); } 为什么这里要用Cow呢? 因为这个函数的返回值类型用&str类 型和String类型都不大合适。 如果返回类型指定为&str类型，那么需要新分配内存的时候，会出现生命周期编译错误。因为函数内部新分配的字符串的引用不能在函数调用结束后继续存在。 如果返回类型指定为String类型，那么对于那种不需要对输入参数做修改的情况，有一些性能损失。因为输入参数&str类型转为String类 型需要分配新的内存空间并执行复制，性能开销较大。这种时候使用Cow类型就是不二之选。既能满足编译器的生命周期要求，也避免了无谓的数据复制。Cow类型，就是优秀的“零性能损失抽象”的设计范例。 Cow类型还实现了Deref trait，所以当我们需要调用类型T的成员函数的时候，可以直接调用，完全无须考虑后面具体是“借用指针”还是“拥有所有权的指针”。所以我们也可以把它当成是一种“智能指针”。 智能指针 上面提到的Rc和Cow都是智能指针.Rust中允许一部分运算符可以由用户自定义行为，即“操作符重载”。其中“解引用”是一个非常重要的操作符，它允许重载。 而需要提醒大家注意的是，“取引用”操作符，如&、&mut，是不允许重载的。因此，“取引用”和“解引用”并非对称互补关系。*&T的类型 一定是T，而&*T的类型未必就是T。 更重要的是，读者需要理解，在某些情况下，编译器帮我们插入了自动deref的调用，简化代码。 在Deref的基础上，我们可以封装出一种自定义类型，它可以直接调用其内部的其他类型的成员方法，我们可以把这种类型称为智能指针类型 其他 在方法里定义struct是可以的 impl Clone for Box { fn clone(&self) -> Self { let mut new = BoxBuilder { data: RawVec::with_capacity(self.len()), len: 0, }; let mut target = new.data.ptr(); for item in self.iter() { unsafe { ptr::write(target, item.clone()); target = target.offset(1); }; new.len += 1; } return unsafe { new.into_box() }; // Helper type for responding to panics correctly. struct BoxBuilder { data: RawVec, len: usize, } impl BoxBuilder { unsafe fn into_box(self) -> Box { let raw = ptr::read(&self.data); mem::forget(self); raw.into_box() } } impl Drop for BoxBuilder { fn drop(&mut self) { let mut data = self.data.ptr(); let max = unsafe { data.offset(self.len as isize) }; while data != max { unsafe { ptr::read(data); data = data.offset(1); } } } } } } 为什么明明可以直接在一个方法里写完的代码，还要引入一个新的类型呢？原因就在于panic safety问题。注意我们这里调用了T类型的 clone方法。T是一个泛型参数，谁能保证clone方法不会产生panic？没有谁能保证，我们只能尽可能让clone发生panic的时候，RawVec的状态不会乱掉。 所以，标准库的实现利用了RAII机制，即便在clone的时候发生了 panic，这个BoxBuilder类型的局部变量的析构函数依然会正确执行，并在析构函数中做好清理工作。上面这段代码之所以搞这么复杂，就是为了保证在发生panic的时候逻辑依然是正确的。大家可以去翻一下标准库中的代码，有大量类似的模式存在，都是因为需要考虑panic safety问题。Rust的标准库在编写的时候有这样一个目标：即便发生了panic，也不会产生“内存不安全”和“线程不安全”的情况。 文件打开 use std::fs::File; use std::io::Read; fn main() { let f = File::open(\"/target/file/path\"); if f.is_err() { println!(\"file is not exist.\"); return; } let mut f = f.unwrap(); let mut content = String::new(); let result = f.read_to_string(&mut content); if result.is_err() { println!(\"read file error.\"); return; } println!(\"{}\", result.unwrap()); } unsafe unsafe可以修饰fn, 代码块, trait, impl等 unsafe有传递性, 比如使用unsafe的fn的代码块也必须用unsafe来修饰. unsafe可以操作裸指针 fn main() { let x = 1_i32; let mut y: u32 = 1; let raw_mut = &mut y as *mut u32 as *mut i32 as *mut i64; // 这是安全的 unsafe { *raw_mut = -1; // 这是不安全的,必须在 unsafe 块中才能通过编译 } println!(\"{:X} {:X}\", x, y); } 上面的例子中: 首先raw_mut必须经过三个as as as的转换才能从u32的指针转为i64的指针 对raw_mut的直接修改是unsafe的 修改了raw_mut, 也就是y, 但也\"一起\"修改了x, 因为x和y两个变量地址是挨着的. 又比如下面的例子: fn raw_to_ref(p: *const i32) -> &'a i32 { unsafe { &*p } } fn main() { let p: &i32 = raw_to_ref(std::ptr::null::()); println!(\"{}\", p); } 这个例子会运行错误, 因为传入了一个空指针, 而在unsafe里面对空指针解引用出现错误. 不加unsafe是不能对裸指针解引用的 在unsafe里, 用户要自己避免空指针问题, 编译器是不管的 要修复这个错误, 改成这样就好了: fn raw_to_ref(p: *const i32) -> Option { if p.is_null() { None } else { unsafe { Some(&*p) } } } fn main() { let p: Option = raw_to_ref(std::ptr::null::()); println!(\"{:?}\", p); } 不用unsafe的swap例子 下面的例子是我自己写的, 能正常工作, 没用unsafe. fn swap(x: &mut i32, y: &mut i32) { let z = *x; *x = *y; *y = z; } fn main() { let mut a = 5; let mut b = 8; swap(&mut a, &mut b); println!(\"a: {}, b: {}\", a, b) } 但如果用泛型, 就会出现编译错误: fn swap(x: &mut T, y: &mut T) { let z = *x; *x = *y; *y = z; } fn main() { let mut a = 5; let mut b = 8; swap(&mut a, &mut b); println!(\"a: {}, b: {}\", a, b) } 错误是:cannot move out of *x which is behind a mutable reference 编译器还提示move occurs because *x has type T, which does not implement the Copy trait 意思是assign的时候, 默认执行的是move语义, 但这里因为x只是借用, 但没有权限解引用. 但如果实现了Copy trait, 也可以调用Copy 那么添加T的约束为Copy, 也就好了: fn swap(x: &mut T, y: &mut T) { let z = *x; //这里用了copy语义 *x = *y; *y = z; } fn main() { let mut a = 5; let mut b = 8; swap(&mut a, &mut b); println!(\"a: {}, b: {}\", a, b) } 标准库的swap 标准的swap并没有要求copy, 而是直接操作指针 fn swap(x: &mut T, y: &mut T) { unsafe { let mut t: T = mem::uninitialized(); ptr::copy_nonoverlapping(&*x, &mut t, 1); ptr::copy_nonoverlapping(&*y, x, 1); ptr::copy_nonoverlapping(&t, y, 1); mem::forget(t); } } 首先，我们依然需要一个作为中转的局部变量。这个局部变量该怎么初始化呢？其实我们不希望它执行初始化，因为我们只需要这部分内存空间而已，它里面的内容马上就会被覆盖掉，做初始化是浪费性能。况且，我们也不知道用什么通用的办法初始化一个泛型类型，它连Default约束都未必满足。所以我们要用mem::uninitialized函数。接下来，我们可以直接通过内存复制来交换两个变量。因为在Rust中，所有的类型、所有的move操作，都是简单的内存复制，不涉及其他的语义。Rust语言已经假定任何一个类型的实例，随时都可以被move到另外的地方，不会产生任何问题。所以，我们可以直接使用ptr::copy系列函数来完成。再加上在safe代码中，&mut型指针具有排他性， 我们可以确信，x和y一定指向不同的变量。所以可以使用ptr::copy_nonoverlapping函数，比ptr::copy要快一点。 最后，一定要记得，要阻止临时的局部变量t执行析构函数。因为t本身并未被合理地初始化，它内部的值是直接通过内存复制获得的。在复制完成后，它内部的指针（如果有的话）会和y指向的变量是相同的。如果我们不阻止它，那么在函数结束的时候它的析构函数就会被自动调用，这样y指向的变量就变成非法的了。 这样我们才能正确地完成这个功能。虽然源代码看起来比较长，但是实际生成的代码并不多，就是3次内存块的复制。 Vec代码 下面的代码中, 用Vec的new创建出来的变量v1, 开始的capacity是0, length也是0, 增长的倍数也是2倍速. fn main() { let mut v1 = Vec::::new(); println!(\"Start: length {} capacity {}\", v1.len(), v1.capacity()); for i in 1..10 { v1.push(i); println!( \"[Pushed {}] length {} capacity {}\", i, v1.len(), v1.capacity() ); } let mut v2 = Vec::::with_capacity(1); println!(\"Start: length {} capacity {}\", v2.len(), v2.capacity()); v2.reserve(10); for i in 1..10 { v2.push(i); println!( \"[Pushed {}] length {} capacity {}\", i, v2.len(), v2.capacity() ); } } //结果 Start: length 0 capacity 0 [Pushed 1] length 1 capacity 4 [Pushed 2] length 2 capacity 4 [Pushed 3] length 3 capacity 4 [Pushed 4] length 4 capacity 4 [Pushed 5] length 5 capacity 8 [Pushed 6] length 6 capacity 8 [Pushed 7] length 7 capacity 8 [Pushed 8] length 8 capacity 8 [Pushed 9] length 9 capacity 16 Start: length 0 capacity 1 [Pushed 1] length 1 capacity 10 [Pushed 2] length 2 capacity 10 [Pushed 3] length 3 capacity 10 [Pushed 4] length 4 capacity 10 [Pushed 5] length 5 capacity 10 [Pushed 6] length 6 capacity 10 [Pushed 7] length 7 capacity 10 [Pushed 8] length 8 capacity 10 [Pushed 9] length 9 capacity 10 用with_capacity()创建的容量一开始就分配了. Vec的特点是空间会自动扩展, 并且当变量生命周 期结束的时候，它会自动释放它管理的内存空间 为什么Vec能够自动回收空间呢? 因为Vec实现了Drop: unsafe impl Drop for Vec { fn drop(&mut self) { unsafe { // use drop for [T] ptr::drop_in_place(&mut self[..]); } // RawVec handles deallocation } } "},"notes/rust_入门3.html":{"url":"notes/rust_入门3.html","title":"闭包 容器 迭代器 生成器 线程","keywords":"","body":"静态分派和动态分派 trait不能用作入参或者返回值 比如下面的Bird这个trait, 有两个实现, Duck和Swan trait Bird { fn fly(&self); } struct Duck; struct Swan; impl Bird for Duck { fn fly(&self) { println!(\"duck duck\"); } } impl Bird for Swan { fn fly(&self) { println!(\"swan swan\"); } } 但Bird不能直接用作入参和出参, 因为trait是一种DST类型，它的大小在编译阶段是不固定的. 这点和go的interface是不同的. // 以下代码不能编译 fn test(arg: Bird) {} fn test() -> Bird {} 有两个办法: 用泛型传参, 即静态分派fn test(arg: T) { arg.fly(); } 用trait object, 即自己给trait穿个Box的马甲, 做到动态分派 // 根据不同需求,可以用不同的指针类型,如 Box/&/&mut 等 fn test(arg: Box) { arg.fly(); } 似乎还有个办法是加dyn关键词, dyn是比较新的关键词 trait Bird { fn fly(&self); } struct Duck; struct Swan; impl Bird for Duck { fn fly(&self) { println!(\"duck duck\"); } } impl Bird for Swan { fn fly(&self) { println!(\"swan swan\"); } } fn call_fly(f: &dyn Bird) { f.fly() } fn main() { let duck = Duck; call_fly(&duck); call_fly(&Swan{}); } //输出 duck duck swan swan impl Trait做为入参 比如下面的函数 fn parse_csv_document(src: R) -> std::io::Result>> { src.lines() .map(|line| { // For each line in the source line.map(|line| { // If the line was read successfully, process it, if not, return the error line.split(',') // Split the line separated by commas .map(|entry| String::from(entry.trim())) // Remove leading and trailing whitespace .collect() // Collect all strings in a row into a Vec }) }) .collect() // Collect all lines into a Vec> } 可以由泛型约束改成impl trait, 即声明src必须实现std::io::BufRead这个trait. 这点和golang传入interface有点像. fn parse_csv_document(src: impl std::io::BufRead) -> std::io::Result>> { src.lines() .map(|line| { // For each line in the source line.map(|line| { // If the line was read successfully, process it, if not, return the error line.split(',') // Split the line separated by commas .map(|entry| String::from(entry.trim())) // Remove leading and trailing whitespace .collect() // Collect all strings in a row into a Vec }) }) .collect() // Collect all lines into a Vec> } impl trait只是语法糖 比如下面的代码用了impl trait形式的入参: pub fn notify(item: &impl Summary) { println!(\"Breaking news! {}\", item.summarize()); } 它实际上是下面显式声明泛型约束的方法一样: pub fn notify(item: &T) { println!(\"Breaking news! {}\", item.summarize()); } trait object 指向trait的指针就是trait object。假如Bird是一个trait的名称，那么dyn Bird就是一个DST动态大小类型。&dyn Bird、&mut dyn Bird、Box、*const dyn Bird、*mut dyn Bird以及Rc等等都是Trait Object。 A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a & reference or a Box smart pointer, then the dyn keyword, and then specifying the relevant trait. impl trait 还有个impl trait语法, 比如: fn foo(n: u32) -> impl Iterator { (0..n).map(|x| x * 100) } 返回一个函数也可以用类似的语法: fn multiply(m: i32) -> impl Fn(i32) -> i32 { move |x| x * m } fn main() { let f = multiply(5); println!(\"{}\", f(2)); } //结果 10 闭包 闭包(closure)是一种匿名函数，具有“捕获”外部变量的能力。闭包有时候也被称作lambda表达式。它有两个特点: 可以像函数一 样被调用； 可以捕获当前环境中的变量。 语法如下: fn main() { let add = |a: i32, b: i32| -> i32 { return a + b; }; let x = add(1, 2); println!(\"result is {}\", x); } 以上闭包有两个参数，以两个|包围。执行语句包含在{}中。闭包的参数和返回值类型的指定与普通函数的语法相同。闭包的参 数和返回值类型都是可以省略的，因此以上闭包可省略为: let add = |a, b| a + b; //省略了类型, 括号, 和return 普通的函数不能捕获局部变量 rust支持函数中定义函数, 但不支持内部函数引用外部函数的局部变量. 比如下面的代码编译不过 fn main() { let x = 1_i32; fn inner_add() -> i32 { x + 1 } let x2 = inner_add(); println!(\"result is {}\", x2); } 要改为闭包: fn main() { let x = 1_i32; let inner_add = || x + 1; let x2 = inner_add(); println!(\"result is {}\", x2); } 闭包和函数 闭包的实现: fn main() { let x = 1_i32; let add_x = | a | x + a; let result = add_x( 5 ); println!(\"result is {}\", result); } 如果改为非闭包的普通实现: struct Closure { inner1: i32, } impl Closure { fn call(&self, a: i32) -> i32 { self.inner1 + a } } fn main() { let x = 1_i32; let add_x = Closure { inner1: x }; let result = add_x.call(5); println!(\"result is {}\", result); } 可以看到闭包的方式更简洁. 闭包如何捕获变量? Rust主要是通过分析外部变量在闭包中的使用方式，通过一系列的规则自动推导出来的。主要规则如下: 如果一个外部变量在闭包中，只通过借用指针&使用，那么这个变量就可通过引用&的方式捕获； 如果一个外部变量在闭包中，通过&mut指针使用过，那么这个变量就需要使用&mut的方式捕获； 如果一个外部变量在闭包中，通过所有权转移的方式使用过，那么这个变量就需要使用“by value”的方式捕获。 简单点总结规则是，在保证能编译通过的情况下，编译器会自动选择一种对外部影响最小的类型存储。对于被捕获的类型为T的外部变量，在匿名结构体中的存储方式选择为: 尽可能先选择&T类型，其次选择&mut T类型，最后选择T类型。 move关键字 闭包的捕获默认是引用捕获, 即捕获&T. 下面的例子编译不通过 fn make_adder(x: i32) -> Box i32> { Box::new(|y| x + y) } fn main() { let f = make_adder(3); println!(\"{}\", f(1)); // 4 println!(\"{}\", f(10)); // 13 } 函数make_adder中有一个局部变量x，按照前面所述的规则，它被闭包所捕获，而且可以使用引用&的方式完成闭包内部的逻辑，因此它是被引用捕获的。而闭包则作为函数返回值被传递出去了。于是，闭包被调用的时候，它内部的引用所指向的内容已经被释放了。 这个时候就要用move关键字了, 表示后面语句块的所有变量都强制使用\"值传递\": fn make_adder(x: i32) -> Box i32> { Box::new(move |y| x + y) // 使用move来强制使用值传递 } 闭包和泛型 下面的例子是传入一个闭包函数到泛型函数: fn call_with_closure(some_closure: F) -> i32 where F: Fn(i32) -> i32, { some_closure(1) } fn main() { let answer = call_with_closure(|x| x + 2); println!(\"{}\", answer); } 每个闭包，编译器都会为它生成一个匿名结构体类型；即使两个闭包的参数和返回值一致，它们也是完全不同的两个类 型，只是都实现了同一个trait而已。 可以用Box封装闭包 fn test() -> Box i32> { let c = |i: i32| i * 2; Box::new(c) } fn main() { let closure = test(); let r = closure(2); println!(\"{}\", r); } 容器 容器 描述 Vec 可变长数组, 连续存储 VecDeque 双向队列, 适用于从头部和尾部插入删除数据 LinkedList 双向链表, 非连续存储 HashMap 基于Hash算法存储key value HashSet 只有key没有value的HashMap BTreeMap 基于B树存储key value BTreeSet 只有key没有value的BtreeMap BinaryHeap 基于二叉堆的优先级队列 Vec 它就是一个可以自动扩展容量的动态数组。它重载了Index运算符，可以通过中括号取下标的形式访问内部成员。它还重载了Deref/DerefMut运算符，因此可 以自动被解引用为数组切片。 用法示例: fn main() { // 常见的几种构造Vec的方式 // 1. new() 方法与 default() 方法一样,构造一个空的Vec let v1 = Vec::::new(); // 2. with_capacity() 方法可以预先分配一个较大空间,避免插入数据的时候动态扩容 let v2: Vec = Vec::with_capacity(1000); // 3. 利用宏来初始化,语法跟数组初始化类似 let v3 = vec![1, 2, 3]; // 插入数据 let mut v4 = Vec::new(); // 多种插入数据的方式 v4.push(1); v4.extend_from_slice(&[10, 20, 30, 40, 50]); v4.insert(2, 100); println!(\"capacity: {} length: {}\", v4.capacity(), v4.len()); // 访问数据 // 调用 IndexMut 运算符,可以写入数据 v4[5] = 5; let i = v4[5]; println!(\"{}\", i); // Index 运算符直接访问,如果越界则会造成 panic,而 get 方法不会,因为它返回一个 Option if let Some(i) = v4.get(6) { println!(\"{}\", i); } // Index 运算符支持使用各种 Range 作为索引 let slice = &v4[4..]; println!(\"{:?}\", slice); } VecDeque A double-ended queue implemented with a growable ring buffer VecDeque是一个双向队列。在它的头部或者尾部执行添加或者删除操作，都是效率很高的。它的用法和Vec非常相似，主要是多了pop_front()和push_front()等方法 use std::collections::VecDeque; fn main() { let mut queue = VecDeque::with_capacity(64); // 向尾部按顺序插入一堆数据 for i in 1..10 { queue.push_back(i); } // 从头部按顺序一个个取出来 while let Some(i) = queue.pop_front() { println!(\"{}\", i); } } HashMap HashMap泛型参数K是键的类型，V是值的类型，S是哈希算法的类型。S这个泛型参数有一个默认值. Hash trait就是这个算法: trait Hash { fn hash(&self, state: &mut H); ... } trait Hasher { fn finish(&self) -> u64; fn write(&mut self, bytes: &[u8]); ... } 如果一个类型，实现了Hash，给定了一种哈希算法Hasher，就能计算出一个u64类型的哈希值, 比如类似下面的: struct Person { first_name: String, last_name: String, } impl Hash for Person { fn hash(&self, state: &mut H) { self.first_name.hash(state); self.last_name.hash(state); } } 但通常写作: #[derive(Hash)] struct Person { first_name: String, last_name: String, } 完整的写法如下: use std::collections::HashMap; #[derive(Hash, Eq, PartialEq, Debug)] struct Person { first_name: String, last_name: String, } impl Person { fn new(first: &str, last: &str) -> Self { Person { first_name: first.to_string(), last_name: last.to_string(), } } } fn main() { let mut book = HashMap::new(); book.insert(Person::new(\"John\", \"Smith\"), \"521-8976\"); book.insert(Person::new(\"Sandra\", \"Dee\"), \"521-9655\"); book.insert(Person::new(\"Ted\", \"Baker\"), \"418-4165\"); let p = Person::new(\"John\", \"Smith\"); // 查找键对应的值 if let Some(phone) = book.get(&p) { println!(\"Phone number found: {}\", phone); } // 删除 book.remove(&p); // 查询是否存在 println!(\"Find key: {}\", book.contains_key(&p)); } HashMap对查询和insert/delete这种组合, 提供了entry API, 可以节省一次hash运算. 比如下面的代码: if map.contains_key(key) { // 执行了一遍hash查找的工作 map.insert(key, value); // 又执行了一遍hash查找的工作 } 使用entry API可以写成: map.entry(key).or_insert(value); BTreeMap 和HashMap用起来类似, 但使用B树来存储key value. 和hash不同, 这个解构是有序的. BTreeMap对key的要求是满足Ord约束，即具备“全序”特征. BTreeMap使用起来和Hashap类似, 但多了一个range功能如下: use std::collections::BTreeMap; fn main() { let mut map = BTreeMap::new(); map.insert(3, \"a\"); map.insert(5, \"b\"); map.insert(8, \"c\"); for (k, v) in map.range(2..6) { println!(\"{} : {}\", k, v); } } 迭代器 迭代器的trait: trait Iterator { type Item; fn next(&mut self) -> Option; } 它最主要的一个方法就是next()，返回一个Option。一般情况返回Some(Item)；如果迭代完成，就返回None。 一个迭代器需要自己记录内部状态, 比如下面Seq结构体里的current: use std::iter::Iterator; struct Seq { current: i32, } impl Seq { fn new() -> Self { Seq { current: 0 } } } impl Iterator for Seq { type Item = i32; //指定关联类型 fn next(&mut self) -> Option { if self.current 从容器创造迭代器 从容器创造迭代器: iter()创造一个Item是&T类型的迭代器； iter_mut()创造一个Item是&mut T类型的迭代器； into_iter()创造一个Item是T类型的迭代器。--这里有问题, 不一定是T 比如Vec等容器创造迭代器: fn main() { let v = vec![1, 2, 3, 4, 5]; let mut iter = v.iter(); while let Some(i) = iter.next() { println!(\"{}\", i); } } 这个和用for in是一样的: fn main() { let v = vec![1, 2, 3, 4, 5]; for i in v { println!(\"{}\", i) } } 迭代器组合 比如下面的例子: fn main() { let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]; let mut iter = v .iter() .take(5) .filter(|&x| x % 2 == 0) .map(|&x| x * x) .enumerate(); while let Some((i, v)) = iter.next() { println!(\"{} {}\", i, v); } } 直到执行iter.next()前, 创造iter使用的\"组合\"模式的代价很小, 它只是按照用户定义的组合, 初始化了一个迭代器对象, 并没有真正干活. 比如下面的代码只是构造了一个迭代器示例, 不会打印, 因为没有调用next()方法. let v = vec![1, 2, 3, 4, 5]; v.iter().map(|x| println!(\"{}\", x)); for in for in就是给迭代器设计的语法糖 use std::collections::HashMap; fn main() { let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]; for i in v { println!(\"{}\", i); } //从array生成一个hashmap let map: HashMap = [(1, 'a'), (2, 'b'), (3, 'c')].iter().cloned().collect(); //比较新的版本>1.56, 可以用from函数 let map = HashMap::from([(1, 'a'), (2, 'b'), (3, 'c')]); for (k, v) in &map { println!(\"{} : {}\", k, v); } } 因为for调用的是 trait IntoIterator { type Item; type IntoIter: Iterator; //感觉这行是约束的意思 fn into_iter(self) -> Self::IntoIter; } 只要某个类型实现了IntoIterator，那么调用into_iter()方法就可以得到对应的迭代器。这个into_iter()方法的receiver是self，而不是&self，执行的是move语义。这么做，可以同时支持Item类型为T、&T 或者&mut T，用户有选择的权力。 那么如何实现这个trait呢? 需要三个版本一起实现: impl IntoIterator for BTreeMap { type Item = (K, V); type IntoIter = IntoIter; } impl IntoIterator for &'a BTreeMap { type Item = (&'a K, &'a V); type IntoIter = Iter; } impl IntoIterator for &'a mut BTreeMap { type Item = (&'a K, &'a mut V); type IntoIter = IterMut; } 对于一个容器类型，标准库里面对它impl了三次IntoIterator。当Self类型为BTreeMap的时候，Item类型为(K，V)，这意味着，每次next()方法都是把内部的元素move出来了；当Self类型为&BTreeMap的时候，Item类型为(&K，&V)，每次next()方法返回的是借用； 当Self类型为&mut BTreeMap的时候，Item类型为(&K，&mut V)，每次next()方法返回的key是只读的，value是可读写的。 所以，如果有个变量m，其类型为BTreeMap，那么用户可以选择使用m.into_iter()或者(&m).into_iter()或者(&mut m).into_iter()，分别达到不同的目的。 for in循环用了into_iter()方法, 对应上面三种实现, 使用方法如下: // container在循环之后生命周期就结束了,循环过程中的每个item是从container中move出来的 for item in container {} // 迭代器中只包含container的&型引用,循环过程中的每个item都是container中元素的借用 for item in &container {} // 迭代器中包含container的&mut型引用,循环过程中的每个item都是指向container中元素的可变借用 for item in &mut container {} 可以看到, 实现了IntoIterator, 就可以被for in所使用. 生成器 生成器的语法像闭包, 区别是在语句块中有yield关键词, 比如: // 方案一 #![feature(generators, generator_trait)] use std::ops::{Generator, GeneratorState}; fn main() { let mut g = || { let mut curr: u64 = 1; let mut next: u64 = 1; loop { let new_next = curr.checked_add(next); if let Some(new_next) = new_next { curr = next; next = new_next; yield curr; // println!(\"{}\", v), GeneratorState::Complete(_) => return, } } } } 注意以上代码编译不过, 但可以看看其中原理: 生成器最大的特点就是，程序的执行流程可以在生成器和调用者之间来回切换。当我们需要暂时从生成器中返回的时候，就使用yield关键字；当调用者希望再次进入生成器的时候，就调用resume()方法，这时程序执行的流程是从上次yield返回的那个点继续执行。 回想迭代器, next方法就很像resume. 迭代器需要自己维护内部状态, 生成器也是类似的, 感觉生成器能自动维护其内部状态. 协程 用户态调度的协程.Rust的协程设计，核心是async和await两个关键字，以及Future这个 trait: pub trait Future { type Output; fn poll(self: PinMut, cx: &mut Context) -> Poll; ...... } 比如下面的代码: async fn async_fn(x: u8) -> u8 { let msg = await!(read_from_network()); let result = await!(calculate(msg, x)); result } 在这个示例中，假设read_from_network()以及calculate()函数都是异步的。最外层的async_fn()函数当然也是异步的。当代码执行到 await！(read_from_network())里面的时候，发现异步操作还没有完成，它会直接退出当前这个函数，把CPU让给其他任务执行。当这个数据从网络上传输完成了，调度器会再次调用这个函数，它会从上次中断的地方恢复执行。所以用async/await的语法写代码，异步代码的逻辑在源码组织上跟同步代码的逻辑差别并不大。这里面状态保存和恢复这些琐碎的事情，都由编译器帮我们完成了。 async关键字可以修饰函数、闭包以及代码块。对于函数: async fn f1(arg: u8) -> u8 {} 实际上等同于: fn f1(arg: u8) -> impl Future {} rust和go不同的, rust需要显式的手动指定调度点, 比如上面的await宏就埋了调度的代码; 而go的调度代码是\"隐藏\"的, 表面上让人感觉不到发生了用户态调度. 标准库 类型转换 常用的类型转换已经被preclude 包括AsRef、AsMut、Into、From、ToOwned等 AsRef/AsMut AsRef这个trait代表的意思是，这个类型可以通过调用as_ref方法，得到另外一个类型的共享引用: pub trait AsRef { fn as_ref(&self) -> &T; } 这里的?Sized约束指T可以是Sized也可以不是Sized, 如果没有, 则默认T是Sized. 类似的, 还有AsMut有一个as_mut方法，可以得到另外一个类型的可读写 引用: pub trait AsMut { fn as_mut(&mut self) -> &mut T; } 比如标准库的String类型, 就针对好几个类型参数实现了 AsRef trait: impl AsRef for String impl AsRef for String impl AsRef for String impl AsRef for String AsRef这样的trait很适合用在泛型代码中，为一系列类型做统一抽 象。比如，我们可以写一个泛型函数，它接受各种类型，只要可以被转 换为&[u8]即可: fn iter_bytes>(arg: T) { for i in arg.as_ref() { println!(\"{}\", i); } } fn main() { let s: String = String::from(\"this is a string\"); let v: Vec = vec![1, 2, 3]; let c: &str = \"hello\"; // 相当于函数重载。只不过基于泛型实现的重载,一定需要重载的参数类型满足某种共同的约束 iter_bytes(s); iter_bytes(v); iter_bytes(c); } borrow pub trait Borrow { fn borrow(&self) -> &Borrowed; } From/Into AsRef/Borrow做的类型转换都是从一种引用&T到另一种引用&U的转换。而From/Into做的则是从任意类型T到U的类型转换: pub trait From { fn from(T) -> Self; } pub trait Into { fn into(self) -> T; } Into和From是逆操作, 如果存在U: From，则实现T: Into impl Into for T where U: From { fn into(self) -> U { U::from(self) } } 比如标准库的String就实现了From impl From for String 可以使用&str.into()或者String::from(s)调用 fn main() { let s: &'static str = \"hello\"; let str1: String = s.into(); let str2: String = String::from(s); } ToOwned ToOwned trait提供的是一种更“泛化”的Clone的功能。Clone一般是从&T类型变量创造一个新的T类型变量，而ToOwned一般是从一个&T类型变量创造一个新的U类型变量。 impl ToOwned for T where T: Clone, { type Owned = T; fn to_owned(&self) -> T { self.clone() } fn clone_into(&self, target: &mut T) { target.clone_from(self); } } ToString/FromStr ToString trait提供了其他类型转换为String类型的能力 pub trait ToString { fn to_string(&self) -> String; } 一般情况下，我们不需要自己为自定义类型实现ToString trait。因为标准库中已经提供了一个默认实现: impl ToString for T { #[inline] default fn to_string(&self) -> String { use core::fmt::Write; let mut buf = String::new(); buf.write_fmt(format_args!(\"{}\", self)) .expect(\"a Display implementation return an error unexpectedly\"); buf.shrink_to_fit(); buf } } 这意味着，任何一个实现了Display trait的类型，都自动实现了ToString trait。而Display trait是可以自动derive的，我们只需要为类型添加一个attribute即可。 FromStr则提供了从字符串切片&str向其他类型转换的能力: pub trait FromStr { type Err; fn from_str(s: &str) -> Result; } str类型有个方法是parse pub fn parse(&self) -> Result { … } 可以这样用: fn print_type_of(_: &T) { println!(\"{}\", std::any::type_name::()) } fn main() { print_type_of(&\"4\".parse::()); let four1 = \"4\".parse::(); //和结构体一样, 函数的泛型参数也可以用双冒号指定 let four2: Result = \"4\".parse(); println!(\"{:?}\", four1); println!(\"{:?}\", four2); } 运算符重载 Rust允许一部分运算符重载，用户可以让这些运算符支持自定义类型。运算符重载的方式是: 针对自定义类型，impl一些在标准库中预定 义好的trait，这些trait都存在于std::ops模块中。比如前面已经讲过了的Deref trait就属于运算符重载 比如加法运算符重载需要满足下面的trait: trait Add { type Output; fn add(self, rhs: RHS) -> Self::Output; } 基本库为i32实现的加法trait: impl Add for i32 type Output = i32; impl Add for &'a i32 type Output = >::Output; impl Add for i32 type Output = >::Output; impl Add for &'b i32 type Output = >::Output; 这意味着，不仅i32+i32是允许的，而且i32+&i32、&i32+i32、&i32+&i32这几种形式也都是允许的。它们的返回类型都是i32 complex加法重载 use std::ops::Add; #[derive(Copy, Clone, Debug, PartialEq)] struct Complex { real: i32, imaginary: i32, } impl Add for Complex { type Output = Complex; fn add(self, other: Complex) -> Complex { Complex { real: self.real + other.real, imaginary: self.imaginary + other.imaginary, } } } fn main() { let c1 = Complex { real: 1, imaginary: 2, }; let c2 = Complex { real: 2, imaginary: 4, }; println!(\"{:?}\", c1 + c2); } 可以实现多个类型的add: use std::ops::Add; #[derive(Copy, Clone, Debug, PartialEq)] struct Complex { real: i32, imaginary: i32, } impl Add for Complex { type Output = Complex; fn add(self, other: &'a Complex) -> Complex { Complex { real: self.real + other.real, imaginary: self.imaginary + other.imaginary, } } } impl Add for Complex { type Output = Complex; fn add(self, other: i32) -> Complex { Complex { real: self.real + other, imaginary: self.imaginary, } } } IO OsString和OsStr Rust的String和Str是utf-8编码的, 但操作系统的字符串不一定用什么格式. 所以rust设计了OsString和OsStr来屏蔽差异. 使用场景如下: use std::path::PathBuf; fn main() { let mut buf = PathBuf::from(\"/\"); buf.set_file_name(\"bar\"); if let Some(s) = buf.to_str() { println!(\"{}\", s); } else { println!(\"invalid path\"); } } 这里的set_file_name方法声明如下: fn set_file_name>(&mut self, file_name: S) 因为&str满足这个约束: impl AsRef for str 文件和路径 rust对文件的实现在std::fs::File. 对文件的读写，则需要用到std::io模块了. 这个模块内部定义了几个重要的trait，比如Read/Write。File类型也实现了Read和Write两个 trait，因此它拥有一系列方便读写文件的方法. use std::fs::File; use std::io::prelude::*; use std::io::BufReader; fn test_read_file() -> Result { let mut path = std::env::home_dir().unwrap(); path.push(\".rustup\"); path.push(\"settings\"); path.set_extension(\"toml\"); let file = File::open(&path)?; let reader = BufReader::new(file); for line in reader.lines() { println!(\"Read a line: {}\", line?); } Ok(()) } fn main() { match test_read_file() { Ok(_) => {} Err(e) => { println!(\"Error occured: {}\", e); } } } 标准输入输出 use std::io::prelude::*; use std::io::BufReader; fn test_stdin() -> Result { let stdin = std::io::stdin(); let handle = stdin.lock(); let reader = BufReader::new(handle); for line in reader.lines() { let line = line?; if line.is_empty() { return Ok(()); } println!(\"Read a line: {}\", line); } Ok(()) } fn main() { match test_stdin() { Ok(_) => {} Err(e) => { println!(\"Error occured: {}\", e); } } } 进程启动参数 在Rust中，进程启动参数是调用独立的函数std::env::args()来得到的，或者使用std::env::args_os()来得到，进程返回值也是调用独立函数std::process::exit()来指定的。 比如: fn main() { if std::env::args().any(|arg| arg == \"-kill\") { std::process::exit(1); } for arg in std::env::args() { println!(\"{}\", arg); } } Any和反射 Rust标准库中提供了一个乞丐版的“反射”功能，那就是std::any模块。这个模块内，有个trait名字叫作Any。所有的类型都自动实现了Any这个trait，因此我们可以把任何一个对象的引用转为&Any这个trait object，然后调用它的方法。 它可以判断这个对象是什么类型，以及强制转换&Any为某个具体类型。另外，成员函数get_type_id()暂时要求'static约束，这个限制条件以后会放宽。 #![feature(get_type_id)] use std::any::Any; use std::fmt::Display; fn log(value: &T) { let value_any = value as &Any; if let Some(s) = value_any.downcast_ref::() { println!(\"String: {}\", s); } else if let Some(i) = value_any.downcast_ref::() { println!(\"i32: {}\", i); } else { let type_id = value_any.get_type_id(); println!(\"unknown type {:?}: {}\", type_id, value); } } fn do_work(value: &T) { log(value); } fn main() { let my_string = \"Hello World\".to_string(); do_work(&my_string); let my_i32: i32 = 100; do_work(&my_i32); let my_char: char = '❤'; do_work(&my_char); } 线程安全 创建线程 use std::thread; thread::spawn(move || { // 这里是新建线程的执行逻辑 }); 如果我们需要等待子线程执行结束，那么可以使用join方法: use std::thread; // child 的类型是 JoinHandle,这个T是闭包的返回类型 let child = thread::spawn(move || { // 子线程的逻辑 }); // 父线程等待子线程结束 let res = child.join(); 更多线程参数 use std::thread; thread::Builder::new().name(\"child1\".to_string()).spawn(move || { println!(\"Hello, world!\"); }); thread的常用API: thread::sleep(dur: Duration) 使得当前线程等待一段时间继续执行。在等待的时间内，线程调度器会调度其他的线程来执行。 thread::yield_now() 放弃当前线程的执行，要求线程调度器执行线程切换。 thread::current() 获得当前的线程。 thread::park() 暂停当前线程，进入等待状态。当thread::Thread::unpark(&self)方法被调用的时候，这个线程可以被恢复执行。 thread::Thread::unpark(&self) 综合例子如下: use std::thread; use std::time::Duration; fn main() { let t = thread::Builder::new() .name(\"child1\".to_string()) .spawn(move || { println!(\"enter child thread.\"); thread::park(); println!(\"resume child thread\"); }) .unwrap(); println!(\"spawn a thread\"); thread::sleep(Duration::new(5, 0)); t.thread().unpark(); t.join(); println!(\"child thread finished\"); } rust怎么保证线程安全 下面的代码编译不过: use std::thread; fn main() { let mut health = 12; thread::spawn(|| { health *= 2; }); println!(\"{}\", health); } spawn函数接受的参数是一个闭包。我们在闭包里面引用了函数体内的局部变量，而这个闭包是运行在另外一个线程上，编译器无法肯定局部变量health的生命周期一定大于闭包的生命周期，于是发生了错误. 如果在闭包前面加move, 虽然能够编译过, 但运行结果是health还是12, 因为move的语义是copy, 导致在闭包里面的health已经不是外面的health了. rust编译器可以识别下面的代码, 带不带move都编译不过. use std::thread; fn main() { let mut v: Vec = vec![]; thread::spawn(|| { v.push(1); }); println!(\"{:?}\", v); } 那么rust能不能让一个变量在不同的线程中共享呢? 答: 不能. 我们没有办法在多线程中直接读写普通的共享变量，除非使用Rust提供的线程安全相关的设施 。 The compiler prevents all data races. “共享不可变，可变不共享” Send & Sync std::marker::Sync: 如果类型T实现了Sync类型，那说明在不同的线程中使用&T访问同一个变量是安全的。 std::marker::Send: 如果类型T实现了Send类型，那说明这个类型的变量在不同的线程中传递所有权是安全的。 在spawn签名中: pub fn spawn(f: F) -> JoinHandle where F: FnOnce() -> T, F: Send + 'static, T: Send + 'static 我们需要注意的是，参数类型F有重要的约束条件F: Send+'static， T: Send+'static。它要求参数满足传递所有权的约束, 但凡在线程之间传递所有权会发生安全问题的类型，都无法在这个参数中出现，否则就是编译错误。另外，Rust对全局变量也有很多限制，你不可能简单地通过全局变量在多线程中随意共享状态。这样，编译器就会禁止掉可能有危险的线程间共享数据的行为。 什么是Send类型 Types that can be transferred across thread boundaries. This trait is automatically implemented when the compiler determines it's appropriate. Send trait由编译器自动判断并实现. 如果一个类型可以安全地从一个线程move进入另一个线程，那它就是Send类型。比如: 普通的数字类型是Send，因为我们把数字move进入另一个线程之后，两个线程同时执行也不会造成什么安全问题. 更进一步，内部不包含引用的类型，都是Send。因为这样的类型跟外界没有什么关联，当它被move进入另一个线程之后，它所有的部分都跟原来的线程没什么关系了，不会出现并发访问的情况。比如String类型。 稍微复杂一点的，具有泛型参数的类型，是否满足Send大多是取决于参数类型是否满足Send。比如Vec，只要我们能保证T: Send，那么Vec肯定也是Send，把它move进入其他线程是没什么问题的。再比如Cell、RefCell、Option、Box，也都是这种情况。 还比如加锁的类型也是Send类型, 比如Mutex就是这种。 Mutex这个类型实际上不关心它内部类型是怎样的，反正要访问内部数据，一定要调用lock()方法上锁，它的所有权在哪个线程中并不重要，所以把它move到其他线程也是没有问题的. 那什么不是send类型呢? 答案是编译器报错的就不是. 比如Rc 什么是Sync类型 Types for which it is safe to share references between threads. This trait is automatically implemented when the compiler determines it's appropriate. Sync trait由编译器自动判断并实现. 如果类型T实现了Sync trait，那说明在不 同的线程中使用&T访问同一个变量是安全的。注意这里是&T是只读的. 显然，基本数字类型肯定是Sync。假如不同线程都拥有指向同一个i32类型的只读引用&i32，这是没什么问题的。因为这个类型引用只能读，不能写。多个线程读同一个整数是安全的。 -- 这里我有疑问, 如果所有权的线程去写呢? 不就不安全了么? 大部分具有泛型参数的类型是否满足Sync，很多都是取决于参数类 型是否满足Sync。像Box、Vec Option 这种也是Sync的，只要其中的参数T是满足Sync的。 也有一些类型，不论泛型参数是否满足Sync，它都是满足Sync的。 这种类型把不满足Sync条件的类型用它包起来，就变成了满足Sync条件 的。Mutex就是这种。多个线程同时拥有&Mutex型引用，指向同一个变量是没问题的。 保证线程安全的类型 Arc Arc是Rc的线程安全版本。它的全称是“Atomic reference counter”。 use std::sync::Arc; use std::thread; fn main() { let numbers: Vec = (0..100u32).collect(); // 引用计数指针,指向一个 Vec let shared_numbers = Arc::new(numbers); // 循环创建 10 个线程 for _ in 0..10 { // 复制引用计数指针,所有的 Arc 都指向同一个 Vec let child_numbers = shared_numbers.clone(); // move修饰闭包,上面这个 Arc 指针被 move 进入了新线程中 thread::spawn(move || { // 我们可以在新线程中使用 Arc,读取共享的那个 Vec let local_numbers = &child_numbers[..]; // 继续使用 Vec 中的数据 }); } } Mutex 下面我们用一个示例来演示一下Arc和Mutex配合。使用多线程修改共享变量: use std::sync::Arc; use std::sync::Mutex; use std::thread; const COUNT: u32 = 1000000; fn main() { let global = Arc::new(Mutex::new(0)); let clone1 = global.clone(); let thread1 = thread::spawn(move || { for _ in 0..COUNT { let mut value = clone1.lock().unwrap(); *value += 1; } }); let clone2 = global.clone(); let thread2 = thread::spawn(move || { for _ in 0..COUNT { let mut value = clone2.lock().unwrap(); *value -= 1; } }); thread1.join().ok(); thread2.join().ok(); println!(\"final value: {:?}\", global); } 而MutexGuard类型则是一个“智能指针”类型，它实现了DerefMut和Deref这两个trait，所以它可以被当作指向内部数据的普通指针使用。 MutexGuard实现了一个析构函数，通过RAII手法，在析构函数中调用了unlock()方法解锁。因此，用户是不需要手动调用方法解锁的 RwLock use std::sync::Arc; use std::sync::RwLock; use std::thread; const COUNT: u32 = 1000000; fn main() { let global = Arc::new(RwLock::new(0)); let clone1 = global.clone(); let thread1 = thread::spawn(move || { for _ in 0..COUNT { let mut value = clone1.write().unwrap(); *value += 1; } }); let clone2 = global.clone(); let thread2 = thread::spawn(move || { for _ in 0..COUNT { let mut value = clone2.write().unwrap(); *value -= 1; } }); thread1.join().ok(); thread2.join().ok(); println!(\"final value: {:?}\", global); } Atomic use std::sync::atomic::{AtomicIsize, Ordering}; use std::sync::Arc; use std::thread; const COUNT: u32 = 1000000; fn main() { // Atomic 系列类型同样提供了线程安全版本的内部可变性 let global = Arc::new(AtomicIsize::new(0)); let clone1 = global.clone(); let thread1 = thread::spawn(move || { for _ in 0..COUNT { clone1.fetch_add(1, Ordering::SeqCst); } }); let clone2 = global.clone(); let thread2 = thread::spawn(move || { for _ in 0..COUNT { clone2.fetch_sub(1, Ordering::SeqCst); } }); thread1.join().ok(); thread2.join().ok(); println!(\"final value: {:?}\", global); } Barrier use std::sync::{Arc, Barrier}; use std::thread; fn main() { let barrier = Arc::new(Barrier::new(10)); let mut handlers = vec![]; for _ in 0..10 { let c = barrier.clone(); // The same messages will be printed together. // You will NOT see any interleaving. let t = thread::spawn(move || { println!(\"before wait\"); c.wait(); println!(\"after wait\"); }); handlers.push(t); } for h in handlers { h.join().ok(); } } 这个程序创建了一个多个线程之间共享的Barrier，它的初始值是10。我们创建了10个子线程，每个子线程都有一个Arc指针指向了这个Barrier，并在子线程中调用了Barrier::wait方法。这些子线程执行到 wait方法的时候，就开始进入等待状态，一直到wait方法被调用了10 次，10个子线程都进入等待状态，此时Barrier就通知这些线程可以继续了。然后它们再开始执行下面的逻辑。 Condvar 等待和通知的机制 use std::sync::{Arc, Condvar, Mutex}; use std::thread; use std::time::Duration; fn main() { let pair = Arc::new((Mutex::new(false), Condvar::new())); let pair2 = pair.clone(); thread::spawn(move || { thread::sleep(Duration::from_secs(1)); let &(ref lock, ref cvar) = &*pair2; let mut started = lock.lock().unwrap(); *started = true; cvar.notify_one(); println!(\"child thread {}\", *started); }); // wait for the thread to start up let &(ref lock, ref cvar) = &*pair; let mut started = lock.lock().unwrap(); println!(\"before wait {}\", *started); while !*started { started = cvar.wait(started).unwrap(); } println!(\"after wait {}\", *started); } 全局变量 Rust中允许存在全局变量。在基本语法章节讲过，使用static关键字修饰的变量就是全局变量。全局变量有一个特点: 如果要修改全局变量，必须使用unsafe关键字 线程局部存储 线程局部(Thread Local)的意思是，声明的这个变量看起来是一个变量，但它实际上在每一个线程中分别有自己独立的存储地址，是不同的变量，互不干扰。在不同线程中，只能看到与当前线程相关联的那个副本，因此对它的读写无须考虑线程安全问题。 可以使用#[thread_local]attribute 可以使用thread_local！宏 异步管道相当于无限扩容的go channel, 但只是多生产单消费 异步管道是最常用的一种管道类型。它的特点是: 发送端和接收端之间存在一个缓冲区，发送端发送数据的时候，是先将这个数据扔到缓冲区，再由接收端自己去取。因此，每次发送，立马就返回了，发送端不用管数据什么时候被接收端处理 use std::sync::mpsc::channel; use std::thread; fn main() { let (tx, rx) = channel(); thread::spawn(move || { for i in 0..10 { tx.send(i).unwrap(); //这里依次发送10个数字, 改成tx.send(\"hello\")发字符串也行的. } }); while let Ok(r) = rx.recv() { println!(\"received {}\", r); } } channel是个泛型函数: pub fn channel() -> (Sender, Receiver) Sender和Receiver 都是泛型类型，且一组发送者和接收者必定是同样的类型参数，因此保 证了发送和接收端都是同样的类型。因为Rust中的类型推导功能的存在，使我们可以在调用channel的时候不指定具体类型参数，而通过后续的方法调用，推导出正确的类型参数。 Sender和Receiver的泛型参数必须满足T: Send约束。这个条件是显而易见的: 被发送的消息会从一个线程转移到另外一个线程，这个约束是为了满足线程安全。如果用户指定的泛型参数没有满足条件，在编译的时候会发生错误，提醒我们修复bug。 发送者调用send方法，接收者调用recv方法，返回类型都是Result类型，用于错误处理，因为它们都有可能调用失败。当发送者已经被销毁 的时候，接收者调用recv则会返回错误；同样，当接收者已经销毁的时候，发送者调用send也会返回错误。 在管道的接收端，如果调用recv方法的时候还没有数据，它会进入等待状态阻塞当前线程，直到接收到数据才继续往下执行。 同步管道 相当于go channel 异步管道内部有一个不限长度的缓冲区，可以一直往里面填充数据，直至内存资源耗尽。异步管道的发送端调用send方法不会发生阻塞，只要把消息加入到缓冲区，它就马上返回。 同步管道的特点是: 其内部有一个固定大小的缓冲区，用来缓存消息。如果缓冲区被填满了，继续调用send方法的时候会发生阻塞，等待接收端把缓冲区内的消息拿走才能继续发送。缓冲区的长度可以在建立管道的时候设置，而且0是有效数值。如果缓冲区的长度设置为0，那就 意味着每次的发送操作都会进入等待状态，直到这个消息被接收端取走才能返回。 第三方线程库 threadpool: threadpool是一个基本的线程池实现use std::sync::mpsc::channel; use threadpool::ThreadPool; fn main() { let n_workers = 4; let n_jobs = 8; let pool = ThreadPool::new(n_workers); let (tx, rx) = channel(); for _ in 0..n_jobs { let tx = tx.clone(); pool.execute(move || { tx.send(1) .expect(\"channel will be there waiting for the pool\"); }); } assert_eq!(rx.iter().take(n_jobs).fold(0, |a, b| a + b), 8); } scoped-threadpool在前面的章节中，我们已经知道，如果要在多线程之间共享变量， 必须使用Arc这样的保证线程安全的智能指针。然而，Arc是有运行期开销的(虽然很小)。假如我们有时候需要子线程访问当前调用栈中的局部变量，而且能保证当前函数的生命周期一定大于子线程的生命周期， 子线程一定先于当前函数退出，那我们能不能直接在子线程中使用最简单的借用指针&来访问父线程栈上的局部对象呢？ parking_lotRust标准库帮我们封装了一些基本的操作系统的同步原语，比如 Mutex Condvar等。一般情况下这些够我们使用了。但是还有一些对性能有极致要求的开发者对标准库的实现并不满意，于是社区里又有人开发出来了一套替代品，在性能和易用性方面，都比标准库更好，这就是 parking_lot库。 crossbeam标准库给了一份mpsc(多生产者单消费者)管道的实现， 但是它有许多缺陷。crossbeam-channel这个库给我们提供了另外一套管 道的实现方式。不仅包括mpsc，还包括mpmc(多生产者多消费者)， 而且使用便捷，执行效率也很高。下面是一个双端管道的使用示例。它基本实现了go语言的内置管道 功能，在执行效率上甚至有过之而无不及:extern crate crossbeam; #[macro_use] extern crate crossbeam_channel as channel; use channel::{Receiver, Sender}; fn main() { let people = vec![\"Anna\", \"Bob\", \"Cody\", \"Dave\", \"Eva\"]; let (tx, rx) = channel::bounded(1); // Make room for one unmatched send. let (tx, rx) = (&tx, &rx); crossbeam::scope(|s| { for name in people { s.spawn(move || seek(name, tx, rx)); } }); if let Ok(name) = rx.try_recv() { println!(\"No one received {}’s message.\", name); } } // Either send my name into the channel or receive someone else's, whatever happens first. fn seek(name: &'a str, tx: &Sender, rx: &Receiver) { select_loop! { recv(rx, peer) => println!(\"{} received a message from {}.\", name, peer), send(tx, name) => {}, // Wait for someone to receive my message. } } rayon Rayon是Rust核心组成员Nicholas Matsakis开发的一个并行迭代器项目。它可以把一个按顺序执行的任务轻松变成并行执行。它非常轻量级，效率极高，而且使用非常简单。而且它保证了无数据竞争的线程安全。 "},"notes/rust_工程构建.html":{"url":"notes/rust_工程构建.html","title":"工程构建","keywords":"","body":"测试和文档测试 rust原生支持测试, 还支持对文档中的example代码进行测试. https://www.cs.brandeis.edu/~cs146a/rust/doc-02-21-2015/book/testing.html 详细解释crate和mod的文档 https://www.cs.brandeis.edu/~cs146a/rust/doc-02-21-2015/book/crates-and-modules.html cargo build会根据约定俗成的规则来编译bin或者lib, 大体上是通过分析目录结构, 和特殊的文件名, 比如main.rs, lib.rs, mod.rs等. $ tree . . ├── Cargo.lock ├── Cargo.toml ├── src │ ├── english │ │ ├── farewells.rs │ │ ├── greetings.rs │ │ └── mod.rs │ ├── japanese │ │ ├── farewells.rs │ │ ├── greetings.rs │ │ └── mod.rs │ └── lib.rs └── target ├── deps ├── libphrases-a7448e02a0468eaa.rlib └── native 项目和模块 Rust用了两个概念来管理项目：一个是crate，一个是mod。 crate简单理解就是一个项目。crate是Rust中的独立编译单元。每个 crate对应生成一个库或者可执行文件（如.lib .dll .so .exe等）。官方有一 个crate仓库https://crates.io/ ，可以供用户发布各种各样的库，用户也可 以直接使用这里面的开源库。 mod简单理解就是命名空间。mod可以嵌套，还可以控制内部元素的可见性。 crate和mod有一个重要区别是：crate之间不能出现循环引用；而mod是无所谓的，mod1要使用mod2的内容，同时mod2要使用mod1的内容，是完全没问题的。在Rust里面，crate才是一个完整的编译单元 （compile unit）。也就是说，rustc编译器必须把整个crate的内容全部读进去才能执行编译，rustc不是基于单个的.rs文件或者mod来执行编译的。作为对比，C/C++里面的编译单元是单独的.c/.cpp文件以及它们所有的include文件。每个.c/.cpp文件都是单独编译，生成.o文件，再把这些.o文件链接起来。 cargo Cargo是官方的项目管理工具 新建一个hello world工程cargo new hello_world --bin 新建一个hello world库cargo new hello_world --lib 编译cargo build --release cargo.toml 举例: [package] name = \"seccompiler\" version = \"1.1.0\" authors = [\"Amazon Firecracker team \"] edition = \"2018\" build = \"../../build.rs\" description = \"Program that compiles multi-threaded seccomp-bpf filters expressed as JSON into raw BPF programs, serializing them and outputting them to a file.\" homepage = \"https://firecracker-microvm.github.io/\" license = \"Apache-2.0\" [[bin]] name = \"seccompiler-bin\" path = \"src/seccompiler_bin.rs\" [dependencies] bincode = \"1.2.1\" libc = \">=0.2.39\" serde = { version = \">=1.0.27\", features = [\"derive\"] } serde_json = \">=1.0.9\" utils = { path = \"../utils\" } The Cargo.toml file for each package is called its manifest. It is written in the TOML format. Every manifest file consists of the following sections:参考: https://doc.rust-lang.org/cargo/reference/manifest.html cargo-features — Unstable, nightly-only features. [package] — Defines a package. name — The name of the package. version — The version of the package. authors — The authors of the package. edition — The Rust edition. rust-version — The minimal supported Rust version. description — A description of the package. documentation — URL of the package documentation. readme — Path to the package's README file. homepage — URL of the package homepage. repository — URL of the package source repository. license — The package license. license-file — Path to the text of the license. keywords — Keywords for the package. categories — Categories of the package. workspace — Path to the workspace for the package. build — Path to the package build script. links — Name of the native library the package links with. exclude — Files to exclude when publishing. include — Files to include when publishing. publish — Can be used to prevent publishing the package. metadata — Extra settings for external tools. default-run — The default binary to run by cargo run. autobins — Disables binary auto discovery. autoexamples — Disables example auto discovery. autotests — Disables test auto discovery. autobenches — Disables bench auto discovery. resolver — Sets the dependency resolver to use. Target tables: (see configuration for settings) [lib] — Library target settings. [[bin]] — Binary target settings. [[example]] — Example target settings. [[test]] — Test target settings. [[bench]] — Benchmark target settings. Dependency tables: [dependencies] — Package library dependencies. [dev-dependencies] — Dependencies for examples, tests, and benchmarks. [build-dependencies] — Dependencies for build scripts. [target] — Platform-specific dependencies. [badges] — Badges to display on a registry. [features] — Conditional compilation features. [patch] — Override dependencies. [replace] — Override dependencies (deprecated). [profile] — Compiler settings and optimizations. [workspace] — The workspace definition. 错误处理 比如使用Option表示some和none两种可能, 返回Result既有值又有错误 impl str { pub fn find>(&'a self, pat: P) -> Option {} } impl File { pub fn open>(path: P) -> io::Result {} } 比如 use std::mem::{size_of, size_of_val}; use std::str::FromStr; use std::string::ParseError; fn main() { let r: Result = FromStr::from_str(\"hello\"); println!(\"Size of String: {}\", size_of::()); println!(\"Size of `r`: {}\", size_of_val(&r)); } 问号运算符 问号运算符意思是，如果结果是Err，则提前返回一个Result类型，否则继续执行。 标准库的Option、Result实现了问号需要的trait fn file_double>(file_path: P) -> Result { let mut file = File::open(file_path).map_err(|e| e.to_string())?; let mut contents = String::new(); file.read_to_string(&mut contents) .map_err(|err| err.to_string())?; let n = contents .trim() .parse::() .map_err(|err| err.to_string())?; Ok(2 * n) } 进一步简化: use std::fs::File; use std::io::Read; use std::path::Path; fn file_double>(file_path: P) -> Result> { let mut file = File::open(file_path)?; let mut contents = String::new(); file.read_to_string(&mut contents)?; let n = contents.trim().parse::()?; Ok(2 * n) } fn main() { match file_double(\"foobar\") { Ok(n) => println!(\"{}\", n), Err(err) => println!(\"Error: {:?}\", err), } } 跟其他很多运算符一样，问号运算符也对应着标准库中的一个trait std::ops::Try trait Try { type Ok; type Error; fn into_result(self) -> Result; fn from_error(v: Self::Error) -> Self; fn from_ok(v: Self::Ok) -> Self; } 和C的ABI兼容 Rust有一个非常好的特性，就是它支持与C语言的ABI兼容. 所以，我们可以用Rust写一个库，然后直接把它当成C写的库来使用。或者反过来，用C写的库，可以直接在Rust中被调用。而且这个过程是没有额外性能损失的。C语言的ABI是这个世界上最通用的ABI，大部分编程语言都支持与C的ABI兼容。这也意味着，Rust与其他语言之间的交互是没问题的，比如用Rust为Python/Node.js/Ruby写一个模块等。 rust编译选项有--crate-type [bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]其中，cdylib和staticlib就是与C的ABI兼容的 Rust 中有泛型，C语言里面没有，所以泛型这种东西是不可能暴露出来给C语言使用的，这就不是C语言的ABI的一部分。只有符合C语言的调用方式的函数，才能作为FFI的接口。这样的函数有以下基本要求： 使用extern \"C\"修饰，在Rust中extern fn默认等同于extern \"C\" fn； 使用#[no_mangle]修饰函数，避免名字重整； 函数参数、返回值中使用的类型，必须在Rust和C里面具备同样的内存布局。 从C调用Rust库 假设我们要在Rust中实现一个把字符串从小写变大写的函数，然后 由C语言调用这个函数: 在Rust侧: #[no_mangle] pub extern \"C\" fn rust_capitalize(s: *mut c_char) { unsafe { let mut p = s as *mut u8; while *p != 0 { let ch = char::from(*p); if ch.is_ascii() { let upper = ch.to_ascii_uppercase(); *p = upper as u8; } p = p.offset(1); } } } 我们在Rust中实现这个函数，考虑到C语言调用的时候传递的是char*类型，所以在Rust中我们对应的参数类型是*mut std::os:: raw::c_char。这样两边就对应起来了。 用下面的命令生成一个c兼容的静态库: rustc --crate-type=staticlib capitalize.rs 在C里面调用: #include #include // declare extern void rust_capitalize(char *); int main() { char str[] = \"hello world\"; rust_capitalize(str); printf(\"%s\\n\", str); return 0; } 用下面的命令链接: gcc -o main main.c -L. -l:libcapitalize.a -Wl,--gc-sections -lpthread -ldl 从Rust调用C库 比如c的函数 int add_square(int a, int b) { return a * a + b * b; } 在rust里面调用: use std::os::raw::c_int; #[link(name = \"simple_math\")] extern \"C\" { fn add_square(a: c_int, b: c_int) -> c_int; } fn main() { let r = unsafe { add_square(2, 2) }; println!(\"{}\", r); } //编译: //rustc -L . call_math.rs 文档 特殊的文档注释 是///、//！、/**…*/、/*！…*/，它们会被视为文档 mod foo { //! 这块文档是给 `foo` 模块做的说明 /// 这块文档是给函数 `f` 做的说明 fn f() { // 这块注释不是文档的一部分 } } 文档还支持markdown格式 "},"notes/rust_vmm_brief.html":{"url":"notes/rust_vmm_brief.html","title":"VMM(virtual machine monitor)","keywords":"","body":"介绍Firecracker Cloud-hypervisor以及virtio基础概念. 转录自我的PPT VMM brief Virtio devices Virtio is a protocol that defines how guest drivers talk to virtual devices. See the spec v1.2.Virtio devices can be exposed by PCI or MMIO PCI: a device with PCI vendor ID 0x1AF4 is a virtio device, device configuration structures are mapped to PCI configuration header BAR 0 Common configuration: feature bits, queue num, queue size, queue select, queue address Notifications: driver writes to notification address triggers an event to device ISR Status: not used when msi-x is enabled Device-specific configuration: different virtio types(net, block…) have different layouts PCI configuration access: provide an alternative way to access above registers other than BAR MMIO: a region of predefined register layout starting at base address, with compatible = \"virtio,mmio“ in DTS, which can be “discovered” by guest driver. All registers are little endian MMIO based virtio devices PCI based virtio devices Memory Manager in cloud-hypervisor Defines VM physical memory layout, just like a new SOC Uses BtreeMap to record memory ranges Uses KVM_SET_USER_MEMORY_REGION ioctl to map the layout to VMM virtual memory. (VM_PA to HOST_VA) When guest VM access memory, 2 stages translate happens(e.g. AARCH64): VM_VA -> VM_PA HOST_VA -> HOST_PA Mainly focus on PCI MMIO space PCI MMCONFIG space AARCH64 VM_PA layout Device Manager Manages all PCI devices Virtio PCI devices VFIO PCI devices Normally has 2 PCI segments Segment 0 is default Each PCI segment has PCI root, vendor ID intel, device ID VIRT_PCIE_HOST Uses HashMap to map bdf to PciDevice A pci config mmio BusDevice to route mm config access to corresponding PciDevice A MMIO address Allocator And many VirtioPciDevices Virtio Net example Virtio net has at least 3 virtqueues Transmitq Receiveq Controlq Driver sends and receives packet driver puts a packet into transmitq Notifies device by writing the notification address of the queue Kvm delivers the notification VMM handles the packet, typically by forwarding it to tap VMM receives the reply packet from tap VMM injects interrupt through KVM Guest irq handler receives the packet Guest driver handles the received packet and hands over it to upper network stack. The content in the virtqueue is virtio_net_hdr + packet data "},"notes/rust_vmm_简介.html":{"url":"notes/rust_vmm_简介.html","title":"rust-vmm简介","keywords":"","body":"https://github.com/rust-vmm Rust-Vmm 是一个开源工程，是一个可以自由定制的 VMM（virtual machine monitor）虚拟机管理器，用户可以按照自己的方式订制它。它是基于 Rust 语言实现的 VMM，有着 Rust 语言带来的优点和特性。 首先，Rust 语言一个内存安全的语言，相比于用 C 或者 C++ 会频繁遇到的各种内存的问题，比如内存的溢出、空指针、野指针、越界访问等等，更进一步会造成安全的问题、性能的问题，以及各种崩溃的问题。Rust 语言很好地解决了这一点，从它的语法、编译规则等杜绝了内存级别访问的漏洞以及风险，所以用 Rust 写的 Rust-Vmm 天然的就是内存安全的。 第二，Rust-Vmm 是不易被攻击的，Rust-VMM 是从零开始的，它是从最小的硬件虚拟化出发的，最小的硬件虚拟化意味着它有着最小的攻击面，被攻击的面就非常少，所以它会很安全。 第三，Rust-Vmm 能够很灵活的定制。Rust-VMM 可以灵活定制它的每一个组件，所有的对于设备的模拟或者关键特性的处理都是封装成了一个一个的 Rust-Vmm crates 包，比如有 VCPU，有 linuxloader，vm-virtIO 等等。其中 crates 是 Rust 语言中的包管理工具，可以理解 JAVA 或 golang 里面的 package，它是以发行不同的包或者库的形式对外发布它的 feature。 第四，Rust-Vmm 有非常高的性能，基于 Rust 语言的 without garbage collection 特性，它是没有 GC 回收检查机制的，不像 JAVA 或者其他更高级的语言会有一个 runtime，Rust-Vmm 的性能上会更好，同时基于 KVM 实现的虚拟化方案也是性能的保证。 简单介绍一下 Rust-Vmm 的一个历史，它是由谷歌首先实现的，谷歌首先实现一个 Rust based 的轻量级的 VMM，它叫做 crosVM，大家也可以从链接里面看到，它是一个为 chrome 浏览器做的一个微内核。然后 AWS，亚马逊基于谷歌开源出来的 crosVM，实现了自己的基于 rust 的 VMM 叫 Firecracker。两个项目的开发人员会发现做这两个项目的时候，会有很多重复的重叠的通用的代码，很自然的把可以开源的、通用的部分结合到一块，就有了 Rust-Vmm 的项目。 使用rust vmm 参考https://opensource.com/article/19/3/rust-virtual-machine要自己搭一个vmm, 可以使用rust rmm提供的各种模块, 这些模块都是独立的项目, rust里面叫crate. KVM interface: Creating our VMM on top of KVM requires an interface that can invoke KVM functionality from Rust. The kvm-bindings crate represents the Rust Foreign Function Interface (FFI) to KVM kernel headers. Because headers only include structures and defines, we also have wrappers over the KVM ioctls (kvm-ioctls) that we use for opening dev/kvm, creating a VM, creating vCPUs, and so on. Virtio devices and rate limiting: Virtio has a frontend-backend architecture. Currently in rust-vmm, the frontend is implemented in the virtio-devices crate, and the backend lies in the vhost package. Vhost has support for both user-land and kernel-land drivers, but users can also plug virtio-devices to their custom backend. The virtio-bindings are the bindings for Virtio devices generated using the Virtio Linux headers. All devices in the virtio-devices crate are exported independently as modules using conditional compilation. Some devices, such as block, net, and vsock support rate limiting in terms of I/O per second and bandwidth. This can be achieved by using the functionality provided in the rate-limiter crate. The kernel-loader is responsible for loading the contents of an ELF kernel image in guest memory. rust-vmm的github上, 各个模块是单独成库的: crosvm crosvm是google的为chrome OS上运行的VMM, 安全性好, Rust写的. Rust也是静态binary 每个虚拟设备是个进程,fork出来的, 但不exec. 这个进程用了minijail做沙盒处理, 应该类似seccomp. 基于KVM 使用Rust 支持x86, aarch64 virtual device使用socket和VM通信 设备模型的核心是bus, 一个读/写操做到bus上, bus会按这个读或写的地址, 找到对应的BusDevice, 转发读/写请求到该BusDevice. 一个地址上只能有一个BusDevice BusDevice可能出现在多个地址 每个BusDevice都自带mutex, 所以BusDevice的实现里就不需要再加锁了. "},"notes/rust_firecracker_代码.html":{"url":"notes/rust_firecracker_代码.html","title":"代码","keywords":"","body":"firecracker是最终的可执行文件: run_without_api流程 这里重点考察build/cargo_target/x86_64-unknown-linux-musl/release/firecracker --no-api --config-file myvmconfig.json方式运行的firecrackermyvmconfig.json内容如下: { \"boot-source\": { \"kernel_image_path\": \"build/kernel/linux-5.10/vmlinux-5.10-x86_64.bin\", \"boot_args\": \"console=ttyS0 reboot=k panic=1 pci=off\", \"initrd_path\": null }, \"drives\": [ { \"drive_id\": \"rootfs\", \"path_on_host\": \"build/rootfs/bionic.rootfs.ext4\", \"is_root_device\": true, \"partuuid\": null, \"is_read_only\": false, \"cache_type\": \"Unsafe\", \"io_engine\": \"Sync\", \"rate_limiter\": null } ], \"machine-config\": { \"vcpu_count\": 2, \"mem_size_mib\": 1024, \"smt\": false, \"track_dirty_pages\": false }, \"balloon\": null, \"network-interfaces\": [], \"vsock\": null, \"logger\": null, \"metrics\": null, \"mmds-config\": null } 经过前面的命令行参数解析, 最后调用 run_without_api( &seccomp_filters, //这个是seccomp的bpf代码 vmm_config_json, //这个是配置文件的字符串 instance_info, boot_timer_enabled, mmds_size_limit, metadata_json.as_deref(), ) 这个函数先从json构建vmm, 然后在循环里run: fn run_without_api( seccomp_filters: &BpfThreadMap, config_json: Option, instance_info: InstanceInfo, bool_timer_enabled: bool, mmds_size_limit: usize, metadata_json: Option, ) -> FcExitCode { let mut event_manager = EventManager::new().expect(\"Unable to create EventManager\"); // Create the firecracker metrics object responsible for periodically printing metrics. let firecracker_metrics = Arc::new(Mutex::new(metrics::PeriodicMetrics::new())); event_manager.add_subscriber(firecracker_metrics.clone()); // Build the microVm. We can ignore VmResources since it's not used without api. let (_, vmm) = match build_microvm_from_json( seccomp_filters, &mut event_manager, // Safe to unwrap since '--no-api' requires this to be set. config_json.unwrap(), instance_info, bool_timer_enabled, mmds_size_limit, metadata_json, ) { Ok((res, vmm)) => (res, vmm), Err(exit_code) => return exit_code, }; // Start the metrics. firecracker_metrics .lock() .expect(\"Poisoned lock\") .start(metrics::WRITE_METRICS_PERIOD_MS); // Run the EventManager that drives everything in the microVM. loop { event_manager .run() .expect(\"Failed to start the event manager\"); if let Some(exit_code) = vmm.lock().unwrap().shutdown_exit_code() { return exit_code; } } } build_microvm_from_json就用到了核心模块vmm firecracker/src/vmm/src build_microvm_from_json build_microvm_from_json //根据json填充VmResources结构体并初始化 let mut vm_resources = VmResources::from_json() let vmm = vmm::builder::build_microvm_for_boot(&vm_resources) //建立guest内存, 思路是在host上mmap, 并记录内存region到变量 let guest_memory = create_guest_memory() //在x86上, 0-768M是内存, 768M到4G是MMIO, 4G以上还是内存 let arch_mem_regions = arch::arch_memory_regions(mem_size) vm_memory::create_guest_memory(&arch_mem_regions) 为每个region mmap一个region //先mmap一个大的size, size=原size+2个page, 属性是libc::PROT_NONE // Map the guarded range to PROT_NONE let guard_addr = unsafe { libc::mmap( std::ptr::null_mut(), guarded_size, libc::PROT_NONE, libc::MAP_ANONYMOUS | libc::MAP_PRIVATE | libc::MAP_NORESERVE, -1, 0, ) }; //再在刚刚map的region里面, 用原size map一个读写region // Inside the protected range, starting with guard_addr + PAGE_SIZE, // map the requested range with received protection and flags let region_addr = unsafe { libc::mmap( region_start_addr as *mut libc::c_void, //前面返回的addr加个page size, prot, flags | libc::MAP_FIXED, fd, offset as libc::off_t, ) }; //最后build MmapRegion并返回, 用的是https://github.com/rust-vmm/vm-memory //到这里好像只是生成GuestMemoryMmap数据结果, 并没有实际操作啥 //加载linux 内核, 代码在firecracker/src/vmm/src/builder.rs let entry_addr = load_kernel(boot_config, &guest_memory)?; let kernel_file = 先open kernel文件 //使用了https://github.com/rust-vmm/linux-loader //下面的Loader在x86上是ELF, 在ARM上是PE //把kernel_file加载到guest_memory let entry_addr = Loader::load::( &guest_memory, &kernel_file, arch::get_kernel_start()) //上面这个get_kernel_start()在x86上是1MB, aarch64上是2GB //先读elf header, 解析所有program header到 let mut phdrs: Vec = vec![]; for 每个phdr //写入guest内存, 似乎只是写入host上mmap的内存. 可能后面会用kvm的api把这些内存映射成guest内存 guest_mem.read_exact_from(mem_offset, kernel_image, phdr.p_filesz as usize) //从guest_memory find 一个region, 并写入initrd的内容; //在我们的配置里, initrd是null let initrd = load_initrd_from_config(boot_config, &guest_memory)?; //重写cmdline, 再原基础上增加virtio等配置 //创建VM let (mut vmm, mut vcpus) = create_vmm_and_vcpus( instance_info, event_manager, guest_memory, None, track_dirty_pages, vcpu_config.vcpu_count, )?; // Set up Kvm Vm and register memory regions. //调用kvm-ioctls let mut vm = setup_kvm_vm(&guest_memory, track_dirty_pages)?; //open /dev/kvm, 然后ioctl KVM_CREATE_VM let mut vm = Vm::new() vm.memory_init() //每个region调用 ioctl KVM_SET_USER_MEMORY_REGION //MMIO_MEM_START在x86上是(4G-768M), 在aarch64上是1G //IRQ_BASE到IRQ_MAX在x86上是5到23, 在aarch64上是32到128 //这里说的是virtio设备用的irq号范围 //mmio_device_manager包括mmio_base, irq, 和bus let mmio_device_manager = MMIODeviceManager::new(arch::MMIO_MEM_START, (arch::IRQ_BASE, arch::IRQ_MAX)); //IrqManager是管理(first..last)irq范围的简单结构体 IrqManager::new() //device的bus是个BtreeMap组织的按地址空间划分的设备的集合 devices::Bus::new() //创建中断控制器 setup_interrupt_controller(&mut vm)?; //x86上是ioctl KVM_CREATE_IRQCHIP //aarch64上是GICv2::create(vm, vcpu_count) vm.setup_irqchip() //新建个eventfd let vcpus_exit_evt = EventFd::new(libc::EFD_NONBLOCK) vcpus = create_vcpus(&vm, vcpu_count, &vcpus_exit_evt) //for里创建n个vCPU, ioctl KVM_CREATE_VCPU let vcpu = Vcpu::new() vcpu.kvm_vcpu.init(vm.fd()) set_stdout_nonblocking(); // servial device是pio设备, 在x86上有, aarch64上没有 let serial_device = setup_serial_device(event_manager, stdin, stdout) //由Serial device写1产生event let interrupt_evt = EventFdTrigger::new(EventFd::new(EFD_NONBLOCK)) //表示in buffer ready let kick_stdin_read_evt = EventFdTrigger::new(EventFd::new(EFD_NONBLOCK)) //SerialWrapper是event和Servial的桥梁 let serial = SerialWrapper { serial: Serial::with_events( interrupt_evt, SerialEventsWrapper { metrics: METRICS.uart.clone(), buffer_ready_event_fd: Some(kick_stdin_read_evt), }, out, ), input: Some(input), } //加入event manager, 最后的event loop里面会监听stdin和kick_stdin_read_evt fd event_manager.add_subscriber(serial.clone()); //只有x86有pio device, 把上面的serial_device加入到pio_device_manager let pio_device_manager = create_pio_dev_manager_with_legacy_devices(&vm, serial_device, reset_evt) let vmm = Vmm { events_observer: Some(Box::new(SerialStdin::get())), instance_info: instance_info.clone(), shutdown_exit_code: None, vm, guest_memory, uffd, vcpus_handles: Vec::new(), vcpus_exit_evt, mmio_device_manager, #[cfg(target_arch = \"x86_64\")] pio_device_manager, }; //最后返回vmm, vcpus Ok((vmm, vcpus)) //这个是给测试用的, kernel启动完成后, test版本的init会直接写/dev/mem某个地址魔术字(123) attach_boot_timer_device(&mu vmm, request_ts)?; let boot_timer = devices::pseudo::BootTimer::new(request_ts); //在mmio里面分配地址空间, 所谓的注册就是按地址空间assign设备, 设备有读写函数 vmm.mmio_device_manager.register_mmio_boot_timer(boot_timer) //目前balloon设备没使能 attach_balloon_device(&mut vmm, &mut boot_cmdline, balloon, event_manager)?; attach_virtio_device(event_manager, vmm, id, balloon.clone(), cmdline) event_manager.add_subscriber(device.clone()); let device = MmioTransport::new(vmm.guest_memory().clone(), device); //分配mmio地址范围, 注册到mmio manager; 并修改cmdline vmm.mmio_device_manager.register_mmio_virtio_for_boot(vmm.vm.fd(), id, device, cmdline) //可能有多个virtio块设备 attach_block_devices( &mut vmm, &mut boot_cmdline, vm_resources.block.list.iter(), event_manager, )?; for 每个 block //如果是root device, 就增加cmdline \"root=/dev/vda\"或\"root=PARTUUID=partuuid\" //见下面的函数分析 attach_virtio_device(event_manager, vmm, id, block.clone(), cmdline)?; //可能有多个virtio net设备 attach_net_devices( &mut vmm, &mut boot_cmdline, vm_resources.net_builder.iter(), event_manager, )?; //对应virtio socket device //guest可以通过AF_VSOCK通过vsock device和host的AF_UNIX socket通信 attach_unixsock_vsock_device(&mut vmm, &mut boot_cmdline, unix_vsock, event_manager)?; configure_system_for_boot( &vmm, vcpus.as_mut(), vcpu_config, entry_addr, &initrd, boot_cmdline, )?; //启动vcpu到pause状态 // Move vcpus to their own threads and start their state machine in the 'Paused' state. vmm.start_vcpus( vcpus, seccomp_filters .get(\"vcpu\") .ok_or_else(|| MissingSeccompFilters(\"vcpu\".to_string()))? .clone(), ) //给每个vcpu起个thread thread::Builder::new().spawn(move || { //Runs the vCPU in KVM context in a loop. Handles KVM_EXITs then goes back in. //run的逻辑是执行StateMachine循环 //state machine从paused开始 self.run(filter); //状态机循环 while let Some(state_fn) = state_machine.function { // Run the current state handler, and get the next one. state_machine = state_fn(machine); } }) //使能seccomp seccompiler::apply_filter() // The vcpus start off in the `Paused` state, let them run. vmm.resume_vm().map_err(Internal)?; self.mmio_device_manager.kick_devices(); //对每个vCPU send event let vmm = Arc::new(Mutex::new(vmm)); event_manager.add_subscriber(vmm.clone()); VmResources定义如下: 一个VMM就由block vsock balloon net等builder构成 #[derive(Default)] pub struct VmResources { /// The vCpu and memory configuration for this microVM. vm_config: VmConfig, /// The boot configuration for this microVM. boot_config: Option, /// The block devices. pub block: BlockBuilder, /// The vsock device. pub vsock: VsockBuilder, /// The balloon device. pub balloon: BalloonBuilder, /// The network devices builder. pub net_builder: NetBuilder, /// The optional Mmds data store. // This is initialised on demand (if ever used), so that we don't allocate it unless it's // actually used. pub mmds: Option>>, /// Data store limit for the mmds. pub mmds_size_limit: usize, /// Whether or not to load boot timer device. pub boot_timer: bool, } event manager https://github.com/rust-vmm/event-manager 使用了epoll机制的事件驱动库 基本上是个epoll的event loop, event subscriber注册的时候掉哟init, 在loop里有对应的event就调用process. aarch64 物理内存layout // ==== Address map in use in ARM development systems today ==== // // - 32-bit - - 36-bit - - 40-bit - //1024GB + + +-------------------+ devices::Bus 一个device都对应一段地址空间, 一个bus包括多个device, 按BtreeMap组织, key是device的地址范围, value是BusDevice /// A device container for routing reads and writes over some address space. /// /// This doesn't have any restrictions on what kind of device or address space this applies to. The /// only restriction is that no two devices can overlap in this address space. #[derive(Clone, Default)] pub struct Bus { //bus下面是BtreeMap管理的device devices: BTreeMap>>, } Bus有get_device, insert, read, write方法. read和write的基本逻辑是通过地址来判断是哪个device, 然后lock这个设备, 然后read/write 比如: /// Reads data from the device that owns the range containing `addr` and puts it into `data`. /// /// Returns true on success, otherwise `data` is untouched. pub fn read(&self, addr: u64, data: &mut [u8]) -> bool { //self.get_device(addr)返回(offset,dev), offset就是\"设备内\"偏移地址 if let Some((offset, dev)) = self.get_device(addr) { // OK to unwrap as lock() failing is a serious error condition and should panic. dev.lock() .expect(\"Failed to acquire device lock\") .read(offset, data); true } else { false } } 底层serial vm-superio-0.5.0/src/serial.rs serial是个泛型的结构体: The serial console emulation is done by emulating a serial COM port. Each serial COM port (COM1-4) has an associated Port I/O address base and 12 registers mapped into 8 consecutive Port I/O locations (with the first one being the base). This structure emulates the registers that make sense for UART 16550 (and below) and helps in the interaction between the driver and device by using a Trigger object for notifications. It also writes the guest's output to an out Write object. serial模拟了UART的16550的12个寄存器 用法 use std::io::{sink, Error, Result}; use std::ops::Deref; use vm_superio::Trigger; use vm_superio::Serial; use vmm_sys_util::eventfd::EventFd; struct EventFdTrigger(EventFd); impl Trigger for EventFdTrigger { type E = Error; fn trigger(&self) -> Result { self.write(1) } } impl Deref for EventFdTrigger { type Target = EventFd; fn deref(&self) -> &Self::Target { &self.0 } } impl EventFdTrigger { pub fn new(flag: i32) -> Self { EventFdTrigger(EventFd::new(flag).unwrap()) } pub fn try_clone(&self) -> Self { EventFdTrigger((**self).try_clone().unwrap()) } } let intr_evt = EventFdTrigger::new(libc::EFD_NONBLOCK); let mut serial = Serial::new(intr_evt.try_clone(), Vec::new()); // std::io::Sink can be used if user is not interested in guest's output. let serial_with_sink = Serial::new(intr_evt, sink()); // Write 0x01 to THR register. serial.write(0, 0x01).unwrap(); // Read from RBR register. let value = serial.read(0); // Send more bytes to the guest in one shot. let input = &[b'a', b'b', b'c']; // Before enqueuing bytes we first check if there is enough free space // in the FIFO. if serial.fifo_capacity() >= input.len() { serial.enqueue_raw_bytes(input).unwrap(); } Serial结构体 这是个泛型, 需要用三个trait: Trigger, SerialEvents, Write来实例化. pub struct Serial { // Some UART registers. baud_divisor_low: u8, baud_divisor_high: u8, interrupt_enable: u8, interrupt_identification: u8, line_control: u8, line_status: u8, modem_control: u8, modem_status: u8, scratch: u8, // This is the buffer that is used for achieving the Receiver register // functionality in FIFO mode. Reading from RBR will return the oldest // unread byte from the RX FIFO. in_buffer: VecDeque, // Used for notifying the driver about some in/out events. interrupt_evt: T, events: EV, out: W, } 三个Trait pub trait SerialEvents { /// The driver reads data from the input buffer. fn buffer_read(&self); /// The driver successfully wrote one byte to serial output. fn out_byte(&self); /// An error occurred while writing a byte to serial output resulting in a lost byte. fn tx_lost_byte(&self); /// This event can be used by the consumer to re-enable events coming from /// the serial input. fn in_buffer_empty(&self); } //一般都是EventFD, 用于trigger通知guest driver? pub trait Trigger { /// Underlying type for the potential error conditions returned by `Self::trigger`. type E; /// Trigger an event. fn trigger(&self) -> Result; } //Write就是io哪个Write 自定义Error /// Errors encountered while handling serial console operations. #[derive(Debug)] pub enum Error { /// Failed to trigger interrupt. Trigger(E), /// Couldn't write/flush to the given destination. IOError(io::Error), /// No space left in FIFO. FullFifo, } 用NoEvents的实例化的Serial NoEvents结构体就是实现了一个啥也不干的SerialEvents pub struct NoEvents; impl SerialEvents for NoEvents { fn buffer_read(&self) {} fn out_byte(&self) {} fn tx_lost_byte(&self) {} fn in_buffer_empty(&self) {} } 一个更具体的实例化: impl Serial { /// Creates a new `Serial` instance which writes the guest's output to /// `out` and uses `trigger` object to notify the driver about new /// events. /// /// # Arguments /// * `trigger` - The Trigger object that will be used to notify the driver /// about events. /// * `out` - An object for writing guest's output to. In case the output /// is not of interest, /// [std::io::Sink](https://doc.rust-lang.org/std/io/struct.Sink.html) /// can be used here. /// /// # Example /// /// You can see an example of how to use this function in the /// [`Example` section from `Serial`](struct.Serial.html#example). pub fn new(trigger: T, out: W) -> Serial { Self::with_events(trigger, NoEvents, out) } } 同样的Serial是范围更大的泛型: impl Serial { /// Creates a new `Serial` instance which writes the guest's output to /// `out`, uses `trigger` object to notify the driver about new /// events, and invokes the `serial_evts` implementation of `SerialEvents` /// during operation. /// /// # Arguments /// * `trigger` - The `Trigger` object that will be used to notify the driver /// about events. /// * `serial_evts` - The `SerialEvents` implementation used to track the occurrence /// of significant events in the serial operation logic. /// * `out` - An object for writing guest's output to. In case the output /// is not of interest, /// [std::io::Sink](https://doc.rust-lang.org/std/io/struct.Sink.html) /// can be used here. pub fn with_events(trigger: T, serial_evts: EV, out: W) -> Self { //用了很多const定义个u8的常量, 比如DEFAULT_BAUD_DIVISOR_LOW是0x0C Serial { baud_divisor_low: DEFAULT_BAUD_DIVISOR_LOW, baud_divisor_high: DEFAULT_BAUD_DIVISOR_HIGH, interrupt_enable: DEFAULT_INTERRUPT_ENABLE, interrupt_identification: DEFAULT_INTERRUPT_IDENTIFICATION, line_control: DEFAULT_LINE_CONTROL, line_status: DEFAULT_LINE_STATUS, modem_control: DEFAULT_MODEM_CONTROL, modem_status: DEFAULT_MODEM_STATUS, scratch: DEFAULT_SCRATCH, in_buffer: VecDeque::new(), interrupt_evt: trigger, events: serial_evts, out, } } /// Provides a reference to the interrupt event object. pub fn interrupt_evt(&self) -> &T { &self.interrupt_evt } /// Provides a reference to the serial events object. pub fn events(&self) -> &EV { &self.events } //具体操作, 私有方法, 基本上是对结构体的各field进行操作 fn is_dlab_set(&self) -> bool { (self.line_control & LCR_DLAB_BIT) != 0 } //还有很多, 省略 //读写函数, 谁来读写? driver //write不是io Write的格式, offset是预定义的常量表中的常量 /// Handles a write request from the driver at `offset` offset from the /// base Port I/O address. /// /// # Arguments /// * `offset` - The offset that will be added to the base PIO address /// for writing to a specific register. /// * `value` - The byte that should be written. /// /// # Example /// /// You can see an example of how to use this function in the /// [`Example` section from `Serial`](struct.Serial.html#example). pub fn write(&mut self, offset: u8, value: u8) -> Result> { match offset { DLAB_LOW_OFFSET if self.is_dlab_set() => self.baud_divisor_low = value, DLAB_HIGH_OFFSET if self.is_dlab_set() => self.baud_divisor_high = value, //关键路径, 每次写入一个字节; 写到stdout DATA_OFFSET => { let res = self .out //重点是这里, 这个out一般是stdout, guest driver的write, 通过这里的Serial Device(Self), 写到stdout .write_all(&[value]) .map_err(Error::IOError) .and_then(|_| self.out.flush().map_err(Error::IOError)) .map(|_| self.events.out_byte()) .map_err(|err| { self.events.tx_lost_byte(); err }); // Because we cannot block the driver, the THRE interrupt is sent // irrespective of whether we are able to write the byte or not self.thr_empty_interrupt().map_err(Error::Trigger)?; return res; } _ => {} } Ok(()) } //读的逻辑是从self.in_buffer pop出一个字节, 返回给调用者. /// Handles a read request from the driver at `offset` offset from the /// base Port I/O address. /// /// Returns the read value. /// /// # Arguments /// * `offset` - The offset that will be added to the base PIO address /// for reading from a specific register. /// /// # Example /// /// You can see an example of how to use this function in the /// [`Example` section from `Serial`](struct.Serial.html#example). pub fn read(&mut self, offset: u8) -> u8 { match offset { DLAB_LOW_OFFSET if self.is_dlab_set() => self.baud_divisor_low, DLAB_HIGH_OFFSET if self.is_dlab_set() => self.baud_divisor_high, DATA_OFFSET => { // Here we emulate the reset method for when RDA interrupt // was raised (i.e. read the receive buffer and clear the // interrupt identification register and RDA bit when no // more data is available). self.del_interrupt(IIR_RDA_BIT); let byte = self.in_buffer.pop_front().unwrap_or_default(); if self.in_buffer.is_empty() { self.clear_lsr_rda_bit(); self.events.in_buffer_empty(); } self.events.buffer_read(); byte } LCR_OFFSET => self.line_control, MCR_OFFSET => self.modem_control, LSR_OFFSET => self.line_status, _ => 0, } } /// Returns how much space is still available in the FIFO. /// /// # Example /// /// You can see an example of how to use this function in the /// [`Example` section from `Serial`](struct.Serial.html#example). #[inline] pub fn fifo_capacity(&self) -> usize { FIFO_SIZE - self.in_buffer.len() } /// Helps in sending more bytes to the guest in one shot, by storing /// `input` bytes in UART buffer and letting the driver know there is /// some pending data to be read by setting RDA bit and its corresponding /// interrupt when not already triggered. /// /// # Arguments /// * `input` - The data to be sent to the guest. /// /// # Returns /// /// The function returns the number of bytes it was able to write to the fifo, /// or `FullFifo` error when the fifo is full. Users can use /// [`fifo_capacity`](#method.fifo_capacity) before calling this function /// to check the available space. /// /// # Example /// /// You can see an example of how to use this function in the /// [`Example` section from `Serial`](struct.Serial.html#example). pub fn enqueue_raw_bytes(&mut self, input: &[u8]) -> Result> { let mut write_count = 0; if !self.is_in_loop_mode() { if self.fifo_capacity() == 0 { return Err(Error::FullFifo); } write_count = std::cmp::min(self.fifo_capacity(), input.len()); if write_count > 0 { self.in_buffer.extend(&input[0..write_count]); self.set_lsr_rda_bit(); //就是给Self.interrupt_evt这个eventfd写1 self.received_data_interrupt().map_err(Error::Trigger)?; } } Ok(write_count) } } driver在哪里读写? 待续 SerialWrapper SerialWrapper包括了底层Serial设备和input SerialWrapper: firecracker/src/devices/src/legacy/serial.rs 底层Serial: vm-superio-0.5.0/src/serial.rs pub struct SerialWrapper { pub serial: Serial, pub input: Option>, } 这个结构体是Serial device和event loop之间的桥梁. 之间用eventfd来通知 Host VMM Guest stdin/stdout Serial设备 read/write driver 具体来讲, guest driver通过BusDevice向Serial设备发出读写请求, VMM调用Serial设备的read/write函数来完成响应并在某些情况下触发中断通知(可能是给PioManager), 比如在给in_buffer读到data后产生received_data_interrupt. Serial结构体来维护UART16550的硬件的寄存器level的行为. 从stdin读输入发给guest流程 SerialWrapper的的实例实现了recv_bytes impl SerialWrapper { fn recv_bytes(&mut self) -> io::Result { let avail_cap = self.serial.fifo_capacity(); if let Some(input) = self.input.as_mut() { let mut out = vec![0u8; avail_cap]; //指定cap的vec //从stdin读 let count = input.read(&mut out)?; //看来&mut Vec能当作&mut [u8] if count > 0 { self.serial //这个有点讲究了, raw_input并不是底层Serial的方法, 而是本文件定义的trait //底层调用的是Servial设备的enqueue_raw_bytes方法, 往底层Servial的in_buffer填数据 .raw_input(&out[..count]) .map_err(|_| io::Error::from_raw_os_error(libc::ENOBUFS))?; } return Ok(count); } Err(io::Error::from_raw_os_error(libc::ENOTTY)) } } 这个recv_bytes被MutEventSubscriber trait调用, SerialWrapper也实现了MutEventSubscriber 里面的process就调用了recv_bytes 具体没怎么看懂 impl MutEventSubscriber for SerialWrapper { //process会在发生event的时候被调用, 传入event和ops用来表示event类型和维护event //可能有多个fd的源头, 但都共用这一个process函数. /// Handle events on the serial input fd. fn process(&mut self, event: Events, ops: &mut EventOps) { #[inline] fn unregister_source(ops: &mut EventOps, source: &T) { match ops.remove(Events::new(source, EventSet::IN)) { Ok(_) => (), Err(_) => error!(\"Could not unregister source fd: {}\", source.as_raw_fd()), } } let input_fd = self.serial_input_fd(); let buffer_ready_fd = self.buffer_ready_evt_fd(); if input_fd (), Err(err) => { error!(\"Detach serial device input source due to error in consuming the buffer ready event: {:?}\", err); unregister_source(ops, &input_fd); unregister_source(ops, &buffer_ready_fd); return; } } } // We expect to receive: `EventSet::IN`, `EventSet::HANG_UP` or // `EventSet::ERROR`. To process all these events we just have to // read from the serial input. match self.recv_bytes() { Ok(count) => { // Handle EOF if the event came from the input source. if input_fd == event.fd() && count == 0 { unregister_source(ops, &input_fd); unregister_source(ops, &buffer_ready_fd); warn!(\"Detached the serial input due to peer close/error.\"); } } Err(e) => { match e.raw_os_error() { Some(errno) if errno == libc::ENOBUFS => { unregister_source(ops, &input_fd); } //这里是none-block read没东西的时候会返回EAGAIN或者EWOULDBLOCK, 都差不多 Some(errno) if errno == libc::EWOULDBLOCK => { self.handle_ewouldblock(ops); } Some(errno) if errno == libc::ENOTTY => { error!(\"The serial device does not have the input source attached.\"); unregister_source(ops, &input_fd); unregister_source(ops, &buffer_ready_fd); } Some(_) | None => { // Unknown error, detach the serial input source. unregister_source(ops, &input_fd); unregister_source(ops, &buffer_ready_fd); warn!(\"Detached the serial input due to peer close/error.\"); } } } } } /// Initial registration of pollable objects. /// If serial input is present, register the serial input FD as readable. fn init(&mut self, ops: &mut EventOps) { //input就是stdin, buffer_ready_event_fd就是前面的kick_stdin_read_evt这个eventfd if self.input.is_some() && self.serial.events().buffer_ready_event_fd.is_some() { let serial_fd = self.serial_input_fd(); let buf_ready_evt = self.buffer_ready_evt_fd(); if serial_fd != -1 { //实际上是把stdin加到epoll if let Err(e) = ops.add(Events::new(&serial_fd, EventSet::IN)) { warn!(\"Failed to register serial input fd: {}\", e); } } //这个实际上是kick_stdin_read_evt这个eventfd if let Err(e) = ops.add(Events::new(&buf_ready_evt, EventSet::IN)) { warn!(\"Failed to register serial buffer ready event: {}\", e); } } } } 实现了BusDevice的按地址读写的trait 按总线地址读写, 最终转化为设备内偏移地址读写 impl BusDevice for SerialWrapper { //读是从内部in_buffer读 fn read(&mut self, offset: u64, data: &mut [u8]) { if data.len() != 1 { self.serial.events().metrics.missed_read_count.inc(); return; } data[0] = self.serial.read(offset as u8); } //写是写到stdout fn write(&mut self, offset: u64, data: &[u8]) { if data.len() != 1 { self.serial.events().metrics.missed_write_count.inc(); return; } if let Err(e) = self.serial.write(offset as u8, data[0]) { // Counter incremented for any handle_write() error. error!(\"Failed the write to serial: {:?}\", e); self.serial.events().metrics.error_count.inc(); } } } attach_virtio_device /// Attaches a VirtioDevice device to the device manager and event manager. fn attach_virtio_device( event_manager: &mut EventManager, vmm: &mut Vmm, id: String, device: Arc>, cmdline: &mut LoaderKernelCmdline, ) -> std::result::Result { use self::StartMicrovmError::*; //注册事件订阅 event_manager.add_subscriber(device.clone()); let device = MmioTransport::new(vmm.guest_memory().clone(), device); vmm.mmio_device_manager .register_mmio_virtio_for_boot(vmm.vm.fd(), id, device, cmdline) //分配mmio的addr len和irq资源, 策略是依次顺序分配 let mmio_slot = self.allocate_new_slot(1)?; self.register_mmio_virtio(vm, device_id, mmio_device, &mmio_slot)?; let locked_device = mmio_device.locked_device(); identifier = (DeviceType::Virtio(locked_device.device_type()), device_id); //对每个queue for (i, queue_evt) in locked_device.queue_events().iter().enumerate() //NOTIFY_REG_OFFSET是0x50, 加上slot.addr这个mmio device的base地址 //注意, 并不是所有的mmio设备的地址空间访问都会触发event, 这个io_addr只是特定地址, 用来notify device的. let io_addr = IoEventAddress::Mmio(slot.addr + u64::from(devices::virtio::NOTIFY_REG_OFFSET)); //这个queue_evt是每个queue的eventfd, 写io_addr就会触发event, 说明guest driver要通知device来干活了 //调用了kvm的ioctl vm.register_ioevent(queue_evt, &io_addr, i as u32) //写这指定地址的时候发event到queue_evt vm.register_irqfd() //注册中断注入guest的eventfd和irq号, 调用kvm ioctl KVM_IRQFD; 意思是只要这个eventfd被写入, 内核的kvm模块就会给guest发指定的irq号中断. register_mmio_device() } vm.register_ioevent(queue_evt, &io_addr, i as u32) 三个参数如下: fd - EventFd which will be signaled. When signaling, the usual vmexit to userspace is prevented.addr - Address being written to.datamatch - Limits signaling fd to only the cases where the value being written is equal to this parameter. The size of datamatch is important and it must match the expected size of the guest's write. guest驱动需要某种方法来通知device, kvm的ioeventfd就是干这个用的. 用eventfd的好处是这个guest driver到device的通知不需要vmexit. Registers an event to be signaled whenever a certain address is written to. When signaling, the usual vmexit to userspace is prevented. 对应KVM的KVM_IOEVENTFD This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address within the guest. A guest write in the registered address will signal the provided event instead of triggering an exit. If datamatch flag is set, the event will be signaled only if the written value to the registered address is equal to datamatch in struct kvm_ioeventfd. 注意: 这个对每个queue都调用了vm.register_ioevent(queue_evt, &io_addr, i as u32), 作用是给io_addr地址绑定一个queue_evt, 当driver写i到这个io_aadr地址的时候, signal给queue_evt. 但问题是, 如果是多个queue, 多个queue_evt都\"绑定\"到同一个io_addr.我猜测这个API是支持多个一个地址对应多个eventfd的, 可能由datamatch的值来区分这个signal发送到哪个eventfd vm.register_irqfd vm.register_irqfd(locked_device.interrupt_evt(), slot.irqs[0]) 调用kvm的ioctl的KVM_IRQFD(见下面) IRQFD是device写eventfd, 通过kvm触发guest中断的机制. kvm的irq相关API https://www.kernel.org/doc/html/latest/virt/kvm/api.html KVM_CREATE_IRQCHIP Creates an interrupt controller model in the kernel. On x86, creates a virtual ioapic, a virtual PIC (two PICs, nested), and sets up future vcpus to have a local APIC. IRQ routing for GSIs 0-15 is set to both PIC and IOAPIC; GSI 16-23 only go to the IOAPIC. On arm64, a GICv2 is created. Any other GIC versions require the usage of KVM_CREATE_DEVICE, which also supports creating a GICv2. Using KVM_CREATE_DEVICE is preferred over KVM_CREATE_IRQCHIP for GICv2. On s390, a dummy irq routing table is created. KVM_SET_GSI_ROUTING Sets the GSI routing table entries, overwriting any previously set entries. KVM_IRQFD Allows setting an eventfd to directly trigger a guest interrupt. kvm_irqfd.fd specifies the file descriptor to use as the eventfd and kvm_irqfd.gsi specifies the irqchip pin toggled by this event. When an event is triggered on the eventfd, an interrupt is injected into the guest using the specified gsi pin. The irqfd is removed using the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both kvm_irqfd.fd and kvm_irqfd.gsi. With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify mechanism allowing emulation of level-triggered, irqfd-based interrupts. When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an additional eventfd in the kvm_irqfd.resamplefd field. When operating in resample mode, posting of an interrupt through kvm_irq.fd asserts the specified gsi in the irqchip. When the irqchip is resampled, such as from an EOI, the gsi is de-asserted and the user is notified via kvm_irqfd.resamplefd. It is the user’s responsibility to re-queue the interrupt if the device making use of it still requires service. Note that closing the resamplefd is not sufficient to disable the irqfd. The KVM_IRQFD_FLAG_RESAMPLE is only necessary on assignment and need not be specified with KVM_IRQFD_FLAG_DEASSIGN. On arm64, gsi routing being supported, the following can happen: in case no routing entry is associated to this gsi, injection fails in case the gsi is associated to an irqchip routing entry, irqchip.pin + 32 corresponds to the injected SPI ID. in case the gsi is associated to an MSI routing entry, the MSI message and device ID are translated into an LPI (support restricted to GICv3 ITS in-kernel emulation). KVM_CREATE_DEVICE Creates an emulated device in the kernel. The file descriptor returned in fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR. If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the device type is supported (not necessarily whether it can be created in the current vm). Individual devices should not define flags. Attributes should be used for specifying any behavior that is not implied by the device type number. 都有哪些可以被create Devices ARM Virtual Interrupt Translation Service (ITS) ARM Virtual Generic Interrupt Controller v2 (VGIC) ARM Virtual Generic Interrupt Controller v3 and later (VGICv3) MPIC interrupt controller FLIC (floating interrupt controller) Generic vcpu interface VFIO virtual device Generic vm interface XICS interrupt controller POWER9 eXternal Interrupt Virtualization Engine (XIVE Gen1) ARM gic v3 Only one VGIC instance may be instantiated through this API. The created VGIC will act as the VM interrupt controller, requiring emulated user-space devices to inject interrupts to the VGIC instead of directly to CPUs. It is not possible to create both a GICv3 and GICv2 on the same VM. Creating a guest GICv3 device requires a host GICv3 as well. KVM_DEV_ARM_VGIC_GRP_ADDR 定义了vgic寄存器在guest物理地址空间的基地址 KVM_VGIC_V3_ADDR_TYPE_DIST (rw, 64-bit) Base address in the guest physical address space of the GICv3 distributor register mappings. Only valid for KVM_DEV_TYPE_ARM_VGIC_V3. This address needs to be 64K aligned and the region covers 64 KByte. KVM_VGIC_V3_ADDR_TYPE_REDIST (rw, 64-bit) Base address in the guest physical address space of the GICv3 redistributor register mappings. There are two 64K pages for each VCPU and all of the redistributor pages are contiguous. Only valid for KVM_DEV_TYPE_ARM_VGIC_V3. This address needs to be 64K aligned. MmioTransport mplements the MMIO transport for virtio devices. This requires 3 points of installation to work with a VM: Mmio reads and writes must be sent to this device at what is referred to here as MMIO base. Mmio::queue_evts must be installed at virtio::NOTIFY_REG_OFFSET offset from the MMIO base. Each event in the array must be signaled if the index is written at that offset. Mmio::interrupt_evt must signal an interrupt that the guest driver is listening to when it is written to. Typically one page (4096 bytes) of MMIO address space is sufficient to handle this transport and inner virtio device. 对应的结构体: pub struct MmioTransport { device: Arc>, // The register where feature bits are stored. pub(crate) features_select: u32, // The register where features page is selected. pub(crate) acked_features_select: u32, pub(crate) queue_select: u32, pub(crate) device_status: u32, pub(crate) config_generation: u32, mem: GuestMemoryMmap, pub(crate) interrupt_status: Arc, } impl MmioTransport impl MmioTransport { /// Constructs a new MMIO transport for the given virtio device. pub fn new(mem: GuestMemoryMmap, device: Arc>) -> MmioTransport { //这里小知识点: device.lock()返回的是mutextGuard, 它会在生命周期结束后自动调用unlock. //不用担心一直会lock, 因为device.lock()的声明周期只有下面一行 //这行结束了其实就已经unlock了. let interrupt_status = device.lock().expect(\"Poisoned lock\").interrupt_status(); //new这个结构体 MmioTransport { device, features_select: 0, acked_features_select: 0, queue_select: 0, device_status: device_status::INIT, config_generation: 0, mem, interrupt_status, } } pub fn locked_device(&self) -> MutexGuard { self.device.lock().expect(\"Poisoned lock\") } // Gets the encapsulated VirtioDevice. pub fn device(&self) -> Arc> { self.device.clone() } fn check_device_status(&self, set: u32, clr: u32) -> bool { self.device_status & (set | clr) == set } fn are_queues_valid(&self) -> bool { self.locked_device() .queues() .iter() .all(|q| q.is_valid(&self.mem)) } //注意到泛型U, 并没有约束; //这里的意思是入参d的类型是U, 表示默认值. fn with_queue(&self, d: U, f: F) -> U where F: FnOnce(&Queue) -> U, { match self .locked_device() .queues() .get(self.queue_select as usize) { Some(queue) => f(queue), None => d, } } fn with_queue_mut(&mut self, f: F) -> bool { if let Some(queue) = self .locked_device() .queues_mut() .get_mut(self.queue_select as usize) { f(queue); true } else { false } } fn update_queue_field(&mut self, f: F) { if self.check_device_status( device_status::FEATURES_OK, device_status::DRIVER_OK | device_status::FAILED, ) { self.with_queue_mut(f); } else { warn!( \"update virtio queue in invalid state 0x{:x}\", self.device_status ); } } fn reset(&mut self) { 重置结构体\"寄存器\" } //根据VirtIO Spec 1.0, section 2.1.1 and 3.1.1 //在device的write里面调用, 实际上是给guest的driver用的 fn set_device_status(&mut self, status: u32) { } } 实现BusDevice 根据virtIO规范MMIO transport方式:https://docs.oasis-open.org/virtio/virtio/v1.2/csd01/virtio-v1.2-csd01.html#x1-1650002 impl BusDevice for MmioTransport { fn read(&mut self, offset: u64, data: &mut [u8]) { match offset { 0x00..=0xff if data.len() == 4 => { let v = match offset { 0x0 => MMIO_MAGIC_VALUE, 0x04 => MMIO_VERSION, 0x08 => self.locked_device().device_type(), 0x0c => VENDOR_ID, // vendor id 0x10 => { //32bit的feature flag let mut features = self .locked_device() .avail_features_by_page(self.features_select); if self.features_select == 1 { features |= 0x1; // enable support of VirtIO Version 1 } features } //对已经选中的queue(QueueSel), 读出queue内元素个数; Reading from the register returns the maximum size (number of elements) of the queue the device is ready to process or zero (0x0) if the queue is not available. 0x34 => self.with_queue(0, |q| u32::from(q.get_max_size())), //对已经选中的queue, 写1表示ready. 读是读上一次的值 0x44 => self.with_queue(0, |q| q.ready as u32), //中断状态寄存器, 要么是Used Buffer Notification(bit 0), 要么是Configuration Change Notification(bit 1) 0x60 => self.interrupt_status.load(Ordering::SeqCst) as u32, //设备状态寄存器. 0x70 => self.device_status, //配置空间原子性寄存器, 两次读的一样就是原子的? 0xfc => self.config_generation, _ => { warn!(\"unknown virtio mmio register read: 0x{:x}\", offset); return; } }; byte_order::write_le_u32(data, v); //注意这里, 使用byte_order的小端写 } 0x100..=0xfff => self.locked_device().read_config(offset - 0x100, data), _ => { warn!( \"invalid virtio mmio read: 0x{:x}:0x{:x}\", offset, data.len() ); } }; } fn write(&mut self, offset: u64, data: &[u8]) { fn hi(v: &mut GuestAddress, x: u32) { *v = (*v & 0xffff_ffff) | (u64::from(x) { let v = byte_order::read_le_u32(data); //按小端方式理解data match offset { //Device (host) features word selection. 写这个寄存器选择feature flag 0x14 => self.features_select = v, //Flags representing device features understood and activated by the driver 0x20 => { if self.check_device_status( device_status::DRIVER, device_status::FEATURES_OK | device_status::FAILED, ) { self.locked_device() .ack_features_by_page(self.acked_features_select, v); } else { warn!( \"ack virtio features in invalid state 0x{:x}\", self.device_status ); } } //Activated (guest) features word selection 0x24 => self.acked_features_select = v, //这个就是QueueSel, 也叫Virtual queue index, 从0开始 0x30 => self.queue_select = v, //Virtual queue size 0x38 => self.update_queue_field(|q| q.size = v as u16), //queue read //Writing one (0x1) to this register notifies the device that it can execute requests from this virtual queue. 0x44 => self.update_queue_field(|q| q.ready = v == 1), //中断应答 0x64 => { if self.check_device_status(device_status::DRIVER_OK, 0) { self.interrupt_status .fetch_and(!(v as usize), Ordering::SeqCst); } } //Device status: Writing non-zero values to this register sets the status flags, indicating the driver progress 0x70 => self.set_device_status(v), //Virtual queue’s Descriptor Area 64 bit long physical address 0x80 => self.update_queue_field(|q| lo(&mut q.desc_table, v)), 0x84 => self.update_queue_field(|q| hi(&mut q.desc_table, v)), //Virtual queue’s Driver Area 64 bit long physical address 0x90 => self.update_queue_field(|q| lo(&mut q.avail_ring, v)), 0x94 => self.update_queue_field(|q| hi(&mut q.avail_ring, v)), //Virtual queue’s Device Area 64 bit long physical address 0xa0 => self.update_queue_field(|q| lo(&mut q.used_ring, v)), 0xa4 => self.update_queue_field(|q| hi(&mut q.used_ring, v)), _ => { warn!(\"unknown virtio mmio register write: 0x{:x}\", offset); } } } 0x100..=0xfff => { if self.check_device_status(device_status::DRIVER, device_status::FAILED) { self.locked_device().write_config(offset - 0x100, data) } else { warn!(\"can not write to device config data area before driver is ready\"); } } _ => { warn!( \"invalid virtio mmio write: 0x{:x}:0x{:x}\", offset, data.len() ); } } } } device device的状态有 /// Enum that indicates if a VirtioDevice is inactive or has been activated /// and memory attached to it. pub enum DeviceState { Inactive, Activated(GuestMemoryMmap), } 这个enum也有方法, 其中mem()方法返回GuestmemoryMmap impl DeviceState { /// Checks if the device is activated. pub fn is_activated(&self) -> bool { match self { DeviceState::Inactive => false, DeviceState::Activated(_) => true, } } /// Gets the memory attached to the device if it is activated. pub fn mem(&self) -> Option { match self { DeviceState::Activated(ref mem) => Some(mem), DeviceState::Inactive => None, } } } IrqTrigger IrqTrigger包含一个eventFd叫irq_evt, trigger_irq方法就是写这个eventFd. /// Helper struct that is responsible for triggering guest IRQs pub struct IrqTrigger { pub(crate) irq_status: Arc, pub(crate) irq_evt: EventFd, } impl IrqTrigger { pub fn new() -> std::io::Result { Ok(Self { irq_status: Arc::new(AtomicUsize::new(0)), irq_evt: EventFd::new(libc::EFD_NONBLOCK)?, }) } pub fn trigger_irq(&self, irq_type: IrqType) -> std::result::Result { let irq = match irq_type { IrqType::Config => VIRTIO_MMIO_INT_CONFIG, IrqType::Vring => VIRTIO_MMIO_INT_VRING, }; //irq状态 self.irq_status.fetch_or(irq as usize, Ordering::SeqCst); //eventfd写1 self.irq_evt.write(1).map_err(|e| { error!(\"Failed to send irq to the guest: {:?}\", e); e })?; Ok(()) } } VirtioDevice trait /// Trait for virtio devices to be driven by a virtio transport. /// /// The lifecycle of a virtio device is to be moved to a virtio transport, which will then query the /// device. The virtio devices needs to create queues, events and event fds for interrupts and expose /// them to the transport via get_queues/get_queue_events/get_interrupt/get_interrupt_status fns. pub trait VirtioDevice: AsAny + Send { /// Get the available features offered by device. fn avail_features(&self) -> u64; /// Get acknowledged features of the driver. fn acked_features(&self) -> u64; /// Set acknowledged features of the driver. /// This function must maintain the following invariant: /// - self.avail_features() & self.acked_features() = self.get_acked_features() fn set_acked_features(&mut self, acked_features: u64); fn has_feature(&self, feature: u64) -> bool { (self.acked_features() & 1 u32; /// Returns the device queues. fn queues(&self) -> &[Queue]; /// Returns a mutable reference to the device queues. fn queues_mut(&mut self) -> &mut [Queue]; /// Returns the device queues event fds. fn queue_events(&self) -> &[EventFd]; /// Returns the device interrupt eventfd. fn interrupt_evt(&self) -> &EventFd; /// Returns the current device interrupt status. fn interrupt_status(&self) -> Arc; /// The set of feature bits shifted by `page * 32`. fn avail_features_by_page(&self, page: u32) -> u32 { let avail_features = self.avail_features(); match page { // Get the lower 32-bits of the features bitfield. 0 => avail_features as u32, // Get the upper 32-bits of the features bitfield. 1 => (avail_features >> 32) as u32, _ => { warn!(\"Received request for unknown features page.\"); 0u32 } } } /// Acknowledges that this set of features should be enabled. fn ack_features_by_page(&mut self, page: u32, value: u32) { let mut v = match page { 0 => u64::from(value), 1 => u64::from(value) { warn!(\"Cannot acknowledge unknown features page: {}\", page); 0u64 } }; // Check if the guest is ACK'ing a feature that we didn't claim to have. let avail_features = self.avail_features(); let unrequested_features = v & !avail_features; if unrequested_features != 0 { warn!(\"Received acknowledge request for unknown feature: {:x}\", v); // Don't count these features as acked. v &= !unrequested_features; } self.set_acked_features(self.acked_features() | v); } /// Reads this device configuration space at `offset`. fn read_config(&self, offset: u64, data: &mut [u8]); /// Writes to this device configuration space at `offset`. fn write_config(&mut self, offset: u64, data: &[u8]); /// Performs the formal activation for a device, which can be verified also with `is_activated`. fn activate(&mut self, mem: GuestMemoryMmap) -> ActivateResult; /// Checks if the resources of this device are activated. fn is_activated(&self) -> bool; /// Optionally deactivates this device and returns ownership of the guest memory map, interrupt /// event, and queue events. fn reset(&mut self) -> Option)> { None } } VirtIO设备框图 virtIO net virtIO net的定义很复杂 pub struct Net { pub(crate) id: String, pub tap: Tap, //对接的tap设备 pub(crate) avail_features: u64, pub(crate) acked_features: u64, pub(crate) queues: Vec, pub(crate) queue_evts: Vec, pub(crate) rx_rate_limiter: RateLimiter, pub(crate) tx_rate_limiter: RateLimiter, pub(crate) rx_deferred_frame: bool, rx_deferred_irqs: bool, rx_bytes_read: usize, rx_frame_buf: [u8; MAX_BUFFER_SIZE], tx_iovec: Vec, tx_frame_buf: [u8; MAX_BUFFER_SIZE], pub(crate) irq_trigger: IrqTrigger, //中断触发, 里面是eventfd pub(crate) config_space: ConfigSpace, pub(crate) guest_mac: Option, pub(crate) device_state: DeviceState, pub(crate) activate_evt: EventFd, pub mmds_ns: Option, #[cfg(test)] pub(crate) mocks: Mocks, } Net实现了很多方法, 比如交换tap设备和queue的数据: impl Net { new_with_tap() id() guest_mac() iface_name() mmds_ns() signal_used_queue() {self.irq_trigger.trigger_irq()} signal_rx_used_queue() do_write_frame_to_guest( write_frame_to_guest() read_from_mmds_or_tap() //处理从tap设备来的数据, 然后给guest发irq: //self.signal_used_queue() -> self.irq_trigger.trigger_irq(IrqType::Vring) 还是写eventfd process_rx() handle_deferred_frame() resume_rx() process_tx() read_tap() process_rx_queue_event() process_tap_rx_event() process_tx_queue_event() process_virtio_queues() } Net实现了VirtioDevice 相对比较薄的一层, 实现了下面的方法: Net还实现了MutEventSubscriber impl MutEventSubscriber for Net { fn process(&mut self, event: Events, ops: &mut EventOps) { let source = event.fd(); let event_set = event.event_set(); // TODO: also check for errors. Pending high level discussions on how we want // to handle errors in devices. let supported_events = EventSet::IN; if !supported_events.contains(event_set) { warn!( \"Received unknown event: {:?} from source: {:?}\", event_set, source ); return; } if self.is_activated() { let virtq_rx_ev_fd = self.queue_evts[RX_INDEX].as_raw_fd(); let virtq_tx_ev_fd = self.queue_evts[TX_INDEX].as_raw_fd(); let rx_rate_limiter_fd = self.rx_rate_limiter.as_raw_fd(); let tx_rate_limiter_fd = self.tx_rate_limiter.as_raw_fd(); let tap_fd = self.tap.as_raw_fd(); let activate_fd = self.activate_evt.as_raw_fd(); // Looks better than C style if/else if/else. match source { _ if source == virtq_rx_ev_fd => self.process_rx_queue_event(), _ if source == tap_fd => self.process_tap_rx_event(), //tap设备来数据了 _ if source == virtq_tx_ev_fd => self.process_tx_queue_event(), _ if source == rx_rate_limiter_fd => self.process_rx_rate_limiter_event(), _ if source == tx_rate_limiter_fd => self.process_tx_rate_limiter_event(), _ if activate_fd == source => self.process_activate_event(ops), _ => { warn!(\"Net: Spurious event received: {:?}\", source); METRICS.net.event_fails.inc(); } } } else { warn!( \"Net: The device is not yet activated. Spurious event received: {:?}\", source ); } } fn init(&mut self, ops: &mut EventOps) { // This function can be called during different points in the device lifetime: // - shortly after device creation, // - on device activation (is-activated already true at this point), // - on device restore from snapshot. if self.is_activated() { self.register_runtime_events(ops); } else { self.register_activate_event(ops); } } } "},"notes/rust_firecracker_使用.html":{"url":"notes/rust_firecracker_使用.html","title":"使用","keywords":"","body":"编译 先clone代码: git clone https://github.com/firecracker-microvm/firecracker 编译firecracker firecracker是rust写的, 但编译不需要本地依赖rust环境, 而是在docker内完成的. 使用了docker imagepublic.ecr.aws/firecracker/fcuvm:v35, 大小3.25G 因为使用了x86_64-unknown-linux-musl做为target, 所以最后的可执行文件是静态链接的 默认debug版本:tools/devtool build生成:build/cargo_target/x86_64-unknown-linux-musl/debug/firecracker 38M, 静态链接, 带符号 指定release版本tools/devtool build --release生成:build/cargo_target/x86_64-unknown-linux-musl/release/firecracker 4.1M, 静态链接, 带符号 编译kernel tools/devtool build_kernel -c resources/guest_configs/microvm-kernel-x86_64-5.10.config -n 8生成:build/kernel/linux-5.10/vmlinux-5.10-x86_64.bin 42M, 带符号的linux elf, 模块全部编入kernel. 编译rootfs tools/devtool build_rootfs -s 300MB生成:build/rootfs/bionic.rootfs.ext4 300M 运行 配置文件方式运行 build/cargo_target/x86_64-unknown-linux-musl/release/firecracker --api-sock /tmp/firecracker.socket --config-file myvmconfig.json会打印kernel启动过程, 并自动以root登陆 myvmconfig.json内容如下: { \"boot-source\": { \"kernel_image_path\": \"build/kernel/linux-5.10/vmlinux-5.10-x86_64.bin\", \"boot_args\": \"console=ttyS0 reboot=k panic=1 pci=off\", \"initrd_path\": null }, \"drives\": [ { \"drive_id\": \"rootfs\", \"path_on_host\": \"build/rootfs/bionic.rootfs.ext4\", \"is_root_device\": true, \"partuuid\": null, \"is_read_only\": false, \"cache_type\": \"Unsafe\", \"io_engine\": \"Sync\", \"rate_limiter\": null } ], \"machine-config\": { \"vcpu_count\": 2, \"mem_size_mib\": 1024, \"smt\": false, \"track_dirty_pages\": false }, \"balloon\": null, \"network-interfaces\": [], \"vsock\": null, \"logger\": null, \"metrics\": null, \"mmds-config\": null } 跑的是ubuntu, 带systemd的 启动迅速 reboot会触发kernel退出, 但并不重启 没有网络接口 根文件系统挂在/dev/vda上 VM配置了1024M内存, 但运行时firecracker进程占用95M, 虚拟内存1032M. rest API方式运行 firecracker启动的时候要指定一个API socket, 每个VM一个. 使用这个socket, 可以用rest API方式来运行和管理VM. devctr镜像 devctr是开发中使用的镜像, 所有的操作都通过这个镜像完成. 基于ubuntu18 安装了常用的开发工具binutils-dev clang cmake gcc 等等 安装了rustcurl https://sh.rustup.rs -sSf | sh -s -- -y rustup target add x86_64-unknown-linux-musl rustup component add rustfmt rustup component add clippy-preview rustup install \"stable\" 使用了开源的init程序, 静态编译版本# Add the tini init binary. ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION_TAG}/tini-static-amd64 /sbin/tini RUN chmod +x /sbin/tini WORKDIR \"$FIRECRACKER_SRC_DIR\" ENTRYPOINT [\"/sbin/tini\", \"--\"] 顶层cargo cargo.toml [workspace] members = [\"src/firecracker\", \"src/jailer\", \"src/seccompiler\", \"src/rebase-snap\"] default-members = [\"src/firecracker\"] [profile.dev] panic = \"abort\" [profile.release] panic = \"abort\" lto = true [patch.crates-io] kvm-bindings = { git = \"https://github.com/firecracker-microvm/kvm-bindings\", tag = \"v0.5.0-1\", features = [\"fam-wrappers\"] } cargo的build系统会自动维护cargo.lock来描述版本信息. 下面的命令可以更新依赖的版本信息: $ cargo update # updates all dependencies $ cargo update -p regex # updates just “regex” firecracker/tools/devtool脚本 # By default, all devtool commands run the container transparently, removing # it after the command completes. Any persisting files will be stored under # build/. # If, for any reason, you want to access the container directly, please use # `devtool shell`. This will perform the initial setup (bind-mounting the # sources dir, setting privileges) and will then drop into a BASH shell inside # the container. # # Building: # Run `./devtool build`. # By default, the debug binaries are built and placed under build/debug/. # To build the release version, run `./devtool build --release` instead. # You can then find the binaries under build/release/. # # Testing: # Run `./devtool test`. # This will run the entire integration test battery. The testing system is # based on pytest (http://pytest.org). # # Opening a shell prompt inside the development container: # Run `./devtool shell`. # # Additional information: # Run `./devtool help`. run_devctr函数写的很好. docker -v的z参数表示可以共享, 参考https://docs.docker.com/storage/bind-mounts/#configure-the-selinux-label # Helper function to run the dev container. # Usage: run_devctr -- # Example: run_devctr --privileged -- bash -c \"echo 'hello world'\" run_devctr() { docker_args=() ctr_args=() docker_args_done=false while [[ $# -gt 0 ]]; do [[ \"$1\" = \"--\" ]] && { docker_args_done=true shift continue } [[ $docker_args_done = true ]] && ctr_args+=(\"$1\") || docker_args+=(\"$1\") shift done # If we're running in a terminal, pass the terminal to Docker and run # the container interactively [[ -t 0 ]] && docker_args+=(\"-i\") [[ -t 1 ]] && docker_args+=(\"-t\") # Try to pass these environments from host into container for network proxies proxies=(http_proxy HTTP_PROXY https_proxy HTTPS_PROXY no_proxy NO_PROXY) for i in \"${proxies[@]}\"; do if [[ ! -z ${!i} ]]; then docker_args+=(\"--env\") && docker_args+=(\"$i=${!i}\") fi done # Finally, run the dev container # Use 'z' on the --volume parameter for docker to automatically relabel the # content and allow sharing between containers. docker run \"${docker_args[@]}\" \\ --rm \\ --volume /dev:/dev \\ --volume \"$FC_ROOT_DIR:$CTR_FC_ROOT_DIR:z\" \\ --env OPT_LOCAL_IMAGES_PATH=\"$(dirname \"$CTR_MICROVM_IMAGES_DIR\")\" \\ --env PYTHONDONTWRITEBYTECODE=1 \\ \"$DEVCTR_IMAGE\" \"${ctr_args[@]}\" } cmd_build 默认debug版本, 默认libc是musl target是x86_64-unknown-linux-musl 先build seccompiler seccompiler是个单独的binary, 把json转成BPF程序保存到文件中. # Build seccompiler-bin. run_devctr \\ --user \"$(id -u):$(id -g)\" \\ --workdir \"$CTR_FC_ROOT_DIR\" \\ ${extra_args} \\ -- \\ cargo build -p seccompiler --bin seccompiler-bin \\ --target-dir \"$CTR_CARGO_SECCOMPILER_TARGET_DIR\" \\ \"${cargo_args[@]}\" ret=$? 注: -p seccompiler: 只build seccompiler 再build rebase-snap Tool that copies all the non-sparse sections from a diff file onto a base file # Build rebase-snap. run_devctr \\ --user \"$(id -u):$(id -g)\" \\ --workdir \"$CTR_FC_ROOT_DIR\" \\ ${extra_args} \\ -- \\ cargo build -p rebase-snap \\ --target-dir \"$CTR_CARGO_REBASE_SNAP_TARGET_DIR\" \\ \"${cargo_args[@]}\" ret=$? build firecracker # Build Firecracker. run_devctr \\ --user \"$(id -u):$(id -g)\" \\ --workdir \"$CTR_FC_ROOT_DIR\" \\ ${extra_args} \\ -- \\ cargo build \\ --target-dir \"$CTR_CARGO_TARGET_DIR\" \\ \"${cargo_args[@]}\" ret=$? build jailer # Build jailer only in case of musl for compatibility reasons. if [ \"$libc\" == \"musl\" ];then run_devctr \\ --user \"$(id -u):$(id -g)\" \\ --workdir \"$CTR_FC_ROOT_DIR\" \\ ${extra_args} \\ -- \\ cargo build -p jailer \\ --target-dir \"$CTR_CARGO_TARGET_DIR\" \\ \"${cargo_args[@]}\" fi build_kernel 比如:./tools/devtool build_kernel -c resources/guest_configs/microvm-kernel-arm64-4.14.config # arch不同, vmlinux的format也不同 arch=$(uname -m) if [ \"$arch\" = \"x86_64\" ]; then target=\"vmlinux\" cfg_pattern=\"x86\" format=\"elf\" elif [ \"$arch\" = \"aarch64\" ]; then target=\"Image\" cfg_pattern=\"arm64\" format=\"pe\" recipe_url=\"https://raw.githubusercontent.com/rust-vmm/vmm-reference/$recipe_commit/resources/kernel/make_kernel.sh\" # 从自己的github的另一个库rust-vmm/vmm-reference下载 make_kernel.sh run_devctr \\ --user \"$(id -u):$(id -g)\" \\ --workdir \"$kernel_dir_ctr\" \\ -- /bin/bash -c \"curl -LO \"$recipe_url\" && source make_kernel.sh && extract_kernel_srcs \"$KERNEL_VERSION\"\" cp \"$KERNEL_CFG\" \"$kernel_dir_host/linux-$KERNEL_VERSION/.config\" KERNEL_BINARY_NAME=\"vmlinux-$KERNEL_VERSION-$arch.bin\" #真正的make kernel run_devctr \\ --user \"$(id -u):$(id -g)\" \\ --workdir \"$kernel_dir_ctr\" \\ -- /bin/bash -c \"source make_kernel.sh && make_kernel \"$kernel_dir_ctr/linux-$KERNEL_VERSION\" $format $target \"$nprocs\" \"$KERNEL_BINARY_NAME\"\" build_rootfs default rootfs size是300M, 用ubuntu18.04, 目标是$flavour.rootfs.ext4 先编译几个c文件, 用作测试? run_devctr \\ --workdir \"$CTR_FC_ROOT_DIR\" \\ -- /bin/bash -c \"gcc -o $rootfs_dir_ctr/init $resources_dir_ctr/init.c && \\ gcc -o $rootfs_dir_ctr/fillmem $resources_dir_ctr/fillmem.c && \\ gcc -o $rootfs_dir_ctr/readmem $resources_dir_ctr/readmem.c\" firecracker/resources/tests/init.c 在调用/sbin/openrc-init之前, 向/dev/mem的特定地址(比如aarch64的0x40000000 1G)写入数字123 用于通知VMM kernel已经启动完毕 // Base address values are defined in arch/src/lib.rs as arch::MMIO_MEM_START. // Values are computed in arch/src//mod.rs from the architecture layouts. // Position on the bus is defined by MMIO_LEN increments, where MMIO_LEN is // defined as 0x1000 in vmm/src/device_manager/mmio.rs. #ifdef __x86_64__ #define MAGIC_MMIO_SIGNAL_GUEST_BOOT_COMPLETE 0xd0000000 #endif #ifdef __aarch64__ #define MAGIC_MMIO_SIGNAL_GUEST_BOOT_COMPLETE 0x40000000 #endif #define MAGIC_VALUE_SIGNAL_GUEST_BOOT_COMPLETE 123 int main () { int fd = open(\"/dev/mem\", (O_RDWR | O_SYNC | O_CLOEXEC)); int mapped_size = getpagesize(); char *map_base = mmap(NULL, mapped_size, PROT_WRITE, MAP_SHARED, fd, MAGIC_MMIO_SIGNAL_GUEST_BOOT_COMPLETE); *map_base = MAGIC_VALUE_SIGNAL_GUEST_BOOT_COMPLETE; msync(map_base, mapped_size, MS_ASYNC); const char *init = \"/sbin/openrc-init\"; char *const argv[] = { \"/sbin/init\", NULL }; char *const envp[] = { }; execve(init, argv, envp); } firecracker/resources/tests/fillmem.c Usage: ./fillmem mb_count先mmap再memset firecracker/resources/tests/readmem.c Usage: ./readmem mb_count value 做镜像 用ubuntu18.04 container的 truncate -s \"$SIZE\" \"$img_file\" mkfs.ext4 -F \"$img_file\" docker run -v \"$FC_ROOT_DIR:/firecracker\" ubuntu:18.04 bash -s 注: 使用'EOF'格式的heredoc, 其内部的变量不会展开 "},"notes/rust_cloud-hypervisor_代码.html":{"url":"notes/rust_cloud-hypervisor_代码.html","title":"代码","keywords":"","body":"cloud hypervisor是一种基于rust-vmm的VMM实现. 它和其他VMM的对比在这里 code walk in single picture 编译 git clone https://github.com/cloud-hypervisor/cloud-hypervisor.git cd cloud-hypervisor/ # docker方式编译 -- 推荐 # 如果需要proxy, 在cmd_build函数docker run命令行加--env http_proxy=\"http://10.158.100.6:8080/\" scripts/dev_cli.sh build --release --libc musl # 产生的bin: build/cargo_target/x86_64-unknown-linux-musl/release/cloud-hypervisor # 本地方式编译, 完全静态链接版本要使用x86_64-unknown-linux-musl rustup target add x86_64-unknown-linux-musl # 完全静态版本一定要加--all, 还要安装musl-tools sudo apt install musl-tools cargo build --release --target=x86_64-unknown-linux-musl --all # 产生的bin: target/x86_64-unknown-linux-musl/release/cloud-hypervisor build时可选的feature列表 #[cfg(target_arch = \"x86_64\")] #[cfg(target_arch = \"aarch64\")] #[cfg(feature = \"guest_debug\")] #[cfg(feature = \"fwdebug\")] #[cfg(feature = \"tdx\")] #[cfg(feature = \"kvm\")] #[cfg(all(feature = \"mshv\", target_arch = \"x86_64\"))] #[cfg(feature = \"gdb\")] REST API和CLI cloud hypervisor以cli方式启动, 并启动http服务, 提供REST接口. 如果cli传入vmm的参数, 则http服务会根据后面的REST api来创建VM 先用cli创建一个empty的实例, 默认1vCPU, 512M内存. $ ./target/debug/cloud-hypervisor --api-socket /tmp/cloud-hypervisor.sock Cloud Hypervisor Guest API server: /tmp/cloud-hypervisor.sock vCPUs: 1 Memory: 512 MB Kernel: None Kernel cmdline: Disk(s): None 随后用REST API来创建vm curl --unix-socket /tmp/cloud-hypervisor.sock -i \\ -X PUT 'http://localhost/api/v1/vm.create' \\ -H 'Accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{ \"cpus\":{\"boot_vcpus\": 4, \"max_vcpus\": 4}, \"kernel\":{\"path\":\"/opt/clh/kernel/vmlinux-virtio-fs-virtio-iommu\"}, \"cmdline\":{\"args\":\"console=ttyS0 console=hvc0 root=/dev/vda1 rw\"}, \"disks\":[{\"path\":\"/opt/clh/images/focal-server-cloudimg-amd64.raw\"}], \"rng\":{\"src\":\"/dev/urandom\"}, \"net\":[{\"ip\":\"192.168.10.10\", \"mask\":\"255.255.255.0\", \"mac\":\"12:34:56:78:90:01\"}] }' 所有的json选项可在vmm/src/config.rs的struct VmConfig里面查看. struct VmConfig用了rust的序列化框架serde, 把结构体直接映射成 然后boot这个实例 curl --unix-socket /tmp/cloud-hypervisor.sock -i -X PUT 'http://localhost/api/v1/vm.boot' 其他命令 # dump vm的config curl --unix-socket /tmp/cloud-hypervisor.sock -i \\ -X GET 'http://localhost/api/v1/vm.info' \\ -H 'Accept: application/json' # reboot vm curl --unix-socket /tmp/cloud-hypervisor.sock -i -X PUT 'http://localhost/api/v1/vm.reboot' # shut down curl --unix-socket /tmp/cloud-hypervisor.sock -i -X PUT 'http://localhost/api/v1/vm.shutdown' cli和REST的关系 http路由 HTTP_ROUTES是个全局变量 lazy_static! { /// HTTP_ROUTES contain all the cloud-hypervisor HTTP routes. pub static ref HTTP_ROUTES: HttpRoutes = { let mut r = HttpRoutes { routes: HashMap::new(), }; r.routes.insert(endpoint!(\"/vm.add-device\"), Box::new(VmActionHandler::new(VmAction::AddDevice(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-user-device\"), Box::new(VmActionHandler::new(VmAction::AddUserDevice(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-disk\"), Box::new(VmActionHandler::new(VmAction::AddDisk(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-fs\"), Box::new(VmActionHandler::new(VmAction::AddFs(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-net\"), Box::new(VmActionHandler::new(VmAction::AddNet(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-pmem\"), Box::new(VmActionHandler::new(VmAction::AddPmem(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-vdpa\"), Box::new(VmActionHandler::new(VmAction::AddVdpa(Arc::default())))); r.routes.insert(endpoint!(\"/vm.add-vsock\"), Box::new(VmActionHandler::new(VmAction::AddVsock(Arc::default())))); r.routes.insert(endpoint!(\"/vm.boot\"), Box::new(VmActionHandler::new(VmAction::Boot))); r.routes.insert(endpoint!(\"/vm.counters\"), Box::new(VmActionHandler::new(VmAction::Counters))); r.routes.insert(endpoint!(\"/vm.create\"), Box::new(VmCreate {})); r.routes.insert(endpoint!(\"/vm.delete\"), Box::new(VmActionHandler::new(VmAction::Delete))); r.routes.insert(endpoint!(\"/vm.info\"), Box::new(VmInfo {})); r.routes.insert(endpoint!(\"/vm.pause\"), Box::new(VmActionHandler::new(VmAction::Pause))); r.routes.insert(endpoint!(\"/vm.power-button\"), Box::new(VmActionHandler::new(VmAction::PowerButton))); r.routes.insert(endpoint!(\"/vm.reboot\"), Box::new(VmActionHandler::new(VmAction::Reboot))); r.routes.insert(endpoint!(\"/vm.receive-migration\"), Box::new(VmActionHandler::new(VmAction::ReceiveMigration(Arc::default())))); r.routes.insert(endpoint!(\"/vm.remove-device\"), Box::new(VmActionHandler::new(VmAction::RemoveDevice(Arc::default())))); r.routes.insert(endpoint!(\"/vm.resize\"), Box::new(VmActionHandler::new(VmAction::Resize(Arc::default())))); r.routes.insert(endpoint!(\"/vm.resize-zone\"), Box::new(VmActionHandler::new(VmAction::ResizeZone(Arc::default())))); r.routes.insert(endpoint!(\"/vm.restore\"), Box::new(VmActionHandler::new(VmAction::Restore(Arc::default())))); r.routes.insert(endpoint!(\"/vm.resume\"), Box::new(VmActionHandler::new(VmAction::Resume))); r.routes.insert(endpoint!(\"/vm.send-migration\"), Box::new(VmActionHandler::new(VmAction::SendMigration(Arc::default())))); r.routes.insert(endpoint!(\"/vm.shutdown\"), Box::new(VmActionHandler::new(VmAction::Shutdown))); r.routes.insert(endpoint!(\"/vm.snapshot\"), Box::new(VmActionHandler::new(VmAction::Snapshot(Arc::default())))); r.routes.insert(endpoint!(\"/vmm.ping\"), Box::new(VmmPing {})); r.routes.insert(endpoint!(\"/vmm.shutdown\"), Box::new(VmmShutdown {})); r }; } 内部channel rust标准库的channel是mpsc, 创建channel: // 编译器会从下文推断出这个channel传输的是ApiRequest let (api_request_sender, api_request_receiver) = std::sync::mpsc::channel(); 这个ApiRequest是个enum, 所有的http请求都定义在这; 注意这里回复还是一个Sender, 里面是ApiResponse. 这个就是rust版本的channel in channel: 发出http请求的一方, 构造请求和一个专有的Sender句柄给服务方, 并等待在对应的Receiver; 服务方把ApiResponse响应写回到这个Sender里面; #[allow(clippy::large_enum_variant)] #[derive(Debug)] pub enum ApiRequest { /// Create the virtual machine. This request payload is a VM configuration /// (VmConfig). /// If the VMM API server could not create the VM, it will send a VmCreate /// error back. VmCreate(Arc>, Sender), /// Boot the previously created virtual machine. /// If the VM was not previously created, the VMM API server will send a /// VmBoot error back. VmBoot(Sender), /// Delete the previously created virtual machine. /// If the VM was not previously created, the VMM API server will send a /// VmDelete error back. /// If the VM is booted, we shut it down first. VmDelete(Sender), /// Request the VM information. VmInfo(Sender), /// Request the VMM API server status VmmPing(Sender), /// Pause a VM. VmPause(Sender), /// Resume a VM. VmResume(Sender), /// Get counters for a VM. VmCounters(Sender), /// Shut the previously booted virtual machine down. /// If the VM was not previously booted or created, the VMM API server /// will send a VmShutdown error back. VmShutdown(Sender), /// Reboot the previously booted virtual machine. /// If the VM was not previously booted or created, the VMM API server /// will send a VmReboot error back. VmReboot(Sender), /// Shut the VMM down. /// This will shutdown and delete the current VM, if any, and then exit the /// VMM process. VmmShutdown(Sender), /// Resize the VM. VmResize(Arc, Sender), /// Resize the memory zone. VmResizeZone(Arc, Sender), /// Add a device to the VM. VmAddDevice(Arc, Sender), /// Add a user device to the VM. VmAddUserDevice(Arc, Sender), /// Remove a device from the VM. VmRemoveDevice(Arc, Sender), /// Add a disk to the VM. VmAddDisk(Arc, Sender), /// Add a fs to the VM. VmAddFs(Arc, Sender), /// Add a pmem device to the VM. VmAddPmem(Arc, Sender), /// Add a network device to the VM. VmAddNet(Arc, Sender), /// Add a vDPA device to the VM. VmAddVdpa(Arc, Sender), /// Add a vsock device to the VM. VmAddVsock(Arc, Sender), /// Take a VM snapshot VmSnapshot(Arc, Sender), /// Restore from a VM snapshot VmRestore(Arc, Sender), /// Incoming migration VmReceiveMigration(Arc, Sender), /// Outgoing migration VmSendMigration(Arc, Sender), // Trigger power button VmPowerButton(Sender), } 代码梳理 main main函数在cloud-hypervisor/src/main.rs fn main() { // Ensure all created files (.e.g sockets) are only accessible by this user let _ = unsafe { libc::umask(0o077) }; //默认vCPU=1, 物理地址46bit; mem=512M; 使用/dev/urandom let (default_vcpus, default_memory, default_rng) = prepare_default_values(); //使用了流行的cli库clap, 瀑布式的定义args //get_matches就是parse()命令行 let cmd_arguments = create_app(&default_vcpus, &default_memory, &default_rng).get_matches(); let exit_code = match start_vmm(cmd_arguments); //支持kvm或mshv, 编译时选择 let hypervisor = hypervisor::new() let kvm_obj = Kvm::new() Ok(KvmHypervisor { kvm: kvm_obj }) let vmm_thread = vmm::start_vmm_thread( env!(\"CARGO_PKG_VERSION\").to_string(), &api_socket_path, api_socket_fd, api_evt.try_clone().unwrap(), http_sender, api_request_receiver, #[cfg(feature = \"gdb\")] gdb_socket_path, #[cfg(feature = \"gdb\")] debug_evt.try_clone().unwrap(), #[cfg(feature = \"gdb\")] vm_debug_evt.try_clone().unwrap(), &seccomp_action, hypervisor, //这个是上面的kvm实例化的hypervisor ) let thread = { //新建thread做主event处理循环 thread::Builder::new() .name(\"vmm\".to_string()) .spawn(move || { //新建vmm, 主要是注册event, 并没有开始真正干活 let mut vmm = Vmm::new( vmm_version.to_string(), api_event, vmm_seccomp_action, hypervisor, exit_evt, )?; //event循环 vmm.control_loop(Arc::new(api_receiver)) let epoll_fd = self.epoll.as_raw_fd(); //在loop里epoll wait, 并根据注册epoll add的token来分发 for event in events.iter().take(num_events) { let dispatch_event: EpollDispatch = event.data.into(); match dispatch_event { EpollDispatch::Unknown => {} EpollDispatch::Exit => {} EpollDispatch::Reset => {} EpollDispatch::ActivateVirtioDevices => {} EpollDispatch::Api => { //consume 触发内部channel的eventfd self.api_evt.read().map_err(Error::EventFdRead)?; //处理内部channel过来的请求并返回结果 let api_request = api_receiver.recv() match api_request { ApiRequest::VmCreate(config, sender) => {} ApiRequest::VmBoot(sender) => {} ... } } } } } }; // 起http线程, 用的是micro_http的库 api::start_http_path_thread() let server = HttpServer::new_from_fd() start_http_thread(server) hread::Builder::new() //新线程 loop { match server.requests() { Ok(request_vec) => { for server_request in request_vec { server.respond(server_request.process( |request| { handle_http_request(request, &api_notifier, &api_sender) } )) } } } } //带api前缀的都是发http请求到vmm.control_loop的. vmm::api::vm_create() vmm::api::vm_boot() //或者vmm::api::vm_restore() vmm_thread.join() std::process::exit(exit_code); } hypervisor的抽象 能在最顶层抽象一个hypervisor, 同时支持多种虚拟化技术. 用了抽象函数返回另一个抽象的模式, 即create_vm返回一个Vm trait object /// /// Trait to represent a Hypervisor /// /// This crate provides a hypervisor-agnostic interfaces /// pub trait Hypervisor: Send + Sync { /// /// Create a Vm using the underlying hypervisor /// Return a hypervisor-agnostic Vm trait object /// fn create_vm(&self) -> Result>; /// /// Create a Vm of a specific type using the underlying hypervisor /// Return a hypervisor-agnostic Vm trait object /// fn create_vm_with_type(&self, _vm_type: u64) -> Result> { unreachable!() } #[cfg(target_arch = \"x86_64\")] /// /// Get the supported CpuID /// fn get_cpuid(&self) -> Result; /// /// Check particular extensions if any /// fn check_required_extensions(&self) -> Result { Ok(()) } #[cfg(target_arch = \"x86_64\")] /// /// Retrieve the list of MSRs supported by the hypervisor. /// fn get_msr_list(&self) -> Result; #[cfg(target_arch = \"aarch64\")] /// /// Retrieve AArch64 host maximum IPA size supported by KVM. /// fn get_host_ipa_limit(&self) -> i32; /// /// Retrieve TDX capabilities /// #[cfg(feature = \"tdx\")] fn tdx_capabilities(&self) -> Result; } vm抽象基本上是基于kvm api的 /// /// Trait to represent a Vm /// /// This crate provides a hypervisor-agnostic interfaces for Vm /// pub trait Vm: Send + Sync { #[cfg(target_arch = \"x86_64\")] /// Sets the address of the one-page region in the VM's address space. fn set_identity_map_address(&self, address: u64) -> Result; #[cfg(target_arch = \"x86_64\")] /// Sets the address of the three-page region in the VM's address space. fn set_tss_address(&self, offset: usize) -> Result; /// Creates an in-kernel interrupt controller. fn create_irq_chip(&self) -> Result; /// Registers an event that will, when signaled, trigger the `gsi` IRQ. fn register_irqfd(&self, fd: &EventFd, gsi: u32) -> Result; /// Unregister an event that will, when signaled, trigger the `gsi` IRQ. fn unregister_irqfd(&self, fd: &EventFd, gsi: u32) -> Result; /// Creates a new KVM vCPU file descriptor and maps the memory corresponding fn create_vcpu(&self, id: u8, vm_ops: Option>) -> Result>; /// Registers an event to be signaled whenever a certain address is written to. fn register_ioevent( &self, fd: &EventFd, addr: &IoEventAddress, datamatch: Option, ) -> Result; /// Unregister an event from a certain address it has been previously registered to. fn unregister_ioevent(&self, fd: &EventFd, addr: &IoEventAddress) -> Result; // Construct a routing entry fn make_routing_entry(&self, gsi: u32, config: &InterruptSourceConfig) -> IrqRoutingEntry; /// Sets the GSI routing table entries, overwriting any previously set fn set_gsi_routing(&self, entries: &[IrqRoutingEntry]) -> Result; /// Creates a memory region structure that can be used with {create/remove}_user_memory_region fn make_user_memory_region( &self, slot: u32, guest_phys_addr: u64, memory_size: u64, userspace_addr: u64, readonly: bool, log_dirty_pages: bool, ) -> MemoryRegion; /// Creates a guest physical memory slot. fn create_user_memory_region(&self, user_memory_region: MemoryRegion) -> Result; /// Removes a guest physical memory slot. fn remove_user_memory_region(&self, user_memory_region: MemoryRegion) -> Result; /// Creates an emulated device in the kernel. fn create_device(&self, device: &mut CreateDevice) -> Result>; /// Returns the preferred CPU target type which can be emulated by KVM on underlying host. #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))] fn get_preferred_target(&self, kvi: &mut VcpuInit) -> Result; /// Enable split Irq capability #[cfg(target_arch = \"x86_64\")] fn enable_split_irq(&self) -> Result; #[cfg(target_arch = \"x86_64\")] fn enable_sgx_attribute(&self, file: File) -> Result; /// Retrieve guest clock. #[cfg(all(feature = \"kvm\", target_arch = \"x86_64\"))] fn get_clock(&self) -> Result; /// Set guest clock. #[cfg(all(feature = \"kvm\", target_arch = \"x86_64\"))] fn set_clock(&self, data: &ClockData) -> Result; #[cfg(feature = \"kvm\")] /// Checks if a particular `Cap` is available. fn check_extension(&self, c: Cap) -> bool; /// Create a device that is used for passthrough fn create_passthrough_device(&self) -> Result>; /// Get the Vm state. Return VM specific data fn state(&self) -> Result; /// Set the VM state fn set_state(&self, state: VmState) -> Result; /// Start logging dirty pages fn start_dirty_log(&self) -> Result; /// Stop logging dirty pages fn stop_dirty_log(&self) -> Result; /// Get dirty pages bitmap fn get_dirty_log(&self, slot: u32, base_gpa: u64, memory_size: u64) -> Result>; #[cfg(feature = \"tdx\")] /// Initalize TDX on this VM fn tdx_init(&self, cpuid: &CpuId, max_vcpus: u32) -> Result; #[cfg(feature = \"tdx\")] /// Finalize the configuration of TDX on this VM fn tdx_finalize(&self) -> Result; #[cfg(feature = \"tdx\")] /// Initalize a TDX memory region for this VM fn tdx_init_memory_region( &self, host_address: u64, guest_address: u64, size: u64, measure: bool, ) -> Result; } vmops vm的op主要针对gpa, guest physical address pub trait VmOps: Send + Sync { // 对guest dram来说的 fn guest_mem_write(&self, gpa: u64, buf: &[u8]) -> Result; fn guest_mem_read(&self, gpa: u64, buf: &mut [u8]) -> Result; // 对guest mmio来说的 fn mmio_read(&self, gpa: u64, data: &mut [u8]) -> Result; fn mmio_write(&self, gpa: u64, data: &[u8]) -> Result; // 对guest pio来说的 #[cfg(target_arch = \"x86_64\")] fn pio_read(&self, port: u64, data: &mut [u8]) -> Result; #[cfg(target_arch = \"x86_64\")] fn pio_write(&self, port: u64, data: &[u8]) -> Result; } cli create vm代码流程 命令行传入的kernel选项, 会被parse成vm config, 再创建vm let vm_params = config::VmParams::from_arg_matches(&cmd_arguments); let vm_config = config::VmConfig::parse(vm_params) // Create and boot the VM based off the VM config we just built. let sender = api_request_sender.clone(); vmm::api::vm_create( api_evt.try_clone().unwrap(), api_request_sender, Arc::new(Mutex::new(vm_config)), ) 这个vm_create就是给内部http服务发请求: pub fn vm_create( api_evt: EventFd, api_sender: Sender, config: Arc>, ) -> ApiResult { let (response_sender, response_receiver) = channel(); // Send the VM creation request. api_sender .send(ApiRequest::VmCreate(config, response_sender)) .map_err(ApiError::RequestSend)?; api_evt.write(1).map_err(ApiError::EventFdWrite)?; response_receiver.recv().map_err(ApiError::ResponseRecv)??; Ok(()) } REST API流程实例 用户发REST API A user or operator sends an HTTP request to the Cloud Hypervisor REST API in order to creates a virtual machine: #!/bin/bash curl --unix-socket /tmp/cloud-hypervisor.sock -i \\ -X PUT 'http://localhost/api/v1/vm.create' \\ -H 'Accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{ \"cpus\":{\"boot_vcpus\": 4, \"max_vcpus\": 4}, \"kernel\":{\"path\":\"/opt/clh/kernel/vmlinux-virtio-fs-virtio-iommu\"}, \"cmdline\":{\"args\":\"console=ttyS0 console=hvc0 root=/dev/vda1 rw\"}, \"disks\":[{\"path\":\"/opt/clh/images/focal-server-cloudimg-amd64.raw\"}], \"rng\":{\"src\":\"/dev/urandom\"}, \"net\":[{\"ip\":\"192.168.10.10\", \"mask\":\"255.255.255.0\", \"mac\":\"12:34:56:78:90:01\"}] }' 这个VMM对应的http server响应请求 The Cloud Hypervisor HTTP thread processes the request and de-serializes the HTTP request JSON body into an internal VmConfig structure. micro_http响应这个请求, 调用提前注册好的EndpointHandler: // /api/v1/vm.create handler pub struct VmCreate {} impl EndpointHandler for VmCreate { fn handle_request( &self, req: &Request, api_notifier: EventFd, api_sender: Sender, ) -> Response { match req.method() { Method::Put => { match &req.body { Some(body) => { // Deserialize into a VmConfig let vm_config: VmConfig = match serde_json::from_slice(body.raw()) .map_err(HttpError::SerdeJsonDeserialize) { Ok(config) => config, Err(e) => return error_response(e, StatusCode::BadRequest), }; // Call vm_create() match vm_create(api_notifier, api_sender, Arc::new(Mutex::new(vm_config))) .map_err(HttpError::ApiError) { Ok(_) => Response::new(Version::Http11, StatusCode::NoContent), Err(e) => error_response(e, StatusCode::InternalServerError), } } None => Response::new(Version::Http11, StatusCode::BadRequest), } } _ => error_response(HttpError::BadRequest, StatusCode::BadRequest), } } } 从http的raw data里(json格式)解析VmConfig let vm_config: VmConfig = match serde_json::from_slice(body.raw()) vm_create使用内部channel向VMM的API发送请求 vm_create使用内部channel向VMM的API发送请求, 请求的内容是VmConfig, 并使用channel in channel来等待回复 VmCreate(Arc>, Sender) // 构造内部channel let (response_sender, response_receiver) = std::sync::mpsc::channel(); // Send the VM creation request. api_sender .send(ApiRequest::VmCreate(config, response_sender)) .map_err(ApiError::RequestSend)?; api_evt.write(1).map_err(ApiError::EventFdWrite)?; response_receiver.recv().map_err(ApiError::ResponseRecv)??; 内部channel处理请求 // Read from the API receiver channel let api_request = api_receiver.recv().map_err(Error::ApiRequestRecv)?; 处理这次的VmCreate The Cloud Hypervisor control loop matches the received internal API against the VmCreate payload, and extracts both the VmConfig structure and the Sender from the command payload. It stores the VmConfig structure and replies back to the sender ((The HTTP thread): match api_request { ApiRequest::VmCreate(config, sender) => { // We only store the passed VM config. // The VM will be created when being asked to boot it. let response = if self.vm_config.is_none() { self.vm_config = Some(config); Ok(ApiResponsePayload::Empty) } else { Err(ApiError::VmAlreadyCreated) }; sender.send(response).map_err(Error::ApiResponseSend)?; } 这里create vm并没有真正的create, 而只是保存vmconfig, 待到boot的时候再创建 返回response 可以看到, 用户的curl请求等到动作执行完毕后, 就会收到response impl Vmm 代码在cloud-hypervisor/vmm/src/lib.rsvm_create和vm_boot等真正执行在Vmm的方法里: impl Vmm { new() vm_create() vm_boot() } x86_64和aarch64的mem layout 和firecracker相比, cloudhypervisor重点在pci mmio. vm_boot 前面说过, vm_create只是保存vmconfig, 而vm_boot是真正创建并运行vm的地方 let vm = Vm::new( Arc::clone(vm_config), exit_evt, reset_evt, &self.seccomp_action, self.hypervisor.clone(), activate_evt, None, None, None, )?; //vm代码在cloud-hypervisor/vmm/src/vm.rs let vm = hypervisor.create_vm().unwrap(); //kvm ioctl KVM_CREATE_VM //return Arc::new(KvmVm {fd: vm_fd, state: VmState {}, ...} //下面3个事x86独有 vm.set_identity_map_address(KVM_IDENTITY_MAP_START.0) vm.set_tss_address(KVM_TSS_START.0 as usize) vm.enable_split_irq() //KVM_ENABLE_CAP let memory_manager = MemoryManager::new(vm.clone(), ...) //建立内存region Vec, 这个Vec的元素是(start, size, type) //比如一般内存分2G, [(0,2G,ram), (3G, 640M, SubRegion), (3G+640M, 大概200M, Reserved)] let arch_mem_regions = arch::arch_memory_regions(ram_size); //很复杂 ... let allocator = SystemAllocator::new( io_base:0 io_size: 64K platform_mmio_base: max_mem - 1M platform_mmio_size: 1M mmio_hole_base: 0xc000_0000 mmio_hole_size: 640M X86_64_IRQ_BASE: 5 irq_num: 24-5 ) //acpi在地址空间最后1M的platform mmio区域 acpi_address = allocator.lock().unwrap().allocate_platform_mmio_addresses(MEMORY_MANAGER_ACPI_SIZE) //从0开始到start_of_device_area的区域是ram let ram_allocator = AddressAllocator::new(GuestAddress(0), start_of_device_area.0) let mut memory_manager = MemoryManager { boot_guest_memory, guest_memory, next_memory_slot, start_of_device_area, end_of_device_area, end_of_ram_area, vm, hotplug_slots, selected_slot, mergeable: config.mergeable, allocator, hotplug_method: config.hotplug_method, boot_ram, current_ram, next_hotplug_slot, shared: config.shared, hugepages: config.hugepages, hugepage_size: config.hugepage_size, prefault: config.prefault, user_provided_zones, snapshot_memory_ranges: MemoryRangeTable::default(), memory_zones, guest_ram_mappings: Vec::new(), acpi_address, log_dirty: dynamic, // Cannot log dirty pages on a TD arch_mem_regions, ram_allocator, dynamic, }; memory_manager.allocate_address_space()?; for (zone_id, regions) in list { for (region, virtio_mem) in regions { //ioctl KVM_SET_USER_MEMORY_REGION //记录user memory region和slot的关系到Vec self.guest_ram_mappings.push(GuestRamMapping { gpa: region.start_addr().raw_value(), size: region.len(), slot, zone_id: zone_id.clone(), virtio_mem, file_offset, }); } } for 每个非ram的region self.ram_allocator .allocate(Some(region.start_addr()), region.len(), None) //内部使用BtreeMap来管理内存ranges, 把每个range insert到BtreeMap //应该都是针对guest 物理地址 self.ranges.insert(new_addr, size); let new_vm = Vm::new_from_memory_manager(memory_manager, vm, ...) //1. 起一个后台线程load kernel //支持load ELF 或 firmware, firmware load到4G地址 Self::load_kernel_async(&kernel, &memory_manager, &config)? linux_loader::loader::elf::Elf::load() linux_loader::loader::load_cmdline() //到CMDLINE_START地址 //或者强制load firmware到4G-size地址, 并手动添加映射 //2. create numa node //主要是从vm config里面提取config.memory_zones和config.distances信息填充到BTreeMap let numa_nodes = Self::create_numa_nodes() //3. 创建device manager, 见下面的详解 //cloud-hypervisor/vmm/src/device_manager.rs let device_manager = DeviceManager::new( vm.clone(), config.clone(), memory_manager.clone(), &exit_evt, &reset_evt, seccomp_action.clone(), numa_nodes.clone(), &activate_evt, force_iommu, restoring, boot_id_list, timestamp, ) /* 1. 新建device tree: HashMap 2. num_pci_segments默认为1, 可以配 3. 确定device区域(其实就是PCI设备区域), 见上面layout图 4. 新建address_manager { allocator: memory_manager.lock().unwrap().allocator(), io_bus: Arc::new(Bus::new()), mmio_bus: Arc::new(Bus::new()), vm: vm.clone(), device_tree: Arc::clone(&device_tree), pci_mmio_allocators, } 5. 新建msi_interrupt_manager, IOAPIC需要它, legacy_interrupt_manager需要IOAPIC gsi_msi_routes是个HashMap, 所有pci的device都共享这个gsi RoutingEntry对应kvm_irq_routing_entry 6. 分配acpi_address 7. 为pci预留legacy的中断slot: pci_irq_slots = [0; 32]; 8. 新建默认的pci_segment, id为0, 一个pci segment包括一个pci root桥, 一个PCI bus 9. 构建pci_segments Vec, 目前看包括id 0和id1的pci_segment 10. 用上面的材料构建device_manager结构体 11. 把device_manager insert到address_manager 12. 返回device_manager */ let memory = memory_manager.lock().unwrap().guest_memory(); //只有x86有io bus let io_bus = Arc::clone(device_manager.lock().unwrap().io_bus()); let mmio_bus = Arc::clone(device_manager.lock().unwrap().mmio_bus()); //只有x86有pci io let pci_config_io = device_manager.lock().unwrap().pci_config_io() as Arc>; //4. vm_ops let vm_ops: Arc = Arc::new(VmOpsHandler { memory, #[cfg(target_arch = \"x86_64\")] io_bus, mmio_bus, #[cfg(target_arch = \"x86_64\")] pci_config_io, }); //5. 创建cpu_manager 通过上面的device_manager memory_manager vm_ops来\"操作\"VM cpu::CpuManager::new() //6. 从文件准备initramfs //7. 构建vm结构体并返回 Ok(Vm { #[cfg(any(target_arch = \"aarch64\", feature = \"tdx\"))] kernel, initramfs, device_manager, config, on_tty, threads: Vec::with_capacity(1), signals: None, state: RwLock::new(VmState::Created), cpu_manager, memory_manager, vm, #[cfg(all(feature = \"kvm\", target_arch = \"x86_64\"))] saved_clock: None, numa_nodes, seccomp_action: seccomp_action.clone(), exit_evt, #[cfg(all(feature = \"kvm\", target_arch = \"x86_64\"))] hypervisor, stop_on_boot, #[cfg(target_arch = \"x86_64\")] load_kernel_handle, }) //根据vm config创建设备, 主要是pci的virtio设备, vfio设备等 new_vm.device_manager.create_devices(serial_pty, console_pty, console_resize_pipe) /* 1. 创建interrupt_controller 对x86来说是IOAPIC, 它的上游是self.msi_interrupt_manager 并把这个中断控制器添加到address_manager bus_devices 和device_tree 对aarch64来说是GIC, gic::Gic::new(), 上游也是self.msi_interrupt_manager 2. 创建legacy的interrupt_controller, 基于上面的interrupt_controller 3. add_legacy_devices() 4. add_acpi_devices() 5. add_console_device() 6. make_virtio_devices() let mut virtio_devices: Vec = Vec::new(); make_virtio_block_devices() make_virtio_net_devices() make_virtio_rng_devices() make_virtio_fs_devices() make_virtio_pmem_devices() make_virtio_vsock_devices() make_virtio_mem_devices() make_virtio_balloon_devices() make_virtio_watchdog_devices() make_vdpa_devices() 7. add_pci_devices(上面的virtio设备) 创建iommu_device: virtio_devices::Iommu::new() //对每个virtio设备 for handle in virtio_devices { add_virtio_pci_device() // 默认add到pci segment 0, 没有iommu, 没有dma 1. id为\"xxx_virtio-pci\" 2. 给这个pci device分配pci资源, bdf号等 (pci_segment_id, pci_device_bdf, resources) = self.pci_resources() 3. msi中断个数为queue个数+1 4. 创建virtio_pci_device //Constructs a new PCI transport for the given virtio device. virtio_pci_device = VirtioPciDevice::new( id, memory, virtio_device, msix_num, access_platform, &self.msi_interrupt_manager, pci_device_bdf.into(), self.activate_evt, use_64bit_bar, //除了virtio block都是64位. dma_handler ) 每个queue都配一个eventfd 创建queues, queue有两个泛型参数 根据virtio规范, pci_device_id是0x1040+device_type. 创建interrupt group, 即把下面的每个irq都绑定一个eventfd到irq 配置msix_config 配置class, 比如PciClassCode::NetworkController等 组成configuration space需要的信息: let configuration = PciConfiguration::new( VIRTIO_PCI_VENDOR_ID, pci_device_id, 0x1, // For modern virtio-PCI devices class, subclass, None, PciHeaderType::Device, VIRTIO_PCI_VENDOR_ID, pci_device_id, msix_config_clone, ); 组成virtio pci device let mut virtio_pci_device = VirtioPciDevice { id, configuration, common_config: VirtioPciCommonConfig { access_platform, driver_status: 0, config_generation: 0, device_feature_select: 0, driver_feature_select: 0, queue_select: 0, msix_config: Arc::new(AtomicU16::new(VIRTQ_MSI_NO_VECTOR)), msix_queues: Arc::new(Mutex::new(vec![VIRTQ_MSI_NO_VECTOR; num_queues])), }, msix_config, msix_num, device, device_activated: Arc::new(AtomicBool::new(false)), interrupt_status: Arc::new(AtomicUsize::new(0)), virtio_interrupt: None, queues, queue_evts, memory: Some(memory), settings_bar: 0, use_64bit_bar, interrupt_source_group, cap_pci_cfg_info: VirtioPciCfgCapInfo::default(), bar_regions: vec![], activate_evt, activate_barrier: Arc::new(Barrier::new(2)), dma_handler, }; //设置msix中断控制器 virtio_pci_device.virtio_interrupt = VirtioInterruptMsix::new() return 这个virtio_pci_device 5. add到pci, 返回bar地址信息 new_resources = self.add_pci_device(virtio_pci_device) 分配bar空间, 返回Vec.这是PciDevice本身的方法 pci_bus.add_device() //添加到hashmap 记录这个Bus_device到bus_devices pci_bus.register_mapping() //注册bar地址到device manager的MMIO Bus, 关联本BusDevice到这个bar地址 6. virtio设备的每个queue, 都有个\"通知\"地址 = bar地址base+NOTIFICATION_BAR_OFFSET+queue index*4, 每个通知地址都有一个eventfd self.address_manager.register_ioevent() 调用KVM的KVM_IOEVENTFD ioctl 7. 把本设备加入到device_tree } add_vfio_devices() add_user_devices() self.bus_devices .push(Arc::clone(&segment.pci_config_mmio) as Arc>); 8. done self.virtio_devices = virtio_devices */ vm.boot() //新建thread处理signal: SIGWINCH, SIGTERM, SIGINT self.setup_signal_handler() //stdin设为raw mode self.setup_tty() //load kernel let entry_point = self.entry_point() self.cpu_manager.create_boot_vcpus() for each vcpu kvm create vcpu self.cpu_manager.start_boot_vcpus() for each vcpu 创建新线程, 在里面loop: vcpu.run() VcpuExit::IoIn VcpuExit::IoOut VcpuExit::Shutdown VcpuExit::SystemEvent VcpuExit::MmioRead VcpuExit::MmioWrite VcpuExit::Hyperv DeviceManager DeviceManager结构体 pub struct DeviceManager { // Manage address space related to devices address_manager: Arc, // Console abstraction console: Arc, // console PTY console_pty: Option>>, // serial PTY serial_pty: Option>>, // Serial Manager serial_manager: Option>, // pty foreground status, console_resize_pipe: Option>, // Interrupt controller #[cfg(target_arch = \"x86_64\")] interrupt_controller: Option>>, #[cfg(target_arch = \"aarch64\")] interrupt_controller: Option>>, // Things to be added to the commandline (e.g. aarch64 early console) #[cfg(target_arch = \"aarch64\")] cmdline_additions: Vec, // ACPI GED notification device ged_notification_device: Option>>, // VM configuration config: Arc>, // Memory Manager memory_manager: Arc>, // The virtio devices on the system virtio_devices: Vec, // List of bus devices // Let the DeviceManager keep strong references to the BusDevice devices. // This allows the IO and MMIO buses to be provided with Weak references, // which prevents cyclic dependencies. bus_devices: Vec>>, // Counter to keep track of the consumed device IDs. device_id_cnt: Wrapping, pci_segments: Vec, #[cfg_attr(target_arch = \"aarch64\", allow(dead_code))] // MSI Interrupt Manager msi_interrupt_manager: Arc>, #[cfg_attr(feature = \"mshv\", allow(dead_code))] // Legacy Interrupt Manager legacy_interrupt_manager: Option>>, // Passthrough device handle passthrough_device: Option>, // VFIO container // Only one container can be created, therefore it is stored as part of the // DeviceManager to be reused. vfio_container: Option>, // Paravirtualized IOMMU iommu_device: Option>>, iommu_mapping: Option>, // PCI information about devices attached to the paravirtualized IOMMU // It contains the virtual IOMMU PCI BDF along with the list of PCI BDF // representing the devices attached to the virtual IOMMU. This is useful // information for filling the ACPI VIOT table. iommu_attached_devices: Option)>, // Tree of devices, representing the dependencies between devices. // Useful for introspection, snapshot and restore. device_tree: Arc>, // Exit event exit_evt: EventFd, reset_evt: EventFd, #[cfg(target_arch = \"aarch64\")] id_to_dev_info: HashMap, // seccomp action seccomp_action: SeccompAction, // List of guest NUMA nodes. numa_nodes: NumaNodes, // Possible handle to the virtio-balloon device balloon: Option>>, // Virtio Device activation EventFd to allow the VMM thread to trigger device // activation and thus start the threads from the VMM thread activate_evt: EventFd, acpi_address: GuestAddress, selected_segment: usize, // Possible handle to the virtio-mem device virtio_mem_devices: Vec>>, #[cfg(target_arch = \"aarch64\")] // GPIO device for AArch64 gpio_device: Option>>, #[cfg(target_arch = \"aarch64\")] // Flash device for UEFI on AArch64 uefi_flash: Option>, // Flag to force setting the iommu on virtio devices force_iommu: bool, // Helps identify if the VM is currently being restored restoring: bool, // io_uring availability if detected io_uring_supported: Option, // List of unique identifiers provided at boot through the configuration. boot_id_list: BTreeSet, // Start time of the VM timestamp: Instant, } DeviceManager方法 impl DeviceManager { new() serial_pty() console_pty() console_resize_pipe() create_devices() state() set_state() get_msi_iova_space() get_device_info() add_pci_devices() add_interrupt_controller() get_interrupt_controller() add_acpi_devices() add_legacy_devices() add_serial_device() modify_mode() set_raw_mode() add_virtio_console_device() add_console_device() make_virtio_devices() make_virtio_block_devices() make_virtio_net_devices() make_virtio_rng_devices() make_virtio_fs_devices() make_virtio_pmem_devices() make_virtio_vsock_devices() make_virtio_mem_devices() make_virtio_balloon_devices() make_virtio_watchdog_devices() make_vdpa_devices() next_device_name() add_passthrough_device() create_vfio_container() add_vfio_devices() add_vfio_user_device() add_pci_device() add_virtio_pci_device() pci_resources() io_bus() mmio_bus() allocator() //address_manager.allocator interrupt_controller() pci_config_io() pci_segments() console() cmdline_additions() update_memory() activate_virtio_devices() notify_hotplug() add_device() add_user_device() remove_device() eject_device() hotplug_virtio_pci_device() is_iommu_segment() add_disk() add_fs() add_pmem() add_net() add_vdpa() add_vsock() counters() resize_balloon() device_tree() restore_devices() notify_power_button() iommu_attached_devices() uefi_flash() validate_identifier() } DeviceNode包括id, 资源, 层级, pci信息 尤其是每个Device都是PCI的device #[derive(Clone, Serialize, Deserialize)] pub struct DeviceNode { pub id: String, pub resources: Vec, pub parent: Option, pub children: Vec, #[serde(skip)] pub migratable: Option>>, pub pci_bdf: Option, #[serde(skip)] pub pci_device_handle: Option, } PCI segment pub(crate) struct PciSegment { pub(crate) id: u16, pub(crate) pci_bus: Arc>, pub(crate) pci_config_mmio: Arc>, pub(crate) mmio_config_address: u64, #[cfg(target_arch = \"x86_64\")] pub(crate) pci_config_io: Option>>, // Bitmap of PCI devices to hotplug. pub(crate) pci_devices_up: u32, // Bitmap of PCI devices to hotunplug. pub(crate) pci_devices_down: u32, // List of allocated IRQs for each PCI slot. pub(crate) pci_irq_slots: [u8; 32], // Device memory covered by this segment pub(crate) start_of_device_area: u64, pub(crate) end_of_device_area: u64, pub(crate) allocator: Arc>, } pci的config空间是vmm的一个结构体: /// Contains the configuration space of a PCI node. /// See the [specification](https://en.wikipedia.org/wiki/PCI_configuration_space). /// The configuration space is accessed with DWORD reads and writes from the guest. pub struct PciConfiguration { registers: [u32; NUM_CONFIGURATION_REGISTERS], writable_bits: [u32; NUM_CONFIGURATION_REGISTERS], // writable bits for each register. bars: [PciBar; NUM_BAR_REGS], rom_bar_addr: u32, rom_bar_size: u32, rom_bar_used: bool, // Contains the byte offset and size of the last capability. last_capability: Option, msix_cap_reg_idx: Option, msix_config: Option>>, } new一个segment impl PciSegment { pub(crate) fn new() { 1. 新建一个pci root桥 默认是VENDOR_ID_INTEL(0x8086)和DEVICE_ID_INTEL_VIRT_PCIE_HOST(0xD57) PciClassCode::BridgeDevice &PciBridgeSubclass::HostBridge PciHeaderType::Device 2. 新建PCI bus, PCI bus用hashmap来管理pci 设备: HashMap>> 3. 新建pci_config_mmio, 一个就是一个PciBus实例 4. 把pci_config_mmio insert到address_manager的mmio_bus 5. 组装一个segment并返回 } } PciBus impl PciBus { new() register_mapping() add_device() remove_by_device() next_device_id() get_device_id() put_device_id() } PciDevice pub trait PciDevice: BusDevice { allocate_bars() free_bars() write_config_register() read_config_register() detect_bar_reprogramming() read_bar() write_bar() move_bar() as_any() id() } virtio设备 virtionet 代码cloud-hypervisor/virtio-devices/src/net.rs //主要是创建tap设备, 配置virtio net的属性 make_virtio_net_devices() 1. 生成id, 即xxx_net 2. 支持vhost user, 但一般还是virtio-net对接tap设备 virtio_devices::Net::new() tap设备有名就open有名的, 没名就默认叫vmtap%d tap设备可以配IP 这里为了模拟多queue, 使用了多个tap Self::new_with_tap() 设置feature标记各种offload, tso, 多队列 Ok(Net { common: VirtioCommon { device_type: VirtioDeviceType::Net as u32, avail_features, queue_sizes: vec![queue_size; queue_num], paused_sync: Some(Arc::new(Barrier::new((num_queues / 2) + 1))), min_queues: 2, ..Default::default() }, id, taps, config, ctrl_queue_epoll_thread: None, counters: NetCounters::default(), seccomp_action, rate_limiter_config, exit_evt, }) 3. 插入到设备树 self.device_tree.insert() 4. 返回MetaVirtioDevice Ok(MetaVirtioDevice { virtio_device, iommu: net_cfg.iommu, id, pci_segment: net_cfg.pci_segment, dma_handler: None, }) Net结构体 pub struct Net { common: VirtioCommon, id: String, taps: Vec, config: VirtioNetConfig, ctrl_queue_epoll_thread: Option>, counters: NetCounters, seccomp_action: SeccompAction, rate_limiter_config: Option, exit_evt: EventFd, } impl VirtioDevice for Net impl VirtioDevice for Net { device_type() queue_max_sizes() features() ack_features() read_config() activate() //这里应该是入口 reset() counters() set_access_platform() } activate 在vmm.control_loop的事件循环里, 会有EpollDispatch::ActivateVirtioDevices事件来触发virtio设备的使能: fn activate { 1. self.common.activate() 2. 创建NetCtrlEpollHandler, 起个线程\"_net1_ctrl\", 在里面epoll循环处理ctrl queue的事件 3. 每个q都创建NetEpollHandler, 起个线程\"_net1_qp%i\", 在epoll里循环处理data queue的事件 } data queue的事件: match ev_type { RX_QUEUE_EVENT: self.handle_rx_event() TX_QUEUE_EVENT: self.handle_tx_event() TX_TAP_EVENT: self.handle_tx_event() RX_TAP_EVENT: self.handle_rx_tap_event() 还有rate limit事件... } NetQueuePair cloud-hypervisor/net_util/src/queue_pair.rs 前面的事件, 最后都会落脚到 impl NetQueuePair { process_tx() self.tx.process_desc_chain() 基本上就是在循环里直接操作desc指向的buffer, 最后调用libc::writev把这些buffer写到tap的fd里面. 最后更新used index process_rx() self.rx.process_desc_chain 基本上是从desc链的信息中, 找到guest driver提前准备好的buffer, 组成iovecs, 用libc::readv函数读到这个iovecs里 } 其他trait Net还满足: Drop trait Pausable trait Snapshottable trait Transportable trait Migratable trait virtio block make_virtio_block_device() 1. 生成id, 一般是xxx_disk 2. 支持vhost user对接spdk 3. 打开块设备文件, 支持qcow2, vhd和raw, 返回一个trait object: Box 4. 传入上面的材料, 创建virtio block设备 virtio_devices::Block::new() 设置feature标记, FLUSH, CONFIG_WCE, BLK_SIZE, TOPOLOGY 计算disk参数, 比如block size, sector个数, writeback, 多队列等 返回Block设备 Ok(Block { common: VirtioCommon { device_type: VirtioDeviceType::Block as u32, avail_features, paused_sync: Some(Arc::new(Barrier::new(num_queues + 1))), queue_sizes: vec![queue_size; num_queues], min_queues: 1, ..Default::default() }, id, disk_image, disk_path, disk_nsectors, config, writeback: Arc::new(AtomicBool::new(true)), counters: BlockCounters::default(), seccomp_action, rate_limiter_config, exit_evt, }) 5. 插入到设备树 self.device_tree.insert() 6. 返回MetaVirtioDevice Ok(MetaVirtioDevice { virtio_device, iommu: net_cfg.iommu, id, pci_segment: net_cfg.pci_segment, dma_handler: None, }) IO Bus和MMIO Bus 顶层的device manager包括两个bus: io bus只有x86有io bus mmio busmmio bus是最常用的. io或者mmio的Bus抽象都是一个BtreeMap, 靠地址range来路由读写操作到底指向哪个具体的设备 pub struct Bus { devices: RwLock>>>, } Bus设备必须有offset读写的方法 pub trait BusDevice: Send { /// Reads at `offset` from this device fn read(&mut self, base: u64, offset: u64, data: &mut [u8]) {} /// Writes at `offset` into this device fn write(&mut self, base: u64, offset: u64, data: &[u8]) -> Option> { None } } 注: 对比firecracker的Bus定义, 和这里差不多: pub struct Bus { //bus下面是BtreeMap管理的device devices: BTreeMap>>, } Bus方法 一个BusDevice对应一个地址范围 impl Bus { new() //根据地址找上一个设备 resolve(&self, addr: u64) -> Option>)> //在指定地址范围插入设备 insert(&self, device: Arc>, base: u64, len: u64) //删除指定地址范围的设备 remove(&self, base: u64, len: u64) //读写 read(&self, addr: u64, data: &mut [u8]) write(&self, addr: u64, data: &[u8]) } 中断 和硬件的irq稍有区别, virt irq在这里被叫做Interrupt Source A device may support multiple types of interrupts, and each type of interrupt may support one or multiple interrupt sources. For example, a PCI device may support: Legacy Irq: exactly one interrupt source. PCI MSI Irq: 1,2,4,8,16,32 interrupt sources. PCI MSIx Irq: 2^n(n=0-11) interrupt sources. 一个设备可以有多个中断源, 比如MSI可以有32个源, MSIx可以有4096个源. A distinct Interrupt Source Identifier (ISID) will be assigned to each interrupt source. An ID allocator will be used to allocate and free Interrupt Source Identifiers for devices. To decouple the vm-device crate from the ID allocator, the vm-device crate doesn't take the responsibility to allocate/free Interrupt Source IDs but only makes use of assigned IDs. 每个中断源都被分配一个ID, 即ISID. vm-device只负责使用这些ID The overall flow to deal with interrupts is: The VMM creates an interrupt manager The VMM creates a device manager, passing on an reference to the interrupt manager The device manager passes on an reference to the interrupt manager to all registered devices The guest kernel loads drivers for virtual devices The guest device driver determines the type and number of interrupts needed, and update the device configuration The virtual device backend requests the interrupt manager to create an interrupt group according to guest configuration information 中断并不是在一开始就固定分配好的, 而是需要guest kernel驱动来触发. VMM创建好中断管理器后, 由设备管理器把中断控制器的引用传递给每个具体的设备; guest kernel驱动在初始化虚拟设备的时候, 决定自己的中断类型, 比如MSI, 和中断个数; 对应虚拟设备的backend根据guest驱动提供的信息, 向中断管理器请求创建一个中断group. interrupt group InterruptManager只有两个API, create_group()和destroy_group(), 用于新建/销毁 InterruptSourceGroup /// Trait to manage interrupt sources for virtual device backends. /// /// The InterruptManager implementations should protect itself from concurrent accesses internally, /// so it could be invoked from multi-threaded context. pub trait InterruptManager: Send + Sync { type GroupConfig; /// Create an [InterruptSourceGroup](trait.InterruptSourceGroup.html) object to manage /// interrupt sources for a virtual device /// /// An [InterruptSourceGroup](trait.InterruptSourceGroup.html) object manages all interrupt /// sources of the same type for a virtual device. /// /// # Arguments /// * interrupt_type: type of interrupt source. /// * base: base Interrupt Source ID to be managed by the group object. /// * count: number of Interrupt Sources to be managed by the group object. fn create_group(&self, config: Self::GroupConfig) -> Result>; /// Destroy an [InterruptSourceGroup](trait.InterruptSourceGroup.html) object created by /// [create_group()](trait.InterruptManager.html#tymethod.create_group). /// /// Assume the caller takes the responsibility to disable all interrupt sources of the group /// before calling destroy_group(). This assumption helps to simplify InterruptSourceGroup /// implementations. fn destroy_group(&self, group: Arc) -> Result; } InterruptSourceGroup负责具体中断的维护: 使能/禁止/向guest注入中断/更新中断配置 pub trait InterruptSourceGroup: Send + Sync { /// Enable the interrupt sources in the group to generate interrupts. fn enable(&self) -> Result { // Not all interrupt sources can be enabled. // To accommodate this, we can have a no-op here. Ok(()) } /// Disable the interrupt sources in the group to generate interrupts. fn disable(&self) -> Result { // Not all interrupt sources can be disabled. // To accommodate this, we can have a no-op here. Ok(()) } /// Inject an interrupt from this interrupt source into the guest. fn trigger(&self, index: InterruptIndex) -> Result; /// Returns an interrupt notifier from this interrupt. /// /// An interrupt notifier allows for external components and processes /// to inject interrupts into a guest, by writing to the file returned /// by this method. #[allow(unused_variables)] fn notifier(&self, index: InterruptIndex) -> Option; /// Update the interrupt source group configuration. /// /// # Arguments /// * index: sub-index into the group. /// * config: configuration data for the interrupt source. /// * masked: if the interrupt is masked fn update( &self, index: InterruptIndex, config: InterruptSourceConfig, masked: bool, ) -> Result; } 中断控制器 分为两大类, msi和legacy msi中断控制器 pub struct MsiInterruptManager { allocator: Arc>, vm: Arc, gsi_msi_routes: Arc>>, } MsiInterruptManager实现了InterruptManager trait: impl InterruptManager for MsiInterruptManager { type GroupConfig = MsiIrqGroupConfig; fn create_group(&self, config: Self::GroupConfig) -> Result> { let mut allocator = self.allocator.lock().unwrap(); //把这次group里的所有中断插入到irq_routes, 以hashmap形式索引, key是u32 //每个中断源对应一个eventfd和一个gsi号组成的InterruptRoute let mut irq_routes: HashMap = HashMap::with_capacity(config.count as usize); for i in config.base..config.base + config.count { irq_routes.insert(i, InterruptRoute::new(&mut allocator)?); } Ok(Arc::new(MsiInterruptGroup::new( self.vm.clone(), self.gsi_msi_routes.clone(), irq_routes, ))) } fn destroy_group(&self, _group: Arc) -> Result { Ok(()) } } MsiInterruptGroup impl InterruptSourceGroup for MsiInterruptGroup { //对这个group下面的每个中断源 fn enable(&self) -> Result { for (_, route) in self.irq_routes.iter() { route.enable(&self.vm)?; //调用kvm的ioctl KVM_IRQFD注册eventfd, 绑定到对应的gsi. 写这个eventfd会触发kvm注入中断到irqchip的gsi pin vm.register_irqfd(&self.irq_fd, self.gsi) } } disable() //取消注册 trigger() //就是写对应的eventfd notifier() //返回eventfd的clone } KVM_IRQFD Allows setting an eventfd to directly trigger a guest interrupt. kvm_irqfd.fd specifies the file descriptor to use as the eventfd and kvm_irqfd.gsi specifies the irqchip pin toggled by this event. When an event is triggered on the eventfd, an interrupt is injected into the guest using the specified gsi pin kvm的ioctl KVM_IRQFD注册eventfd, 绑定到对应的gsi. 写这个eventfd会触发kvm注入中断到irqchip的gsi pin "},"notes/rust_cloud-hypervisor_使用.html":{"url":"notes/rust_cloud-hypervisor_使用.html","title":"使用","keywords":"","body":"命令记录 命令行启动 bin/cloud-hypervisor --seccomp false --api-socket clh.sock --cpus boot=2 --memory size=2048M,shared=on --kernel kernel/vmlinux.bin --initramfs rootfs/boot/rootfs.cpio.gz --cmdline \"console=hvc0 config_overlay=linux_shell_only=1 init=/init\" ch-remote启动 # 先启动主程序, 主程序等待命令 bin/cloud-hypervisor --seccomp false --api-socket clh.sock # create bin/ch-remote --api-socket clh.sock create 启动 # virt-customize需要这个 apt install libguestfs-tools # 默认ubuntu的cloud image是没有默认用户的, 也没有root密码 # 用下面的命令配置一个 sudo virt-customize -a focal-server-cloudimg-amd64.img --root-password password:ubuntu wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img qemu-img convert -p -f qcow2 -O raw focal-server-cloudimg-amd64.img focal-server-cloudimg-amd64.raw wget https://github.com/cloud-hypervisor/rust-hypervisor-firmware/releases/download/0.4.0/hypervisor-fw 启动示例: $ sudo setcap cap_net_admin+ep ./cloud-hypervisor/target/release/cloud-hypervisor # 如果有权限问题, 把/dev/kvm的other设为读写 # 或者加入kvm组 sudo chmod o+rw /dev/kvm $ ./cloud-hypervisor/target/release/cloud-hypervisor \\ --kernel ./hypervisor-fw \\ --disk path=focal-server-cloudimg-amd64.raw \\ --cpus boot=4 \\ --memory size=1024M \\ --net \"tap=,mac=,ip=,mask=\" 可选参数 cloud-hypervisor -h --api-socket /path/to/uds --kernel --cmdline --console --cpus --device --disk --event-monitor --fs --initramfs --log-file --memory --memory-zone --net --numa --platform --pmem --restore --rng --seccomp --serial --vsock --watchdog rest API ping curl --unix-socket /tmp/clh.sock -i -X GET 'http://localhost/api/v1/vmm.ping' dump vm info 假设使用--api-socket /tmp/clh.sock启动clh curl --unix-socket /tmp/clh.sock -i -X GET 'http://localhost/api/v1/vm.info' -H 'Accept: application/json' | tail -1 | jq . 列表如下: { \"config\": { \"cpus\": { \"boot_vcpus\": 1, \"max_vcpus\": 1, \"topology\": null, \"kvm_hyperv\": false, \"max_phys_bits\": 46, \"affinity\": null, \"features\": {} }, \"memory\": { \"size\": 1073741824, \"mergeable\": false, \"hotplug_method\": \"Acpi\", \"hotplug_size\": null, \"hotplugged_size\": null, \"shared\": false, \"hugepages\": false, \"hugepage_size\": null, \"prefault\": false, \"zones\": null }, \"kernel\": { \"path\": \"./hypervisor-fw\" }, \"initramfs\": null, \"cmdline\": { \"args\": \"\" }, \"disks\": [ { \"path\": \"focal-server-cloudimg-amd64.raw\", \"readonly\": false, \"direct\": false, \"iommu\": false, \"num_queues\": 1, \"queue_size\": 128, \"vhost_user\": false, \"vhost_socket\": null, \"poll_queue\": true, \"rate_limiter_config\": null, \"id\": \"_disk0\", \"disable_io_uring\": false, \"pci_segment\": 0 } \"net\": [ { \"tap\": null, \"ip\": \"192.168.249.1\", \"mask\": \"255.255.255.0\", \"mac\": \"2e:cc:5f:b8:cd:dc\", \"host_mac\": \"82:22:4f:c3:21:da\", \"iommu\": false, \"num_queues\": 2, \"queue_size\": 256, \"vhost_user\": false, \"vhost_socket\": null, \"vhost_mode\": \"Client\", \"id\": \"_net1\", \"fds\": null, \"rate_limiter_config\": null, \"pci_segment\": 0 } ], \"rng\": { \"src\": \"/dev/urandom\", \"iommu\": false }, \"balloon\": null, \"fs\": null, \"pmem\": null, \"serial\": { \"file\": null, \"mode\": \"Null\", \"iommu\": false }, \"console\": { \"file\": null, \"mode\": \"Tty\", \"iommu\": false }, \"devices\": null, \"user_devices\": null, \"vdpa\": null, \"vsock\": null, \"iommu\": false, \"sgx_epc\": null, \"numa\": null, \"watchdog\": false, \"platform\": null }, \"state\": \"Running\", \"memory_actual_size\": 1073741824, \"device_tree\": { \"__rng\": { \"id\": \"__rng\", \"resources\": [], \"parent\": \"_virtio-pci-__rng\", \"children\": [], \"pci_bdf\": null }, \"_disk0\": { \"id\": \"_disk0\", \"resources\": [], \"parent\": \"_virtio-pci-_disk0\", \"children\": [], \"pci_bdf\": null }, \"_net1\": { \"id\": \"_net1\", \"resources\": [], \"parent\": \"_virtio-pci-_net1\", \"children\": [], \"pci_bdf\": null }, \"_virtio-pci-__console\": { \"id\": \"_virtio-pci-__console\", \"resources\": [ { \"PciBar\": { \"index\": 0, \"base\": 70364448686080, \"size\": 524288, \"type_\": \"Mmio64\", \"prefetchable\": false } } ], \"parent\": null, \"children\": [ \"__console\" ], \"pci_bdf\": \"0000:00:01.0\" }, \"__serial\": { \"id\": \"__serial\", \"resources\": [], \"parent\": null, \"children\": [], \"pci_bdf\": null }, \"_virtio-pci-_disk0\": { \"id\": \"_virtio-pci-_disk0\", \"resources\": [ { \"PciBar\": { \"index\": 0, \"base\": 3891789824, \"size\": 524288, \"type_\": \"Mmio32\", \"prefetchable\": false } } ], \"parent\": null, \"children\": [ \"_disk0\" ], \"pci_bdf\": \"0000:00:02.0\" }, \"_virtio-pci-_net1\": { \"id\": \"_virtio-pci-_net1\", \"resources\": [ { \"PciBar\": { \"index\": 0, \"base\": 70364448161792, \"size\": 524288, \"type_\": \"Mmio64\", \"prefetchable\": false } } ], \"parent\": null, \"children\": [ \"_net1\" ], \"pci_bdf\": \"0000:00:03.0\" }, \"__console\": { \"id\": \"__console\", \"resources\": [], \"parent\": \"_virtio-pci-__console\", \"children\": [], \"pci_bdf\": null }, \"__ioapic\": { \"id\": \"__ioapic\", \"resources\": [], \"parent\": null, \"children\": [], \"pci_bdf\": null }, \"_virtio-pci-__rng\": { \"id\": \"_virtio-pci-__rng\", \"resources\": [ { \"PciBar\": { \"index\": 0, \"base\": 70364447637504, \"size\": 524288, \"type_\": \"Mmio64\", \"prefetchable\": false } } ], \"parent\": null, \"children\": [ \"__rng\" ], \"pci_bdf\": \"0000:00:04.0\" } } } reboot shutdown curl --unix-socket /tmp/cloud-hypervisor.sock -i -X PUT 'http://localhost/api/v1/vm.reboot' curl --unix-socket /tmp/cloud-hypervisor.sock -i -X PUT 'http://localhost/api/v1/vm.shutdown' 其他 比如暂停, 恢复, add net, add disk, remove device, dump counters等等都支持. 例如: curl --unix-socket /tmp/clh.sock -i -X GET 'http://localhost/api/v1/vm.counters' guest kernel启动打印 以ubuntu的云镜像为例: Command line: BOOT_IMAGE=/boot/vmlinuz-5.4.0-113-generic root=LABEL=cloudimg-rootfs ro console=tty1 console=ttyS0 BIOS-provided physical RAM map efi: EFI v2.80 by Hypervisor detected: KVM clocksource: kvm-clock tsc: Detected 2394.454 MHz processor Zone ranges: DMA [mem 0x0000000000001000-0x0000000000ffffff] DMA32 [mem 0x0000000001000000-0x000000003fffffff] Normal empty Device empty Early memory node ranges node 0: [mem 0x0000000000001000-0x000000000009ffff] node 0: [mem 0x000000000013f000-0x000000003fffffff] Initmem setup node 0 [mem 0x0000000000001000-0x000000003fffffff] On node 0 totalpages: 261984 //1G Booting paravirtualized kernel on KVM //guest kernel知道自己是在KVM上启动的 NR_IRQS: 524544, nr_irqs: 256, preallocated irqs: 0 printk: console [tty1] enabled printk: console [ttyS0] enabled LSM: Security Framework initializing Yama: becoming mindful. AppArmor: AppArmor initialized PCI host bridge to bus 0000:00 pci_bus 0000:00: root bus resource [mem 0xe8000000-0xe80fffff] pci_bus 0000:00: root bus resource [mem 0xc0000000-0xe7ffffff window] pci_bus 0000:00: root bus resource [mem 0x100000000-0x3ffeffffffff window] pci_bus 0000:00: root bus resource [io 0x0000-0x0cf7 window] pci_bus 0000:00: root bus resource [io 0x0d00-0xffff window] pci_bus 0000:00: root bus resource [bus 00] pci 0000:00:00.0: [8086:0d57] type 00 class 0x060000 //INTEL pci 0000:00:01.0: [1af4:1043] type 00 class 0xffff00 //virtio pci 0000:00:01.0: reg 0x10: [mem 0x3ffefff80000-0x3ffeffffffff 64bit] //资源已经分配好 pci 0000:00:02.0: [1af4:1042] type 00 class 0x018000 pci 0000:00:02.0: reg 0x10: [mem 0xe7f80000-0xe7ffffff] pci 0000:00:03.0: [1af4:1041] type 00 class 0x020000 pci 0000:00:03.0: reg 0x10: [mem 0x3ffefff00000-0x3ffefff7ffff 64bit] pci 0000:00:04.0: [1af4:1044] type 00 class 0xffff00 pci 0000:00:04.0: reg 0x10: [mem 0x3ffeffe80000-0x3ffeffefffff 64bit] pci_bus 0000:00: on NUMA node 0 iommu: Default domain type: Translated PCI: Using ACPI for IRQ routing PCI: pci_cache_line_size set to 64 bytes tcpip协议栈初始化 virtio-pci 0000:00:01.0: enabling device (0000 -> 0002) virtio-pci 0000:00:02.0: enabling device (0000 -> 0002) virtio-pci 0000:00:03.0: enabling device (0000 -> 0002) virtio-pci 0000:00:04.0: enabling device (0000 -> 0002) Serial: 8250/16550 driver, 32 ports, IRQ sharing enabled loop, tun, vfio, usb, i2c驱动初始化 systemd开始工作 一堆的audit打印... gdb调试 用上面的命令启动hypervisor后, 用gdb调试: gdb cloud-hypervisor -p 18294 Reading symbols from cloud-hypervisor...done (gdb) b mmio_read Breakpoint 1 at 0x7f766eb1d1ee: file vmm/src/vm.rs, line 384. (gdb) b mmio_write Breakpoint 2 at 0x7f766eb1d3a1: file vmm/src/vm.rs, line 391. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00007f766eb1d1ee in ::mmio_read at vmm/src/vm.rs:384 2 breakpoint keep y 0x00007f766eb1d3a1 in ::mmio_write at vmm/src/vm.rs:391 (gdb) b src/kvm/mod.rs:1145 Breakpoint 4 at 0x7f766f2759d7: file hypervisor/src/kvm/mod.rs, line 1145. //只对thread 4打断点 (gdb) b kvm_ioctls::ioctls::vcpu::VcpuFd::run thread 4 rust-gdb 参考https://bitshifter.github.io/rr+rust/index.html#1 需要在root用户下安装rust. 我从普通用户拷贝~/.cargo和~/.rustp好像也能用. # su root ~/.cargo/bin/rust-gdb -p 19507 b kvm_ioctls::ioctls::vcpu::VcpuFd::run 测试场景: vm内virtio-net网口ping对应的tap口 启动hypervisor后, VM内有virtio-net网口: root@ubuntu:~# ethtool -i ens3 driver: virtio_net version: 1.0.0 bus-info: 0000:00:03.0 查看pci拓扑: 注: lspci执行过程中, 会频繁的触发vm exit, 断点表面是VM在做VcpuExit::IoOut root@ubuntu:~# lspci 00:00.0 Host bridge: Intel Corporation Device 0d57 00:01.0 Unassigned class [ffff]: Red Hat, Inc. Virtio console (rev 01) 00:02.0 Mass storage controller: Red Hat, Inc. Virtio block device (rev 01) 00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device (rev 01) 00:04.0 Unassigned class [ffff]: Red Hat, Inc. Virtio RNG (rev 01) 同时, hypervisor会在host上创建一个网口vmtap0, 并配置IP192.168.249.1/24 默认vm的ens3是down的, 下面配置其为up, ip为192.168.249.2 ip link set up dev ens3 ip addr add 192.168.249.2/24 dev ens3 此时可以ping通vmtap0: ping 192.168.249.1 gdb观察 设断点: # su root ~/.cargo/bin/rust-gdb -p 19507 b kvm_ioctls::ioctls::vcpu::VcpuFd::run 这里的kvm_ioctls::ioctls::vcpu::VcpuFd::run是下面代码:是KVM_RUN的循环主体. ping是否会触发VM exit -- 否 一直ping, 同时做gdb观察 gdb设置上面的断点后, continue执行, 除了第一次continue后会触发断点, 后面不管怎么ping, 都没有触发断点. 说明: virtio-net在ping的过程中, VM并没有exit, VM一直\"全速\"运行 因为VM没有exit, 也就没有mmio_read, mmio_write等触发VMM后端的动作; 就是说guest driver在收发报文的时候, 对vring的操作, 对bar寄存器的操作, 统统没有触发mmio exit. vmm后端怎么工作 前面看到, ping的过程中没有观察到VM exit, 那VMM后端如何响应guest driver的读写寄存器请求的呢? 会不会在其他代码路径下面调用了寄存器访问的函数呢? 先看看有没有人调用mmio_write和mmio_read (gdb) b mmio_read (gdb) b mmio_write 注: 用b vmm::vm::VmOpsHandler::mmio_read是不认的. 用这样的语法gdb可以认: (gdb) b ::mmio_read 继续在VM里ping, 没有触发断点. 再增加 (gdb) b vm_device::bus::Bus::read (gdb) b vm_device::bus::Bus::write 依旧没触发. 看看有没有认调用VirtioPciDevice的read: b ::read b ::write 还是没有触发 继续看pci的读写bar操作: b ::read_bar b ::write_bar 还是没有触发 至此, VM exit路径没有触发virtio-net后端的动作. 所以, 到这里很清楚了, virtio-net设备在工作的时候, 完全不需要在VM exit和VM enter之间进行切换. guest driver和vmm device在virtio ring的协议下, 通过ioeventfd和irqfd来互相\"通知\", 在VM不exit的情况下, 完成报文的交互. 见cloud-hypervisor/net_util/src/queue_pair.rs的process_tx()和process_rx()函数. 再次确认, pci::device::PciDevice::read_bar/write_bar并没有在virtio-net报文交换的过程中被调用. 写文件是否会触发VM exit -- 否 echo abc > abc.txt sync //执行的很快 dd if=/dev/zero of=out.dd bs=1M count=4 4194304 bytes (4.2 MB, 4.0 MiB) copied, 0.0129554 s, 324 MB/s lspci是否会触发VM exit -- 是 在vm里面执行lspci, 可以看到断点被触发: (gdb) bt #0 kvm_ioctls::ioctls::vcpu::VcpuFd::run #1 0x00007fee2b19b9c5 in ::run #2 0x00007fee2aca1b45 in vmm::cpu::Vcpu::run #3 0x00007fee2ac7f5cb in vmm::cpu::CpuManager::start_vcpu::{{closure}}::{{closure}} () #4 0x00007fee2acd51bb in std::panicking::try::do_call #5 0x00007fee2acd5c5b in __rust_try #6 0x00007fee2acd46e1 in std::panicking::try #7 0x00007fee2ab64211 in std::panic::catch_unwind #8 0x00007fee2ac7eaf4 in vmm::cpu::CpuManager::start_vcpu::{{closure}} #9 0x00007fee2aa607c3 in std::sys_common::backtrace::__rust_begin_short_backtrace #10 0x00007fee2a9cbde0 in std::thread::Builder::spawn_unchecked_::{{closure}}::{{closure}} #11 0x00007fee2acdc7c4 in #12 0x00007fee2acd50a2 in std::panicking::try::do_call #13 0x00007fee2acd5c5b in __rust_try #14 0x00007fee2acd44e7 in std::panicking::try #15 0x00007fee2ab64254 in std::panic::catch_unwind #16 0x00007fee2a9cafb3 in std::thread::Builder::spawn_unchecked_::{{closure}} #17 0x00007fee2a82f74f in core::ops::function::FnOnce::call_once{{vtable-shim}} #18 0x00007fee2b423ff3 in as core::ops::function::FnOnce>::call_once #19 as core::ops::function::FnOnce>::call_once #20 std::sys::unix::thread::Thread::new::thread_start #21 0x00007fee2b44c2e5 in start #22 0x00007fee2b44d3d9 in __clone (gdb) n (gdb) n (gdb) finish (gdb) n 1147 VcpuExit::IoIn(addr, data) => { 最后跟下来vm在做VcpuExit::IoIn和VcpuExit::IoOut, vmm调用对应的pio_read和pio_write来响应. 注: lspci没有触发mmio相关的调用, 只有pio. 最小化启动 https://bl.ocks.org/gdamjan/1f260b58eb9fb1ba62d2234958582405 https://alpinelinux.org/downloads/ 参考集成 见: cloud-hypervisor/scripts/run_integration_tests_x86_64.sh release过程 jobs: steps: - name: Code checkout uses: actions/checkout@v2 - name: Install musl-gcc run: sudo apt install -y musl-tools //需要musl-tools - name: Install Rust toolchain (x86_64-unknown-linux-gnu) //gnu target是动态链接 uses: actions-rs/toolchain@v1 with: toolchain: \"1.60\" target: x86_64-unknown-linux-gnu - name: Install Rust toolchain (x86_64-unknown-linux-musl) //musl target是静态链接 uses: actions-rs/toolchain@v1 with: toolchain: \"1.60\" target: x86_64-unknown-linux-musl - name: Build uses: actions-rs/cargo@v1 with: toolchain: \"1.60\" command: build args: --all --release --target=x86_64-unknown-linux-gnu - name: Static Build uses: actions-rs/cargo@v1 with: toolchain: \"1.60\" command: build args: --all --release --target=x86_64-unknown-linux-musl - name: Strip cloud-hypervisor binaries run: strip target/*/release/cloud-hypervisor //strip - name: Install Rust toolchain (aarch64-unknown-linux-musl) //aarch64 musl uses: actions-rs/toolchain@v1 with: toolchain: \"1.60\" target: aarch64-unknown-linux-musl override: true - name: Static Build (AArch64) uses: actions-rs/cargo@v1 with: use-cross: true command: build args: --all --release --target=aarch64-unknown-linux-musl - name: Upload static cloud-hypervisor //上传asset id: upload-release-static-cloud-hypervisor uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: upload_url: ${{ steps.create_release.outputs.upload_url }} asset_path: target/x86_64-unknown-linux-musl/release/cloud-hypervisor asset_name: cloud-hypervisor-static asset_content_type: application/octet-stream "},"notes/rust_cloud-hypervisor_问题与解决.html":{"url":"notes/rust_cloud-hypervisor_问题与解决.html","title":"问题与解决","keywords":"","body":"cloud hypervisor无法启动 直接启动会报错:看提示已经能够显示出错的具体代码位置了. 加上RUST_BACKTRACE=1会更具体: 又提示RUST_BACKTRACE=full会更详细: 可以看到: rust的调用层级很多, 和go有的一拼 RUST_BACKTRACE=1会过滤掉最近的0到12层调用栈, 这些都是rust_begin_unwind的内部流程, 一般用户不需要关心 真正出问题的是vmm::vm::Vm::new, 即RUST_BACKTRACE=full时的第16层调用栈, 很奇怪的是在调用栈里没提示是哪一行. 但调用栈打印之前就有打印提示出错文件和行号:vmm/src/vm.rs:729:48 unwrap出错会直接panic 用环境变量RUST_BACKTRACE=这招和go很像GOTRACEBACK= 会是什么原因 突然想到这个机器本来就是kvm的虚拟机, 是否是kvm嵌套没打开呢? 参考:https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/ 检查kvm是否nested cat /sys/module/kvm_intel/parameters/nested 果然这个机器显示N enable nested KVM To enable nested virtualization for Intel processors: Shut down all running VMs and unload the kvm_probe module:sudo modprobe -r kvm_intel Activate the nesting feature:sudo modprobe kvm_intel nested=1 Nested virtualization is enabled until the host is rebooted. To enable it permanently, add the following line to the /etc/modprobe.d/kvm.conf file:options kvm_intel nested=1 AMD的CPU把上面的kvm_intel改成kvm_amd 不是nested没开 按照上面的方法, 重新加载kvm_intel并使能nested=1, 也成功了. 但问题依旧.那估计就是kernel版本太低了:Linux spine.novalocal 3.10.0-1160.2.2.el7.x86_64 不支持KVM_CAP_IMMEDIATE_EXIT功能 https://github.com/rust-vmm/kvm-ioctls/src/cap.rs ImmediateExit = KVM_CAP_IMMEDIATE_EXIT, 升级kernel centos 7的kernel比较老, 直接用标准方式升级版本还是3.10. 下面用epel升级kernel yum --enablerepo=elrepo-kernel install kernel-lt 改grub默认从新kernel启动, 启动后版本是: $ uname -a Linux spine.novalocal 5.4.207-1.el7.elrepo.x86_64 #1 SMP Tue Jul 19 10:40:55 EDT 2022 x86_64 x86_64 x86_64 GNU/Linux 使用新kernel问题解决! "},"notes/rust_mdbook_使用.html":{"url":"notes/rust_mdbook_使用.html","title":"使用mdbook","keywords":"","body":"mdBook是rust写的一个工具, 用来把md文档转成html book.guide: https://rust-lang.github.io/mdBook mdBook本身也是个git repo: https://github.com/rust-lang/mdBook 更新 2022.08 mdbook不支持中文搜索, 故弃用. 使用gitbook代替gitbook参考:https://github.com/zhangjikai/gitbook-usehttps://github.com/snowdreams1006/snowdreams1006.github.io/blob/master/book.jsonhttps://snowdreams1006.github.io/ 安装 可以直接去github页面下载: https://github.com/rust-lang/mdBook/releases也可以自己编译, 但需要先安装rust编译器 cargo install mdbook cargo命令会自动从crates.io下载mdbook, 编译, 然后安装到cargo的bin目录(默认是~/.cargo/bin/). crates.io上的版本会比github代码稍微滞后一点, 可以指定用github代码编译: cargo install --git https://github.com/rust-lang/mdBook.git mdbook book组织 book由chapter组成, 每个chapter是一个独立的page, chapter可以有子chapter. mdbook使用 # 新建一个book mdbook init my-first-book cd my-first-book # 开启一个webserver, 修改的内容可以自动刷新到web page mdbook serve book.toml 一个book需要几个特殊文件来定义排版和布局. 根目录下的book.toml就是其中一个: 最常用的, 最简单的: [book] title = \"My First Book\" mdbook自己的实例:https://github.com/rust-lang/mdBook/blob/master/guide/book.toml SUMMARY.md 这个文件在src目录下, 定义了chapter结构: # Summary [Introduction](README.md) - [My First Chapter](my-first-chapter.md) - [Nested example](nested/README.md) - [Sub-chapter](nested/sub-chapter.md) 实例: https://github.com/rust-lang/mdBook/blob/master/guide/src/SUMMARY.md build book mdbook build 这个命令会根据md文件在本地book目录下生成html. "}}