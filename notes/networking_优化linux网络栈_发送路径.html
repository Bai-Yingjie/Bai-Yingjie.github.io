
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>优化linux网络栈: 发送路径(网摘) · My Notes</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Bai Yingjie">
        
        
    
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-prism/prism.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-hide-navigation-buttons/index.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    


    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="networking_Potential_Performance_Bottleneck_in_Linux_TCP.html" />
    
    
    <link rel="prev" href="networking_优化linux网络栈_接收路径.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    简介
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="recent_topics.html">
            
                <a href="recent_topics.html">
            
                    
                    recent topics
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="as_title_kaiyuan.html">
            
                <a href="as_title_kaiyuan.html">
            
                    
                    开源
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="my_opensource.html">
            
                <a href="my_opensource.html">
            
                    
                    我的开源项目
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="my_upstream.html">
            
                <a href="my_upstream.html">
            
                    
                    我的upstream commit
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="as_title_system.html">
            
                <a href="as_title_system.html">
            
                    
                    系统分析和性能
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="as_title_perf_misc.html">
            
                <a href="as_title_perf_misc.html">
            
                    
                    调试和分析记录系列
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="profiling_调试和分析记录5.html">
            
                <a href="profiling_调试和分析记录5.html">
            
                    
                    调试和分析记录5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="profiling_调试和分析记录4.html">
            
                <a href="profiling_调试和分析记录4.html">
            
                    
                    调试和分析记录4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="profiling_调试和分析记录3.html">
            
                <a href="profiling_调试和分析记录3.html">
            
                    
                    调试和分析记录3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="profiling_调试和分析记录2.html">
            
                <a href="profiling_调试和分析记录2.html">
            
                    
                    调试和分析记录2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="profiling_调试和分析记录1.html">
            
                <a href="profiling_调试和分析记录1.html">
            
                    
                    调试和分析记录1
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="调试和分析工具概览.html">
            
                <a href="调试和分析工具概览.html">
            
                    
                    profiling和debugging工具相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1" data-path="profiling_Linux内核调试的方式以及工具集锦.html">
            
                <a href="profiling_Linux内核调试的方式以及工具集锦.html">
            
                    
                    Linux内核调试的方式以及工具集锦(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" data-path="profiling_user_space_Ptrace_Utrace_Uprobes.html">
            
                <a href="profiling_user_space_Ptrace_Utrace_Uprobes.html">
            
                    
                    Ptrace, Utrace, Uprobes: Lightweight, Dynamic Tracing of User Apps
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" data-path="debugging_gdb备忘录.html">
            
                <a href="debugging_gdb备忘录.html">
            
                    
                    gdb备忘录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" data-path="profiling_perf命令备忘录.html">
            
                <a href="profiling_perf命令备忘录.html">
            
                    
                    perf命令备忘录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.5" data-path="profiling_perf命令备忘录2.html">
            
                <a href="profiling_perf命令备忘录2.html">
            
                    
                    perf命令备忘录2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.6" data-path="profiling_perf学习笔记之实战篇.html">
            
                <a href="profiling_perf学习笔记之实战篇.html">
            
                    
                    perf学习笔记之实战篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.7" data-path="profiling_perf学习笔记之入门篇.html">
            
                <a href="profiling_perf学习笔记之入门篇.html">
            
                    
                    perf学习笔记之入门篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.8" data-path="profiling_用kprobe和perf_记录函数参数.html">
            
                <a href="profiling_用kprobe和perf_记录函数参数.html">
            
                    
                    使用kprobe和perf结合记录函数参数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.9" data-path="profiling_ftrace和trace-cmd记录.html">
            
                <a href="profiling_ftrace和trace-cmd记录.html">
            
                    
                    ftrace和trace-cmd记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.10" data-path="profiling_ftrace使用实例.html">
            
                <a href="profiling_ftrace使用实例.html">
            
                    
                    ftrace使用实例
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.11" data-path="profiling_systemtap实例.html">
            
                <a href="profiling_systemtap实例.html">
            
                    
                    systemtap实例
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.12" data-path="profiling_systemtap基础.html">
            
                <a href="profiling_systemtap基础.html">
            
                    
                    systemtap基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.13" data-path="profiling_perf-tools_example.html">
            
                <a href="profiling_perf-tools_example.html">
            
                    
                    perf-tools 系统tracing工具集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.14" data-path="profiling_Comparing_SystemTap_and_bpftrace.html">
            
                <a href="profiling_Comparing_SystemTap_and_bpftrace.html">
            
                    
                    Comparing SystemTap and bpftrace(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.15" data-path="system_analysis_bcc和ebpf.html">
            
                <a href="system_analysis_bcc和ebpf.html">
            
                    
                    bcc和ebpf(starting)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.16" data-path="profiling_valgrind体验.html">
            
                <a href="profiling_valgrind体验.html">
            
                    
                    体验valgrind
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="as_title_os_perf.html">
            
                <a href="as_title_os_perf.html">
            
                    
                    profiling和debugging实例
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.3.1" data-path="debugging_gshellos_socket_leak.html">
            
                <a href="debugging_gshellos_socket_leak.html">
            
                    
                    gshell socket leak调查
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.2" data-path="profiling_调查ftrace显示调用栈全0问题.html">
            
                <a href="profiling_调查ftrace显示调用栈全0问题.html">
            
                    
                    调查ftrace显示调用栈全0问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.3" data-path="profiling_eoe_filter写tap设备失败问题.html">
            
                <a href="profiling_eoe_filter写tap设备失败问题.html">
            
                    
                    eoe_filter写tap设备失败问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.4" data-path="performance_ovs进程调查.html">
            
                <a href="performance_ovs进程调查.html">
            
                    
                    OVS进程调查
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.5" data-path="performance_ping流程和函数调用解析.html">
            
                <a href="performance_ping流程和函数调用解析.html">
            
                    
                    ping流程和函数调用解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.6" data-path="profiling_VM互相ping场景下的延迟分析.html">
            
                <a href="profiling_VM互相ping场景下的延迟分析.html">
            
                    
                    VM互相ping场景下的延迟分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.7" data-path="debugging_ftrace_谁创建了bond0设备.html">
            
                <a href="debugging_ftrace_谁创建了bond0设备.html">
            
                    
                    谁创建了bond0设备: ftrace kprobe uprobe perf综合使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.8" data-path="profiling_unixbench之filecopy分析.html">
            
                <a href="profiling_unixbench之filecopy分析.html">
            
                    
                    unixbench之file copy分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.9" data-path="profiling_lmbench之lat_tcp分析.html">
            
                <a href="profiling_lmbench之lat_tcp分析.html">
            
                    
                    lmbench之lat_tcp分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="as_title_arch_perf.html">
            
                <a href="as_title_arch_perf.html">
            
                    
                    CPU ARCH相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.4.1" data-path="performance_CPU_microarchiteture_pmu.html">
            
                <a href="performance_CPU_microarchiteture_pmu.html">
            
                    
                    Top-down Microarchitecture Analysis Method(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="as_title_cloud.html">
            
                <a href="as_title_cloud.html">
            
                    
                    Cloud和容器相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="container_linux_namespaces.html">
            
                <a href="container_linux_namespaces.html">
            
                    
                    linux名字空间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="cloud_杂记.html">
            
                <a href="cloud_杂记.html">
            
                    
                    云杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="container_当代容器读书笔记.html">
            
                <a href="container_当代容器读书笔记.html">
            
                    
                    当代容器读书笔记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="multi-arch_docker_binfmt_misc.html">
            
                <a href="multi-arch_docker_binfmt_misc.html">
            
                    
                    multi-arch docker 和 binfmt_misc
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="as_title_vdevice.html">
            
                <a href="as_title_vdevice.html">
            
                    
                    CPU和device虚拟化
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="as_title_gvisor.html">
            
                <a href="as_title_gvisor.html">
            
                    
                    gvisor
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1.1" data-path="golang_gvisor代码_KVM.html">
            
                <a href="golang_gvisor代码_KVM.html">
            
                    
                    gvisor KVM模式代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.1.2" data-path="golang_gvisor调试.html">
            
                <a href="golang_gvisor调试.html">
            
                    
                    gvisor调试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.1.3" data-path="golang_gvisor_ptrace.html">
            
                <a href="golang_gvisor_ptrace.html">
            
                    
                    gvisor ptrace模式介绍(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="rust_vmm_brief.html">
            
                <a href="rust_vmm_brief.html">
            
                    
                    rust VMM(virtual machine monitor)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.2.1" data-path="rust_vmm_简介.html">
            
                <a href="rust_vmm_简介.html">
            
                    
                    rust-vmm简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.2" data-path="rust_firecracker_代码.html">
            
                <a href="rust_firecracker_代码.html">
            
                    
                    firecracker代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.3" data-path="rust_firecracker_使用.html">
            
                <a href="rust_firecracker_使用.html">
            
                    
                    firecracker使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.4" data-path="rust_cloud-hypervisor_代码.html">
            
                <a href="rust_cloud-hypervisor_代码.html">
            
                    
                    cloud hypervisor代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.5" data-path="rust_cloud-hypervisor_使用.html">
            
                <a href="rust_cloud-hypervisor_使用.html">
            
                    
                    cloud hypervisor使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.6" data-path="rust_cloud-hypervisor_问题与解决.html">
            
                <a href="rust_cloud-hypervisor_问题与解决.html">
            
                    
                    cloud hypervisor问题与解决
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.7" data-path="rust_virtiofsd_代码.html">
            
                <a href="rust_virtiofsd_代码.html">
            
                    
                    virtiofsd代码阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.8" data-path="rust_virtio_vhost_libs.html">
            
                <a href="rust_virtio_vhost_libs.html">
            
                    
                    vhost virtio相关的rust库
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="virtualization_virtio规范阅读笔记.html">
            
                <a href="virtualization_virtio规范阅读笔记.html">
            
                    
                    virtio规范阅读笔记.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="qemu_ovs_虚拟化环境.html">
            
                <a href="qemu_ovs_虚拟化环境.html">
            
                    
                    qemu OVS 虚拟化环境准备
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="qemu使用.html">
            
                <a href="qemu使用.html">
            
                    
                    Qemu使用(old)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="qemu_binary_translation.html">
            
                <a href="qemu_binary_translation.html">
            
                    
                    QEMU 指令翻译
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="as_title_networking.html">
            
                <a href="as_title_networking.html">
            
                    
                    计算机网络相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="networking_杂记2.html">
            
                <a href="networking_杂记2.html">
            
                    
                    networking杂记2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="networking_杂记1.html">
            
                <a href="networking_杂记1.html">
            
                    
                    networking杂记1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="networking_优化linux网络栈_接收路径.html">
            
                <a href="networking_优化linux网络栈_接收路径.html">
            
                    
                    优化linux网络栈: 接收路径(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6.4" data-path="networking_优化linux网络栈_发送路径.html">
            
                <a href="networking_优化linux网络栈_发送路径.html">
            
                    
                    优化linux网络栈: 发送路径(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="networking_Potential_Performance_Bottleneck_in_Linux_TCP.html">
            
                <a href="networking_Potential_Performance_Bottleneck_in_Linux_TCP.html">
            
                    
                    Potential Performance Bottleneck in Linux TCP(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="networking_xdp入门.html">
            
                <a href="networking_xdp入门.html">
            
                    
                    Get started with XDP(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="networking_linux收包路径图解.html">
            
                <a href="networking_linux收包路径图解.html">
            
                    
                    linux收包路径图解(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="vpp_compiling_on_alpine.md">
            
                <span>
            
                    
                    alpine编译vpp
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.8.1" data-path="vpp_host_interace.html">
            
                <a href="vpp_host_interace.html">
            
                    
                    vpp的host-interface
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="as_title_qemu_ovs.html">
            
                <a href="as_title_qemu_ovs.html">
            
                    
                    Qemu OVS和DPDK
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.9.1" data-path="OVS_DPDK_编译运行.html">
            
                <a href="OVS_DPDK_编译运行.html">
            
                    
                    OVS-DPDK编译运行
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9.2" data-path="OVS_架构和代码.html">
            
                <a href="OVS_架构和代码.html">
            
                    
                    OVS架构和代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9.3" data-path="OVS_DPDK_performance_HXT_ARM_server.html">
            
                <a href="OVS_DPDK_performance_HXT_ARM_server.html">
            
                    
                    OVS-DPDK for ARM server 性能测试环境
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9.4" data-path="DPDK_Mellanox.html">
            
                <a href="DPDK_Mellanox.html">
            
                    
                    DPDK Mellanox
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9.5" data-path="OVS_phy-vm-phy.html">
            
                <a href="OVS_phy-vm-phy.html">
            
                    
                    OVS PHY-VM-PHY
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9.6" data-path="networking_网络虚拟化用例记录.html">
            
                <a href="networking_网络虚拟化用例记录.html">
            
                    
                    网络虚拟化用例记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9.7" data-path="networking_网络虚拟化操作记录.html">
            
                <a href="networking_网络虚拟化操作记录.html">
            
                    
                    网络虚拟化操作记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6.10" data-path="as_title_virtnet.html">
            
                <a href="as_title_virtnet.html">
            
                    
                    虚拟化网络
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.10.1" data-path="networking_tc_filter_连接veth和tap.html">
            
                <a href="networking_tc_filter_连接veth和tap.html">
            
                    
                    Connecting a veth device to tap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10.2" data-path="networking_multicast_vxlan_flannel.html">
            
                <a href="networking_multicast_vxlan_flannel.html">
            
                    
                    multicast vxlan和flannel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10.3" data-path="networking_virtio网络介绍.html">
            
                <a href="networking_virtio网络介绍.html">
            
                    
                    virtio网络介绍(网摘): vhost-net virtio-net vhost-user SRIOV
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10.4" data-path="networking_virtualization_杂记.html">
            
                <a href="networking_virtualization_杂记.html">
            
                    
                    虚拟化网络杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10.5" data-path="networking_linux虚拟网络接口.html">
            
                <a href="networking_linux虚拟网络接口.html">
            
                    
                    linux虚拟网络接口(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="as_title_arm_server.html">
            
                <a href="as_title_arm_server.html">
            
                    
                    ARM server
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="arm_server_杂记.html">
            
                <a href="arm_server_杂记.html">
            
                    
                    Arm server 杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="server_知识点.html">
            
                <a href="server_知识点.html">
            
                    
                    server知识点
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="as_title_embedded.html">
            
                <a href="as_title_embedded.html">
            
                    
                    嵌入式系统开发调试
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="embedded_debugging.html">
            
                <a href="embedded_debugging.html">
            
                    
                    嵌入式调试杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="uboot_杂记.html">
            
                <a href="uboot_杂记.html">
            
                    
                    uboot杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="buildroot_杂记.html">
            
                <a href="buildroot_杂记.html">
            
                    
                    buildroot杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="toolchain_升级gcc问题解决.html">
            
                <a href="toolchain_升级gcc问题解决.html">
            
                    
                    升级GCC7.3问题解决
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="kernel_异常打印分析实例.html">
            
                <a href="kernel_异常打印分析实例.html">
            
                    
                    kernel bug异常打印分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="as_title_linuxdaily.html">
            
                <a href="as_title_linuxdaily.html">
            
                    
                    Linux工程实践
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="linux_日常使用.html">
            
                <a href="linux_日常使用.html">
            
                    
                    日常linux使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="git_日常使用.html">
            
                <a href="git_日常使用.html">
            
                    
                    日常git使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="向kernel提交补丁.html">
            
                <a href="向kernel提交补丁.html">
            
                    
                    向kernel提交补丁
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="linux_ssh_relay.html">
            
                <a href="linux_ssh_relay.html">
            
                    
                    ssh relay
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="gitlab_ci.html">
            
                <a href="gitlab_ci.html">
            
                    
                    gitlab CI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="docker_操作记录.html">
            
                <a href="docker_操作记录.html">
            
                    
                    docker操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="centos_操作记录.html">
            
                <a href="centos_操作记录.html">
            
                    
                    centos操作记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="as_title_golang.html">
            
                <a href="as_title_golang.html">
            
                    
                    Golang
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="as_title_golang1.html">
            
                <a href="as_title_golang1.html">
            
                    
                    入门
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1.1" data-path="golang_语法基础.html">
            
                <a href="golang_语法基础.html">
            
                    
                    Golang 语法基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.1.2" data-path="golang_json性能.html">
            
                <a href="golang_json性能.html">
            
                    
                    Golang json性能比较
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="golang_原理.html">
            
                <a href="golang_原理.html">
            
                    
                    Golang 原理相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.2.1" data-path="golang_interface原理.html">
            
                <a href="golang_interface原理.html">
            
                    
                    Golang interface原理(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2.2" data-path="golang_内存分配.html">
            
                <a href="golang_内存分配.html">
            
                    
                    Golang 内存分配(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="golang_标准库.html">
            
                <a href="golang_标准库.html">
            
                    
                    Golang 标准库
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="golang_泛型.html">
            
                <a href="golang_泛型.html">
            
                    
                    Golang 泛型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="golang_我的反射代码.html">
            
                <a href="golang_我的反射代码.html">
            
                    
                    Golang 我的反射代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="golang_问答.html">
            
                <a href="golang_问答.html">
            
                    
                    Golang 问答
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="golang_plugin.html">
            
                <a href="golang_plugin.html">
            
                    
                    Golang plugin
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="golang_高效go.html">
            
                <a href="golang_高效go.html">
            
                    
                    Golang 高效go
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="golang_进阶.html">
            
                <a href="golang_进阶.html">
            
                    
                    Golang 进阶
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="as_title_golang2.html">
            
                <a href="as_title_golang2.html">
            
                    
                    Golang 杂记
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.10.1" data-path="golang_杂记1.html">
            
                <a href="golang_杂记1.html">
            
                    
                    Golang 杂记1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10.2" data-path="golang_杂记2.html">
            
                <a href="golang_杂记2.html">
            
                    
                    Golang 杂记2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10.3" data-path="golang_杂记3.html">
            
                <a href="golang_杂记3.html">
            
                    
                    Golang 杂记3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10.4" data-path="golang_lib选型.html">
            
                <a href="golang_lib选型.html">
            
                    
                    Golang lib选型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10.5" data-path="golang_mod_proxy.html">
            
                <a href="golang_mod_proxy.html">
            
                    
                    go mod和go proxy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10.6" data-path="golang_汇编_arm64.html">
            
                <a href="golang_汇编_arm64.html">
            
                    
                    Golang 汇编语法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10.7" data-path="golang_cgo_swig.html">
            
                <a href="golang_cgo_swig.html">
            
                    
                    go调用c可以用swig
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="as_title_golang3.html">
            
                <a href="as_title_golang3.html">
            
                    
                    Golang 环境和工具链生成
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.11.1" data-path="golang_toolchain_ppc.html">
            
                <a href="golang_toolchain_ppc.html">
            
                    
                    go tools增加ppc32支持
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11.2" data-path="golang_toolchain_compile_gccgo.html">
            
                <a href="golang_toolchain_compile_gccgo.html">
            
                    
                    编译gccgo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11.3" data-path="golang_go_on_mips.html">
            
                <a href="golang_go_on_mips.html">
            
                    
                    go on mips boards(not so updated)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.11.3.1" data-path="golang_go_on_mips_part1.html">
            
                <a href="golang_go_on_mips_part1.html">
            
                    
                    part 1: cross compile go
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11.3.2" data-path="golang_go_on_mips_part2.html">
            
                <a href="golang_go_on_mips_part2.html">
            
                    
                    part 2: build native go compiler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11.3.3" data-path="golang_go_on_mips_part3.html">
            
                <a href="golang_go_on_mips_part3.html">
            
                    
                    part 3: gccgo experiments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11.3.4" data-path="golang_go_on_mips_part4.html">
            
                <a href="golang_go_on_mips_part4.html">
            
                    
                    part 4: Golang json performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11.3.5" data-path="golang_gentoo_on_mips_board_and_build_go.html">
            
                <a href="golang_gentoo_on_mips_board_and_build_go.html">
            
                    
                    Gentoo on mips board and build go
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.12" data-path="as_title_golang4.html">
            
                <a href="as_title_golang4.html">
            
                    
                    微服务
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.12.1" data-path="golang_micro.html">
            
                <a href="golang_micro.html">
            
                    
                    go-micro和micro
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.12.2" data-path="golang_微服务概念.html">
            
                <a href="golang_微服务概念.html">
            
                    
                    微服务概念
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.13" data-path="as_title_golang5.html">
            
                <a href="as_title_golang5.html">
            
                    
                    解释器和编解码
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.13.1" data-path="golang_yeagi.html">
            
                <a href="golang_yeagi.html">
            
                    
                    解释器yeagi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13.2" data-path="golang_tengo.html">
            
                <a href="golang_tengo.html">
            
                    
                    解释器tengo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13.3" data-path="golang_govaluate.html">
            
                <a href="golang_govaluate.html">
            
                    
                    解释器govaluate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13.4" data-path="golang_encoding_gotiny.html">
            
                <a href="golang_encoding_gotiny.html">
            
                    
                    gotiny编解码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13.5" data-path="golang_abs.html">
            
                <a href="golang_abs.html">
            
                    
                    解释器abs
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.14" data-path="as_title_golang6.html">
            
                <a href="as_title_golang6.html">
            
                    
                    调试和性能
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.14.1" data-path="golang_调试记录.html">
            
                <a href="golang_调试记录.html">
            
                    
                    Golang 调试记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.14.2" data-path="golang_topid性能优化.html">
            
                <a href="golang_topid性能优化.html">
            
                    
                    Golang topid性能优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.14.3" data-path="golang_gshell性能调试.html">
            
                <a href="golang_gshell性能调试.html">
            
                    
                    Golang gshell性能调试
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10.15" data-path="as_title_golang7.html">
            
                <a href="as_title_golang7.html">
            
                    
                    网络和消息中间件
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.15.1" data-path="golang_zmq.html">
            
                <a href="golang_zmq.html">
            
                    
                    消息中间件基本概念和zero mq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.15.2" data-path="golang_mango.html">
            
                <a href="golang_mango.html">
            
                    
                    消息中间件mango
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.15.3" data-path="golang_libp2p.html">
            
                <a href="golang_libp2p.html">
            
                    
                    Golang p2p网络
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="as_title_rust.html">
            
                <a href="as_title_rust.html">
            
                    
                    Rust
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="rust_入门_brief.html">
            
                <a href="rust_入门_brief.html">
            
                    
                    Rust 入门系列
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1.1" data-path="rust_books.html">
            
                <a href="rust_books.html">
            
                    
                    Rust reference books
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.1.2" data-path="rust_入门1.html">
            
                <a href="rust_入门1.html">
            
                    
                    Rust 安装和基础语法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.1.3" data-path="rust_入门2.html">
            
                <a href="rust_入门2.html">
            
                    
                    Rust 泛型和内存所有权
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.1.4" data-path="rust_入门3.html">
            
                <a href="rust_入门3.html">
            
                    
                    Rust 闭包 容器 迭代器 生成器 线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.1.5" data-path="rust_工程构建.html">
            
                <a href="rust_工程构建.html">
            
                    
                    Rust 工程构建
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="rust_coding_brief.html">
            
                <a href="rust_coding_brief.html">
            
                    
                    Rust 代码积累
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.2.1" data-path="rust_by_example_misc.html">
            
                <a href="rust_by_example_misc.html">
            
                    
                    Rust by example杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2.2" data-path="rust_序列化.html">
            
                <a href="rust_序列化.html">
            
                    
                    Rust 序列化原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2.3" data-path="rust_知识点积累.html">
            
                <a href="rust_知识点积累.html">
            
                    
                    Rust 知识点更新
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2.4" data-path="rust_adaptiveservice.html">
            
                <a href="rust_adaptiveservice.html">
            
                    
                    rust版本的adaptiveservice探索
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2.5" data-path="rust_常用设施.html">
            
                <a href="rust_常用设施.html">
            
                    
                    Rust 常用设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2.6" data-path="rust_代码小段.html">
            
                <a href="rust_代码小段.html">
            
                    
                    Rust 代码小段
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2.7" data-path="rust_错误处理.html">
            
                <a href="rust_错误处理.html">
            
                    
                    Rust 错误处理(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="others.html">
            
                <a href="others.html">
            
                    
                    其他
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.3.1" data-path="rust_mdbook_使用.html">
            
                <a href="rust_mdbook_使用.html">
            
                    
                    Rust 使用mdbook
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="as_title_scripts.html">
            
                <a href="as_title_scripts.html">
            
                    
                    脚本
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="shell_变量.html">
            
                <a href="shell_变量.html">
            
                    
                    shell变量
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="shell_基础篇.html">
            
                <a href="shell_基础篇.html">
            
                    
                    shell命令和脚本记录-基础篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="shell_高级篇.html">
            
                <a href="shell_高级篇.html">
            
                    
                    shell命令和脚本记录-高级篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="shell_脚本片段.html">
            
                <a href="shell_脚本片段.html">
            
                    
                    shell脚本片段
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="python_记录.html">
            
                <a href="python_记录.html">
            
                    
                    python记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="lua_记录.html">
            
                <a href="lua_记录.html">
            
                    
                    lua记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="shell_rds脚本阅读.html">
            
                <a href="shell_rds脚本阅读.html">
            
                    
                    RDS脚本阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.8" data-path="Project_Euler.html">
            
                <a href="Project_Euler.html">
            
                    
                    Project Euler
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="as_title_app.html">
            
                <a href="as_title_app.html">
            
                    
                    应用相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="app_sysbench代码分析.html">
            
                <a href="app_sysbench代码分析.html">
            
                    
                    sysbench代码分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="as_title_algorithm.html">
            
                <a href="as_title_algorithm.html">
            
                    
                    算法相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="algorithm_radix_tree.html">
            
                <a href="algorithm_radix_tree.html">
            
                    
                    基数(radix)树(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="as_title_cos.html">
            
                <a href="as_title_cos.html">
            
                    
                    C和Operating System
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="system_libc_part1.html">
            
                <a href="system_libc_part1.html">
            
                    
                    libc概览1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="system_libc_part2.html">
            
                <a href="system_libc_part2.html">
            
                    
                    libc概览2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="system_libc_part3.html">
            
                <a href="system_libc_part3.html">
            
                    
                    libc概览3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="system_原理杂记.html">
            
                <a href="system_原理杂记.html">
            
                    
                    系统原理杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" data-path="system_alpine.html">
            
                <a href="system_alpine.html">
            
                    
                    Alpine Linux
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" data-path="system_进程间通信.html">
            
                <a href="system_进程间通信.html">
            
                    
                    进程间通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.7" data-path="system_特殊功能fd.html">
            
                <a href="system_特殊功能fd.html">
            
                    
                    eventfd timerfd signalfd和fd共享
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8" data-path="c_automake_autoconf.html">
            
                <a href="c_automake_autoconf.html">
            
                    
                    automake autoconf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.9" data-path="makefile_原理和实践.html">
            
                <a href="makefile_原理和实践.html">
            
                    
                    makefile
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.10" data-path="c_编程杂记高级篇.html">
            
                <a href="c_编程杂记高级篇.html">
            
                    
                    C编程杂记高级篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.11" data-path="c_编程杂记基础篇.html">
            
                <a href="c_编程杂记基础篇.html">
            
                    
                    C编程杂记基础篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.12" data-path="c_networking_socket高阶用法.html">
            
                <a href="c_networking_socket高阶用法.html">
            
                    
                    网络编程: Advanced Socket Topics(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.13" data-path="c_protobuf介绍.html">
            
                <a href="c_protobuf介绍.html">
            
                    
                    序列化: protobuf介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.14" data-path="c_进程间通信_共享文件和共享内存.html">
            
                <a href="c_进程间通信_共享文件和共享内存.html">
            
                    
                    进程间通信: 共享文件和共享内存(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.15" data-path="c_pthread_condition和mutex.html">
            
                <a href="c_pthread_condition和mutex.html">
            
                    
                    并发 任务 事件 和锁.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.16" data-path="kernel_user_space_howto.html">
            
                <a href="kernel_user_space_howto.html">
            
                    
                    kernel space和user space交互(网摘, linux2.6)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.17" data-path="CentOS_系统性能优化配置.html">
            
                <a href="CentOS_系统性能优化配置.html">
            
                    
                    CentOS 性能优化系统配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.18" data-path="OS_gentoo使用.html">
            
                <a href="OS_gentoo使用.html">
            
                    
                    gentoo使用记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="as_title_driver.html">
            
                <a href="as_title_driver.html">
            
                    
                    内核 设备和驱动相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="device_driver_地址空间类型和DMA.html">
            
                <a href="device_driver_地址空间类型和DMA.html">
            
                    
                    地址空间类型和DMA
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="platform_device_driver.html">
            
                <a href="platform_device_driver.html">
            
                    
                    平台驱动杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3" data-path="platform_device_driver2.html">
            
                <a href="platform_device_driver2.html">
            
                    
                    平台驱动杂记2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.4" data-path="device_driver_pci驱动概述.html">
            
                <a href="device_driver_pci驱动概述.html">
            
                    
                    pci驱动概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.5" data-path="device_driver_内核中的时间和延迟操作.html">
            
                <a href="device_driver_内核中的时间和延迟操作.html">
            
                    
                    内核中的时间和延迟操作
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.6" data-path="device_driver_杂记.html">
            
                <a href="device_driver_杂记.html">
            
                    
                    驱动调试杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.7" data-path="device_localbus_16bit读写.html">
            
                <a href="device_localbus_16bit读写.html">
            
                    
                    CPLD做8bit到16bit转换
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.8" data-path="driver_位域和大小端.html">
            
                <a href="driver_位域和大小端.html">
            
                    
                    位域和大小端
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.9" data-path="as_title_driver1.html">
            
                <a href="as_title_driver1.html">
            
                    
                    nand
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.9.1" data-path="device_driver_octeon_nand.html">
            
                <a href="device_driver_octeon_nand.html">
            
                    
                    octeon nand flash驱动
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.9.2" data-path="device_driver_nand概率写失败问题分析.html">
            
                <a href="device_driver_nand概率写失败问题分析.html">
            
                    
                    Nand flash概率写失败问题分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.10" data-path="octeon_remote_pci.html">
            
                <a href="octeon_remote_pci.html">
            
                    
                    octeon remote-pci.c阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.11" data-path="Device_VFIO_notes.html">
            
                <a href="Device_VFIO_notes.html">
            
                    
                    VFIO简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12" data-path="as_title_driver2.html">
            
                <a href="as_title_driver2.html">
            
                    
                    智能网卡和DPDK
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.12.1" data-path="smartNIC_智能网卡对比.html">
            
                <a href="smartNIC_智能网卡对比.html">
            
                    
                    智能网卡对比
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12.2" data-path="octeon_pci_NIC.html">
            
                <a href="octeon_pci_NIC.html">
            
                    
                    octeon PCI NIC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12.3" data-path="as_title_driver3.html">
            
                <a href="as_title_driver3.html">
            
                    
                    octeon liquidIO
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.12.3.1" data-path="smartNIC_liquidIO_代码阅读app篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读app篇.html">
            
                    
                    PCI-NIC 代码阅读 --app篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12.3.2" data-path="smartNIC_liquidIO_代码阅读api篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读api篇.html">
            
                    
                    PCI-NIC 代码阅读 --api篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12.3.3" data-path="smartNIC_liquidIO_代码阅读driver篇之结构体.html">
            
                <a href="smartNIC_liquidIO_代码阅读driver篇之结构体.html">
            
                    
                    PCI-NIC 代码阅读 --driver篇之结构体
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12.3.4" data-path="smartNIC_liquidIO_代码阅读driver篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读driver篇.html">
            
                    
                    PCI-NIC 代码阅读 --driver篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12.3.5" data-path="smartNIC_liquidIO_代码阅读真NIC篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读真NIC篇.html">
            
                    
                    PCI-NIC 代码阅读 --真NIC篇
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.12.4" data-path="networking_dpdk使用_2014.html">
            
                <a href="networking_dpdk使用_2014.html">
            
                    
                    DPDK使用(2014)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.13" data-path="device_nvme要点介绍.html">
            
                <a href="device_nvme要点介绍.html">
            
                    
                    nvme要点介绍
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="as_title_cpu.html">
            
                <a href="as_title_cpu.html">
            
                    
                    CPU Arch相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.17.1" data-path="CPU_interconnection_networks.html">
            
                <a href="CPU_interconnection_networks.html">
            
                    
                    CPU核互联模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.2" data-path="cache_CPU和cache一致性原理.html">
            
                <a href="cache_CPU和cache一致性原理.html">
            
                    
                    CPU和cache一致性原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3" data-path="as_title_cpu1.html">
            
                <a href="as_title_cpu1.html">
            
                    
                    ARM64
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.17.3.1" data-path="CPU_ARM64_知识杂记.html">
            
                <a href="CPU_ARM64_知识杂记.html">
            
                    
                    aarch64架构知识杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.2" data-path="CPU_ARM64_thunder_overview.html">
            
                <a href="CPU_ARM64_thunder_overview.html">
            
                    
                    thunder 概览
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.3" data-path="CPU_ARM64_thunder_开发板操作记录.html">
            
                <a href="CPU_ARM64_thunder_开发板操作记录.html">
            
                    
                    thunder 开发板操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.4" data-path="CPU_ARM64_thunder_bdk.html">
            
                <a href="CPU_ARM64_thunder_bdk.html">
            
                    
                    thunder BDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.5" data-path="CPU_ARM64_thunder_efi_rtc.html">
            
                <a href="CPU_ARM64_thunder_efi_rtc.html">
            
                    
                    thunder RTC时间和efi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.6" data-path="CPU_ARM64_thunder_uefi_fdt.html">
            
                <a href="CPU_ARM64_thunder_uefi_fdt.html">
            
                    
                    thunder uefi和fdt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.7" data-path="CPU_ARM64_thunder_atf.html">
            
                <a href="CPU_ARM64_thunder_atf.html">
            
                    
                    thunder atf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.3.8" data-path="CPU_ARM64_thunder_kernel_boot.html">
            
                <a href="CPU_ARM64_thunder_kernel_boot.html">
            
                    
                    thunder kernel启动打印流程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17.4" data-path="as_title_cpu2.html">
            
                <a href="as_title_cpu2.html">
            
                    
                    PPC
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.17.4.1" data-path="CPU_PPC启动多核Linux_流程和内存映射.html">
            
                <a href="CPU_PPC启动多核Linux_流程和内存映射.html">
            
                    
                    PPC启动多核linux: 流程和内存映射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.4.2" data-path="CPU_PPC_kernel升级记录.html">
            
                <a href="CPU_PPC_kernel升级记录.html">
            
                    
                    PPC kernel升级记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17.5" data-path="as_title_cpu3.html">
            
                <a href="as_title_cpu3.html">
            
                    
                    MIPS
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.17.5.1" data-path="CPU_MIPS_octeon地址空间和寄存器访问.html">
            
                <a href="CPU_MIPS_octeon地址空间和寄存器访问.html">
            
                    
                    octeon 地址空间和寄存器访问
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.2" data-path="CPU_MIPS_octeon操作记录.html">
            
                <a href="CPU_MIPS_octeon操作记录.html">
            
                    
                    octeon 操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.3" data-path="CPU_MIPS_octeon_包处理性能.html">
            
                <a href="CPU_MIPS_octeon_包处理性能.html">
            
                    
                    octeon 系列处理器包处理性能
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.4" data-path="CPU_MIPS_octeon_ddr调试记录.html">
            
                <a href="CPU_MIPS_octeon_ddr调试记录.html">
            
                    
                    octeon DDR调试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.5" data-path="CPU_MIPS_octeon_BDK.html">
            
                <a href="CPU_MIPS_octeon_BDK.html">
            
                    
                    octeon CN78xx BDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.6" data-path="kernel_增加ECC中断.html">
            
                <a href="kernel_增加ECC中断.html">
            
                    
                    octeon 增加ECC中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.7" data-path="CPU_MIPS_octeon_hw-ddr2代码走读.html">
            
                <a href="CPU_MIPS_octeon_hw-ddr2代码走读.html">
            
                    
                    octeon hw-ddr2代码走读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.8" data-path="CPU_MIPS_octeon_reboot调试和ddr中断.html">
            
                <a href="CPU_MIPS_octeon_reboot调试和ddr中断.html">
            
                    
                    octeon reboot调试和DDR中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.9" data-path="CPU_MIPS_octeon中断.html">
            
                <a href="CPU_MIPS_octeon中断.html">
            
                    
                    octeon 中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.10" data-path="CPU_MIPS_octeon原子操作.html">
            
                <a href="CPU_MIPS_octeon原子操作.html">
            
                    
                    octeon 原子操作
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17.5.11" data-path="CPU_MIPS_octeon网口代码分析.html">
            
                <a href="CPU_MIPS_octeon网口代码分析.html">
            
                    
                    octeon 网口代码分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >优化linux网络栈: 发送路径(网摘)</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#general-advice-on-monitoring-and-tuning-the-linux-networking-stack"><b>1. </b>General advice on monitoring and tuning the Linux networking stack</a></li><li><span class="title-icon "></span><a href="#overview"><b>2. </b>Overview</a></li><li><span class="title-icon "></span><a href="#detailed-look"><b>3. </b>Detailed Look</a></li><ul><li><span class="title-icon "></span><a href="#protocol-family-registration"><b>3.1. </b>Protocol family registration</a></li><li><span class="title-icon "></span><a href="#sending-network-data-via-a-socket"><b>3.2. </b>Sending network data via a socket</a></li><ul><li><span class="title-icon "></span><a href="#socksendmsg-socksendmsg-and-socksendmsgnosec"><b>3.2.1. </b>sock_sendmsg, __sock_sendmsg, and __sock_sendmsg_nosec</a></li><li><span class="title-icon "></span><a href="#inetsendmsg"><b>3.2.2. </b>inet_sendmsg</a></li></ul><li><span class="title-icon "></span><a href="#udp-protocol-layer"><b>3.3. </b>UDP protocol layer</a></li><ul><li><span class="title-icon "></span><a href="#udpsendmsg"><b>3.3.1. </b>udp_sendmsg</a></li><li><span class="title-icon "></span><a href="#udpsendskb"><b>3.3.2. </b>udp_send_skb</a></li><li><span class="title-icon "></span><a href="#monitoring-udp-protocol-layer-statistics"><b>3.3.3. </b>Monitoring: UDP protocol layer statistics</a></li><li><span class="title-icon "></span><a href="#tuning-socket-send-queue-memory"><b>3.3.4. </b>Tuning: Socket send queue memory</a></li></ul><li><span class="title-icon "></span><a href="#ip-protocol-layer"><b>3.4. </b>IP protocol layer</a></li><ul><li><span class="title-icon "></span><a href="#ipsendskb"><b>3.4.1. </b>ip_send_skb</a></li><li><span class="title-icon "></span><a href="#iplocalout-and-iplocalout"><b>3.4.2. </b>ip_local_out and __ip_local_out</a></li><li><span class="title-icon "></span><a href="#netfilter-and-nfhook"><b>3.4.3. </b>netfilter and nf_hook</a></li><li><span class="title-icon "></span><a href="#destination-cache"><b>3.4.4. </b>Destination cache</a></li><li><span class="title-icon "></span><a href="#ipoutput"><b>3.4.5. </b>ip_output</a></li><li><span class="title-icon "></span><a href="#ipfinishoutput"><b>3.4.6. </b>ip_finish_output</a></li><li><span class="title-icon "></span><a href="#ipfinishoutput2"><b>3.4.7. </b>ip_finish_output2</a></li><li><span class="title-icon "></span><a href="#dstneighoutput"><b>3.4.8. </b>dst_neigh_output</a></li><li><span class="title-icon "></span><a href="#neighhhoutput"><b>3.4.9. </b>neigh_hh_output</a></li><li><span class="title-icon "></span><a href="#n-output"><b>3.4.10. </b>n-&gt;output</a></li><li><span class="title-icon "></span><a href="#monitoring-ip-protocol-layer"><b>3.4.11. </b>Monitoring: IP protocol layer</a></li></ul><li><span class="title-icon "></span><a href="#linux-netdevice-subsystem"><b>3.5. </b>Linux netdevice subsystem</a></li><ul><li><span class="title-icon "></span><a href="#linux-traffic-control"><b>3.5.1. </b>Linux traffic control</a></li><li><span class="title-icon "></span><a href="#devqueuexmit-and-devqueuexmit"><b>3.5.2. </b>dev_queue_xmit and __dev_queue_xmit</a></li><li><span class="title-icon "></span><a href="#resuming-devqueuexmit"><b>3.5.3. </b>Resuming __dev_queue_xmit</a></li><li><span class="title-icon "></span><a href="#devxmitskb"><b>3.5.4. </b>__dev_xmit_skb</a></li><li><span class="title-icon "></span><a href="#tuning-transmit-packet-steering-xps"><b>3.5.5. </b>Tuning: Transmit Packet Steering (XPS)</a></li></ul><li><span class="title-icon "></span><a href="#queuing-disciplines"><b>3.6. </b>Queuing disciplines!</a></li><ul><li><span class="title-icon "></span><a href="#qdiscrunbegin-and-qdiscrunend"><b>3.6.1. </b>qdisc_run_begin and qdisc_run_end</a></li><li><span class="title-icon "></span><a href="#qdiscrun"><b>3.6.2. </b>__qdisc_run</a></li><li><span class="title-icon "></span><a href="#qdiscrestart"><b>3.6.3. </b>qdisc_restart</a></li><li><span class="title-icon "></span><a href="#reminder-while-loop-in-qdiscrun"><b>3.6.4. </b>Reminder, while loop in __qdisc_run</a></li><li><span class="title-icon "></span><a href="#finally-time-to-meet-our-friend-devhardstartxmit"><b>3.6.5. </b>Finally time to meet our friend dev_hard_start_xmit</a></li><li><span class="title-icon "></span><a href="#monitoring-qdiscs"><b>3.6.6. </b>Monitoring qdiscs</a></li><li><span class="title-icon "></span><a href="#tuning-qdiscs"><b>3.6.7. </b>Tuning qdiscs</a></li></ul><li><span class="title-icon "></span><a href="#network-device-driver"><b>3.7. </b>Network Device Driver</a></li><ul><li><span class="title-icon "></span><a href="#driver-operations-registration"><b>3.7.1. </b>Driver operations registration</a></li><li><span class="title-icon "></span><a href="#transmit-data-with-ndostartxmit"><b>3.7.2. </b>Transmit data with ndo_start_xmit</a></li><li><span class="title-icon "></span><a href="#igbtxmap"><b>3.7.3. </b>igb_tx_map</a></li><li><span class="title-icon "></span><a href="#transmit-completions"><b>3.7.4. </b>Transmit completions</a></li><li><span class="title-icon "></span><a href="#monitoring-network-devices"><b>3.7.5. </b>Monitoring network devices</a></li><li><span class="title-icon "></span><a href="#monitoring-dynamic-queue-limits"><b>3.7.6. </b>Monitoring dynamic queue limits</a></li><li><span class="title-icon "></span><a href="#tuning-network-devices"><b>3.7.7. </b>Tuning network devices</a></li></ul><li><span class="title-icon "></span><a href="#the-end"><b>3.8. </b>The End</a></li></ul><li><span class="title-icon "></span><a href="#extras"><b>4. </b>Extras</a></li><ul><li><span class="title-icon "></span><a href="#reducing-arp-traffic-msgconfirm"><b>4.1. </b>Reducing ARP traffic (MSG_CONFIRM)</a></li><li><span class="title-icon "></span><a href="#udp-corking_1"><b>4.2. </b>UDP Corking</a></li><li><span class="title-icon "></span><a href="#timestamping"><b>4.3. </b>Timestamping</a></li></ul><li><span class="title-icon "></span><a href="#conclusion"><b>5. </b>Conclusion</a></li><li><span class="title-icon "></span><a href="#help-with-linux-networking-or-other-systems"><b>6. </b>Help with Linux networking or other systems</a></li><li><span class="title-icon "></span><a href="#related-posts"><b>7. </b>Related posts</a></li></ul></div><a href="#general-advice-on-monitoring-and-tuning-the-linux-networking-stack" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><ul>
<li><a href="#general-advice-on-monitoring-and-tuning-the-linux-networking-stack">General advice on monitoring and tuning the Linux networking stack</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#detailed-look">Detailed Look</a><ul>
<li><a href="#protocol-family-registration">Protocol family registration</a></li>
<li><a href="#sending-network-data-via-a-socket">Sending network data via a socket</a><ul>
<li><a href="#sock_sendmsg-__sock_sendmsg-and-__sock_sendmsg_nosec"><code>sock_sendmsg</code>, <code>__sock_sendmsg</code>, and <code>__sock_sendmsg_nosec</code></a></li>
<li><a href="#inet_sendmsg"><code>inet_sendmsg</code></a></li>
</ul>
</li>
<li><a href="#udp-protocol-layer">UDP protocol layer</a><ul>
<li><a href="#udp_sendmsg"><code>udp_sendmsg</code></a><ul>
<li><a href="#udp-corking">UDP corking</a></li>
<li><a href="#get-the-udp-destination-address-and-port">Get the UDP destination address and port</a></li>
<li><a href="#socket-transmit-bookkeeping-and-timestamping">Socket transmit bookkeeping and timestamping</a></li>
<li><a href="#ancillary-messages-via-sendmsg">Ancillary messages, via sendmsg</a></li>
<li><a href="#setting-custom-ip-options">Setting custom IP options</a></li>
<li><a href="#multicast-or-unicast">Multicast or unicast?</a></li>
<li><a href="#routing">Routing</a></li>
<li><a href="#prevent-the-arp-cache-from-going-stale-with-msg_confirm">Prevent the ARP cache from going stale with <code>MSG_CONFIRM</code></a></li>
<li><a href="#fast-path-for-uncorked-udp-sockets-prepare-data-for-transmit">Fast path for uncorked UDP sockets: Prepare data for transmit</a><ul>
<li><a href="#ip_make_skb"><code>ip_make_skb</code></a></li>
<li><a href="#transmit-the-data">Transmit the data!</a></li>
</ul>
</li>
<li><a href="#slow-path-for-corked-udp-sockets-with-no-preexisting-corked-data">Slow path for corked UDP sockets with no preexisting corked data</a><ul>
<li><a href="#ip_append_data"><code>ip_append_data</code></a></li>
<li><a href="#__ip_append_data"><code>__ip_append_data</code></a></li>
<li><a href="#flushing-corked-sockets">Flushing corked sockets</a></li>
</ul>
</li>
<li><a href="#error-accounting">Error accounting</a></li>
</ul>
</li>
<li><a href="#udp_send_skb"><code>udp_send_skb</code></a></li>
<li><a href="#monitoring-udp-protocol-layer-statistics">Monitoring: UDP protocol layer statistics</a><ul>
<li><a href="#procnetsnmp"><code>/proc/net/snmp</code></a></li>
<li><a href="#procnetudp"><code>/proc/net/udp</code></a></li>
</ul>
</li>
<li><a href="#tuning-socket-send-queue-memory">Tuning: Socket send queue memory</a></li>
</ul>
</li>
<li><a href="#ip-protocol-layer">IP protocol layer</a><ul>
<li><a href="#ip_send_skb"><code>ip_send_skb</code></a></li>
<li><a href="#ip_local_out-and-__ip_local_out"><code>ip_local_out</code> and <code>__ip_local_out</code></a></li>
<li><a href="#netfilter-and-nf_hook">netfilter and <code>nf_hook</code></a></li>
<li><a href="#destination-cache">Destination cache</a></li>
<li><a href="#ip_output"><code>ip_output</code></a></li>
<li><a href="#ip_finish_output"><code>ip_finish_output</code></a><ul>
<li><a href="#path-mtu-discovery">Path MTU Discovery</a></li>
</ul>
</li>
<li><a href="#ip_finish_output2"><code>ip_finish_output2</code></a></li>
<li><a href="#dst_neigh_output"><code>dst_neigh_output</code></a></li>
<li><a href="#neigh_hh_output"><code>neigh_hh_output</code></a></li>
<li><a href="#n-output"><code>n-&gt;output</code></a><ul>
<li><a href="#neigh_resolve_output"><code>neigh_resolve_output</code></a></li>
</ul>
</li>
<li><a href="#monitoring-ip-protocol-layer">Monitoring: IP protocol layer</a><ul>
<li><a href="#procnetsnmp-1"><code>/proc/net/snmp</code></a></li>
<li><a href="#procnetnetstat"><code>/proc/net/netstat</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linux-netdevice-subsystem">Linux netdevice subsystem</a><ul>
<li><a href="#linux-traffic-control">Linux traffic control</a></li>
<li><a href="#dev_queue_xmit-and-__dev_queue_xmit"><code>dev_queue_xmit</code> and <code>__dev_queue_xmit</code></a><ul>
<li><a href="#netdev_pick_tx"><code>netdev_pick_tx</code></a></li>
<li><a href="#__netdev_pick_tx"><code>__netdev_pick_tx</code></a><ul>
<li><a href="#transmit-packet-steering-xps">Transmit Packet Steering (XPS)</a></li>
<li><a href="#skb_tx_hash"><code>skb_tx_hash</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resuming-__dev_queue_xmit">Resuming <code>__dev_queue_xmit</code></a></li>
<li><a href="#__dev_xmit_skb"><code>__dev_xmit_skb</code></a></li>
<li><a href="#tuning-transmit-packet-steering-xps">Tuning: Transmit Packet Steering (XPS)</a></li>
</ul>
</li>
<li><a href="#queuing-disciplines">Queuing disciplines!</a><ul>
<li><a href="#qdisc_run_begin-and-qdisc_run_end"><code>qdisc_run_begin</code> and <code>qdisc_run_end</code></a></li>
<li><a href="#__qdisc_run"><code>__qdisc_run</code></a></li>
<li><a href="#qdisc_restart"><code>qdisc_restart</code></a><ul>
<li><a href="#dequeue_skb"><code>dequeue_skb</code></a></li>
<li><a href="#sch_direct_xmit"><code>sch_direct_xmit</code></a></li>
<li><a href="#handle_dev_cpu_collision"><code>handle_dev_cpu_collision</code></a></li>
<li><a href="#dev_requeue_skb"><code>dev_requeue_skb</code></a></li>
</ul>
</li>
<li><a href="#reminder-while-loop-in-__qdisc_run">Reminder, while loop in <code>__qdisc_run</code></a><ul>
<li><a href="#__netif_schedule"><code>__netif_schedule</code></a></li>
<li><a href="#net_tx_action"><code>net_tx_action</code></a><ul>
<li><a href="#net_tx_action-completion-queue"><code>net_tx_action</code> completion queue</a></li>
<li><a href="#net_tx_action-output-queue"><code>net_tx_action</code> output queue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#finally-time-to-meet-our-friend-dev_hard_start_xmit">Finally time to meet our friend <code>dev_hard_start_xmit</code></a></li>
<li><a href="#monitoring-qdiscs">Monitoring qdiscs</a><ul>
<li><a href="#using-the-tc-command-line-tool">Using the <code>tc</code> command line tool</a></li>
</ul>
</li>
<li><a href="#tuning-qdiscs">Tuning qdiscs</a><ul>
<li><a href="#increasing-the-processing-weight-of-__qdisc_run">Increasing the processing weight of <code>__qdisc_run</code></a></li>
<li><a href="#increasing-the-transmit-queue-length">Increasing the transmit queue length</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#network-device-driver">Network Device Driver</a><ul>
<li><a href="#driver-operations-registration">Driver operations registration</a></li>
<li><a href="#transmit-data-with-ndo_start_xmit">Transmit data with <code>ndo_start_xmit</code></a></li>
<li><a href="#igb_tx_map"><code>igb_tx_map</code></a><ul>
<li><a href="#dynamic-queue-limits-dql">Dynamic Queue Limits (DQL)</a></li>
</ul>
</li>
<li><a href="#transmit-completions">Transmit completions</a><ul>
<li><a href="#transmit-completion-irq">Transmit completion IRQ</a></li>
<li><a href="#igb_poll"><code>igb_poll</code></a></li>
<li><a href="#igb_clean_tx_irq"><code>igb_clean_tx_irq</code></a></li>
<li><a href="#igb_poll-return-value"><code>igb_poll</code> return value</a></li>
</ul>
</li>
<li><a href="#monitoring-network-devices">Monitoring network devices</a><ul>
<li><a href="#using-ethtool--s">Using <code>ethtool -S</code></a></li>
<li><a href="#using-sysfs">Using sysfs</a></li>
<li><a href="#using-procnetdev">Using <code>/proc/net/dev</code></a></li>
</ul>
</li>
<li><a href="#monitoring-dynamic-queue-limits">Monitoring dynamic queue limits</a></li>
<li><a href="#tuning-network-devices">Tuning network devices</a><ul>
<li><a href="#check-the-number-of-tx-queues-being-used">Check the number of TX queues being used</a></li>
<li><a href="#adjust-the-number-of-tx-queues-used">Adjust the number of TX queues used</a></li>
<li><a href="#adjust-the-size-of-the-tx-queues">Adjust the size of the TX queues</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-end">The End</a></li>
</ul>
</li>
<li><a href="#extras">Extras</a><ul>
<li><a href="#reducing-arp-traffic-msg_confirm">Reducing ARP traffic (<code>MSG_CONFIRM</code>)</a></li>
<li><a href="#udp-corking-1">UDP Corking</a></li>
<li><a href="#timestamping">Timestamping</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#help-with-linux-networking-or-other-systems">Help with Linux networking or other systems</a></li>
<li><a href="#related-posts">Related posts</a></li>
</ul>
<p><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/" target="_blank">&#x539F;&#x6587;&#x94FE;&#x63A5;</a></p>
<p>This blog post explains how computers running the Linux kernel send packets, as well as how to monitor and tune each component of the networking stack as packets flow from user programs to network hardware.</p>
<p>This post forms a pair with our previous post <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a>.</p>
<p>It is impossible to tune or monitor the Linux networking stack without reading the source code of the kernel and having a deep understanding of what exactly is happening.</p>
<p>This blog post will hopefully serve as a reference to anyone looking to do this.</p>
<h1 id="general-advice-on-monitoring-and-tuning-the-linux-networking-stack"><a name="general-advice-on-monitoring-and-tuning-the-linux-networking-stack" class="anchor-navigation-ex-anchor" href="#general-advice-on-monitoring-and-tuning-the-linux-networking-stack"><i class="fa fa-link" aria-hidden="true"></i></a>1. General advice on monitoring and tuning the Linux networking stack</h1>
<p>As mentioned in our previous article, the Linux network stack is complex and there is no one size fits all solution for monitoring or tuning. If you truly want to tune the network stack, you will have no choice but to invest a considerable amount of time, effort, and money into understanding how the various parts of networking system interact.</p>
<p>Many of the example settings provided in this blog post are used solely for illustrative purposes and are not a recommendation for or against a certain configuration or default setting. Before adjusting any setting, you should develop a frame of reference around what you need to be monitoring to notice a meaningful change.</p>
<p>Adjusting networking settings while connected to the machine over a network is dangerous; you could very easily lock yourself out or completely take out your networking. Do not adjust these settings on production machines; instead, make adjustments on new machines and rotate them into production, if possible.</p>
<h1 id="overview"><a name="overview" class="anchor-navigation-ex-anchor" href="#overview"><i class="fa fa-link" aria-hidden="true"></i></a>2. Overview</h1>
<p>For reference, you may want to have a copy of the device data sheet handy. This post will examine the Intel I350 Ethernet controller, controlled by the <code>igb</code> device driver. You can find that data sheet (warning: LARGE PDF) <a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf" target="_blank">here for your reference</a>.</p>
<p>The high-level path network data takes from a user program to a network device is as follows:</p>
<ol>
<li>Data is written using a system call (like <code>sendto</code>, <code>sendmsg</code>, et. al.).</li>
<li>Data passes through the socket subsystem on to the socket&#x2019;s protocol family&#x2019;s system (in our case, <code>AF_INET</code>).</li>
<li>The protocol family passes data through the protocol layers which (in many cases) arrange the data into packets.</li>
<li>The data passes through the routing layer, populating the destination and neighbour caches along the way (if they are cold). This can generate ARP traffic if an ethernet address needs to be looked up.</li>
<li>After passing through the protocol layers, packets reach the device agnostic layer.</li>
<li>The output queue is chosen using XPS (if enabled) or a hash function.</li>
<li>The device driver&#x2019;s transmit function is called.</li>
<li>The data is then passed on to the queue discipline (qdisc) attached to the output device.</li>
<li>The qdisc will either transmit the data directly if it can, or queue it up to be sent during the <code>NET_TX</code> softirq.</li>
<li>Eventually the data is handed down to the driver from the qdisc.</li>
<li>The driver creates the needed DMA mappings so the device can read the data from RAM.</li>
<li>The driver signals the device that the data is ready to be transmit.</li>
<li>The device fetches the data from RAM and transmits it.</li>
<li>Once transmission is complete, the device raises an interrupt to signal transmit completion.</li>
<li>The driver&#x2019;s registered IRQ handler for transmit completion runs. For many devices, this handler simply triggers the NAPI poll loop to start running via the <code>NET_RX</code> softirq.</li>
<li>The poll function runs via a softIRQ and calls down into the driver to unmap DMA regions and free packet data.</li>
</ol>
<p>This entire flow will be examined in detail in the following sections.</p>
<p>The protocol layers examined below are the IP and UDP protocol layers. Much of the information presented will serve as a reference for other protocol layers, as well.</p>
<h1 id="detailed-look"><a name="detailed-look" class="anchor-navigation-ex-anchor" href="#detailed-look"><i class="fa fa-link" aria-hidden="true"></i></a>3. Detailed Look</h1>
<p>This blog post will be examining the Linux kernel version 3.13.0 with links to code on GitHub and code snippets throughout this post, much like <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank">the companion post</a>.</p>
<p>Let&#x2019;s begin by examining how protocol families are registered in the kernel and used by the socket subsystem, then we can proceed to receiving data.</p>
<h2 id="protocol-family-registration"><a name="protocol-family-registration" class="anchor-navigation-ex-anchor" href="#protocol-family-registration"><i class="fa fa-link" aria-hidden="true"></i></a>3.1. Protocol family registration</h2>
<p>What happens when you run a piece of code like this in a user program to create a UDP socket?</p>
<pre class="language-"><code class="lang-c">sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> IPPROTO_UDP<span class="token punctuation">)</span>
</code></pre>
<p>In short, the Linux kernel looks up a set of functions exported by the UDP protocol stack that deal with many things including sending and receiving network data. To understand exactly how this work, we have to look into the <code>AF_INET</code> address family code.</p>
<p>The Linux kernel executes the <code>inet_init</code> function early during kernel initialization. This function registers the <code>AF_INET</code> protocol family, the individual protocol stacks within that family (TCP, UDP, ICMP, and RAW), and calls initialization routines to get protocol stacks ready to process network data. You can find the code for <code>inet_init</code> in <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L1678-L1804" target="_blank">./net/ipv4/af_inet.c</a>.</p>
<p>The <code>AF_INET</code> protocol family exports a structure that has a <code>create</code> function. This function is called by the kernel when a socket is created from a user program:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> inet_family_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>family <span class="token operator">=</span> PF_INET<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>create <span class="token operator">=</span> inet_create<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>owner  <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>The <code>inet_create</code> function takes the arguments passed to the socket system call and searches the registered protocols to find a set of operations to link to the socket. Take a look:</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* Look for the requested type/protocol pair. */</span>
lookup_protocol<span class="token operator">:</span>
        err <span class="token operator">=</span> <span class="token operator">-</span>ESOCKTNOSUPPORT<span class="token punctuation">;</span>
        <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>sock<span class="token operator">-&gt;</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token comment">/* Check the non-wild match. */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">==</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">!=</span> IPPROTO_IP<span class="token punctuation">)</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        <span class="token comment">/* Check for the two wild cases. */</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                protocol <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                err <span class="token operator">=</span> <span class="token operator">-</span>EPROTONOSUPPORT<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>Later, <code>answer</code> which holds a reference to a particular protocol stack has its <code>ops</code> fields copied into the socket structure:</p>
<pre class="language-"><code class="lang-c">sock<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>ops<span class="token punctuation">;</span>
</code></pre>
<p>You can find the structure definitions for all of the protocol stacks in <code>af_inet.c</code>. Let&#x2019;s take a look at the <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L998-L1020" target="_blank">TCP and UDP protocol structures</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/* Upon startup we insert all the elements in inetsw_array[] into
 * the linked list inetsw.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">inet_protosw</span> inetsw_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>
        <span class="token punctuation">{</span>
                <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_STREAM<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_TCP<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>tcp_prot<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_stream_ops<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>no_check <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">,</span>
                <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT <span class="token operator">|</span>
                              INET_PROTOSW_ICSK<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>

        <span class="token punctuation">{</span>
                <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_DGRAM<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_UDP<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>udp_prot<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_dgram_ops<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>no_check <span class="token operator">=</span>   UDP_CSUM_DEFAULT<span class="token punctuation">,</span>
                <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT<span class="token punctuation">,</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>

            <span class="token comment">/* .... more protocols ... */</span>
</code></pre>
<p>In the case of <code>IPPROTO_UDP</code>, an <code>ops</code> structure is linked into place <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L935-L960" target="_blank">which contains functions for various things</a>, including sending and receiving data:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">proto_ops</span> inet_dgram_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>family           <span class="token operator">=</span> PF_INET<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>owner           <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>

  <span class="token comment">/* ... */</span>

  <span class="token punctuation">.</span>sendmsg       <span class="token operator">=</span> inet_sendmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>recvmsg       <span class="token operator">=</span> inet_recvmsg<span class="token punctuation">,</span>

  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>inet_dgram_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>and a protocol-specific structure <code>prot</code>, which contains function pointers to all the internal UDP protocol stack function. For the UDP protocol, this structure is called <code>udp_prot</code> and is exported by <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L2171-L2203" target="_blank">./net/ipv4/udp.c</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">struct</span> <span class="token class-name">proto</span> udp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name           <span class="token operator">=</span> <span class="token string">&quot;UDP&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>owner           <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>

  <span class="token comment">/* ... */</span>

  <span class="token punctuation">.</span>sendmsg       <span class="token operator">=</span> udp_sendmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>recvmsg       <span class="token operator">=</span> udp_recvmsg<span class="token punctuation">,</span>

  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>udp_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Now, let&#x2019;s turn to a user program that sends UDP data to see how <code>udp_sendmsg</code> is called in the kernel!</p>
<h2 id="sending-network-data-via-a-socket"><a name="sending-network-data-via-a-socket" class="anchor-navigation-ex-anchor" href="#sending-network-data-via-a-socket"><i class="fa fa-link" aria-hidden="true"></i></a>3.2. Sending network data via a socket</h2>
<p>A user program wants to send UDP network data and so it uses the <code>sendto</code> system call, maybe like this:</p>
<pre class="language-"><code class="lang-c">ret <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> buflen<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dest<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This system call passes through the <a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank">Linux system call</a> layer and lands <a href="https://github.com/torvalds/linux/blob/v3.13/net/socket.c#L1756-L1803" target="_blank">in this function</a> in <code>./net/socket.c</code>:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/*
 *      Send a datagram to a given address. We move the address into kernel
 *      space and check the user space data area is readable before invoking
 *      the protocol.
 */</span>

<span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>sendto<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span>
                <span class="token keyword">int</span><span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*  ... code ... */</span>

    err <span class="token operator">=</span> <span class="token function">sock_sendmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* ... code  ... */</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>SYSCALL_DEFINE6</code> macro unfolds <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/syscalls.h#L170-L198" target="_blank">into a pile of macros</a>, which in turn, set up the infrastructure needed to create a system call with 6 arguments (hence <code>DEFINE6</code>). One of the results of this is that inside the kernel, system call function names have <code>sys_</code> prepended to them.</p>
<p>The system call code for <code>sendto</code> calls <code>sock_sendmsg</code> after arranging the data in a way that the lower layers will be able to handle. In particular, it takes the destination address passed into <code>sendto</code> and arranges it into a structure, let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c">  iov<span class="token punctuation">.</span>iov_base <span class="token operator">=</span> buff<span class="token punctuation">;</span>
  iov<span class="token punctuation">.</span>iov_len <span class="token operator">=</span> len<span class="token punctuation">;</span>
  msg<span class="token punctuation">.</span>msg_name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">;</span>
  msg<span class="token punctuation">.</span>msg_iovlen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  msg<span class="token punctuation">.</span>msg_control <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  msg<span class="token punctuation">.</span>msg_controllen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  msg<span class="token punctuation">.</span>msg_namelen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          err <span class="token operator">=</span> <span class="token function">move_addr_to_kernel</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> addr_len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                  <span class="token keyword">goto</span> out_put<span class="token punctuation">;</span>
          msg<span class="token punctuation">.</span>msg_name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">;</span>
          msg<span class="token punctuation">.</span>msg_namelen <span class="token operator">=</span> addr_len<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>This code is copying <code>addr</code>, passed in via the user program into the kernel data structure <code>address</code>, which is then embedded into a <code>struct msghdr</code> structure as <code>msg_name</code>. This is similar to what a userland program would do if it were calling <code>sendmsg</code> instead of <code>sendto</code>. The kernel provides this mutation because both <code>sendto</code> and <code>sendmsg</code> do call down to <code>sock_sendmsg</code>.</p>
<h3 id="socksendmsg-socksendmsg-and-socksendmsgnosec"><a name="socksendmsg-socksendmsg-and-socksendmsgnosec" class="anchor-navigation-ex-anchor" href="#socksendmsg-socksendmsg-and-socksendmsgnosec"><i class="fa fa-link" aria-hidden="true"></i></a>3.2.1. sock_sendmsg, __sock_sendmsg, and __sock_sendmsg_nosec</h3>
<p><code>sock_sendmsg</code> performs some error checking before calling <code>__sock_sendmsg</code> does its own error checking before calling <code>__sock_sendmsg_nosec</code>. <code>__sock_sendmsg_nosec</code> passes the data deeper into the socket subsystem:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__sock_sendmsg_nosec</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span>
                                       <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sock_iocb</span> <span class="token operator">*</span>si <span class="token operator">=</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

                <span class="token comment">/* other code ... */</span>

        <span class="token keyword">return</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As seen in the previous section explaining socket creation, the <code>sendmsg</code> function registered to this socket ops structure is <code>inet_sendmsg</code>.</p>
<h3 id="inetsendmsg"><a name="inetsendmsg" class="anchor-navigation-ex-anchor" href="#inetsendmsg"><i class="fa fa-link" aria-hidden="true"></i></a>3.2.2. inet_sendmsg</h3>
<p>As you may have guessed from the name, this is a generic function provided by the <code>AF_INET</code> protocol family. This function starts by calling <code>sock_rps_record_flow</code> to record the last CPU that the flow was processed on; this is used by <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#receive-packet-steering-rps" target="_blank">Receive Packet Steering</a>. Next, this function looks up the <code>sendmsg</code> function on the socket&#x2019;s internal protocol operations structure and calls it:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">inet_sendmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span>
                 <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>

  <span class="token function">sock_rps_record_flow</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* We may need to bind the socket. */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>inet_num <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span>no_autobind <span class="token operator">&amp;&amp;</span>
      <span class="token function">inet_autobind</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>

  <span class="token keyword">return</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>inet_sendmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>When dealing with UDP, <code>sk-&gt;sk_prot-&gt;sendmsg</code> above is <code>udp_sendmsg</code> as exported by the UDP protocol layer, via the <code>udp_prot</code> structure we saw earlier. This function call transitions from the generic <code>AF_INET</code> protocol family on to the UDP protocol stack.</p>
<h2 id="udp-protocol-layer"><a name="udp-protocol-layer" class="anchor-navigation-ex-anchor" href="#udp-protocol-layer"><i class="fa fa-link" aria-hidden="true"></i></a>3.3. UDP protocol layer</h2>
<h3 id="udpsendmsg"><a name="udpsendmsg" class="anchor-navigation-ex-anchor" href="#udpsendmsg"><i class="fa fa-link" aria-hidden="true"></i></a>3.3.1. udp_sendmsg</h3>
<p>The <code>udp_sendmsg</code> function can be found in <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L845-L1088" target="_blank">./net/ipv4/udp.c</a>. The entire function is quite long, so we&#x2019;ll examine pieces of it below. Follow the previous link if you&#x2019;d like to read it in its entirety.</p>
<h4 id="udp-corking"><a name="udp-corking" class="anchor-navigation-ex-anchor" href="#udp-corking"><i class="fa fa-link" aria-hidden="true"></i></a>UDP corking</h4>
<p>After variable declarations and some basic error checking, one of the first things <code>udp_sendmsg</code> does is check if the socket is &#x201C;corked&#x201D;. UDP corking is a feature that allows a user program request that the kernel accumulate data from multiple calls to <code>send</code> into a single datagram before sending. There are two ways to enable this option in your user program:</p>
<ol>
<li>Use the <code>setsockopt</code> system call and pass <code>UDP_CORK</code> as the socket option.</li>
<li>Pass <code>MSG_MORE</code> as one of the <code>flags</code> when calling <code>send</code>, <code>sendto</code>, or <code>sendmsg</code> from your program.</li>
</ol>
<p>These options are documented in the <a href="http://man7.org/linux/man-pages/man7/udp.7.html" target="_blank">UDP man page</a> and the <a href="http://man7.org/linux/man-pages/man2/send.2.html" target="_blank">send / sendto / sendmsg man page</a>, respectively.</p>
<p>The code from <code>udp_sendmsg</code> checks <code>up-&gt;pending</code> to determine if the socket is currently corked, and if so, it proceeds directly to appending data. We&#x2019;ll see how data is appended later.</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">udp_sendmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span>
                <span class="token class-name">size_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token comment">/* variables and error checking ... */</span>

  fl4 <span class="token operator">=</span> <span class="token operator">&amp;</span>inet<span class="token operator">-&gt;</span>cork<span class="token punctuation">.</span>fl<span class="token punctuation">.</span>u<span class="token punctuation">.</span>ip4<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>up<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">/*
           * There are pending frames.
           * The socket lock must be held while it&apos;s corked.
           */</span>
          <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>up<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>up<span class="token operator">-&gt;</span>pending <span class="token operator">!=</span> AF_INET<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                          <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
                          <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                  <span class="token punctuation">}</span>
                  <span class="token keyword">goto</span> do_append_data<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<h4 id="get-the-udp-destination-address-and-port"><a name="get-the-udp-destination-address-and-port" class="anchor-navigation-ex-anchor" href="#get-the-udp-destination-address-and-port"><i class="fa fa-link" aria-hidden="true"></i></a>Get the UDP destination address and port</h4>
<p>Next, the destination address and port are determined from one of two possible sources:</p>
<ol>
<li>The socket itself has the destination address stored because the socket was connected at some point.</li>
<li>The address is passed in via an auxiliary structure, as we saw in the kernel code for <code>sendto</code>.</li>
</ol>
<p>Here&#x2019;s how the kernel deals with this:</p>
<pre class="language-"><code class="lang-c">  <span class="token comment">/*
   *      Get and verify the address.
   */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token operator">-&gt;</span>msg_name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span>usin <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span><span class="token punctuation">)</span>msg<span class="token operator">-&gt;</span>msg_name<span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token operator">-&gt;</span>msg_namelen <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>usin<span class="token punctuation">)</span><span class="token punctuation">)</span>
                  <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>usin<span class="token operator">-&gt;</span>sin_family <span class="token operator">!=</span> AF_INET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>usin<span class="token operator">-&gt;</span>sin_family <span class="token operator">!=</span> AF_UNSPEC<span class="token punctuation">)</span>
                          <span class="token keyword">return</span> <span class="token operator">-</span>EAFNOSUPPORT<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          daddr <span class="token operator">=</span> usin<span class="token operator">-&gt;</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token punctuation">;</span>
          dport <span class="token operator">=</span> usin<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>dport <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                  <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_ESTABLISHED<span class="token punctuation">)</span>
                  <span class="token keyword">return</span> <span class="token operator">-</span>EDESTADDRREQ<span class="token punctuation">;</span>
          daddr <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">;</span>
          dport <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_dport<span class="token punctuation">;</span>
          <span class="token comment">/* Open fast path for connected socket.
             Route will not be used, if at least one option is set.
           */</span>
          connected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>Yes, that is a <code>TCP_ESTABLISHED</code> in the UDP protocol layer! The socket states for better or worse use TCP state descriptions.</p>
<p>Recall earlier that we saw how the kernel arranges a <code>struct msghdr</code> structure on behalf of the user when the user program calls <code>sendto</code>. The code above shows how the kernel parses that data back out in order to set <code>daddr</code> and <code>dport</code>.</p>
<p>If the <code>udp_sendmsg</code> function was reached by kernel function which did <em>not</em> arrange a <code>struct msghdr</code> structure, the destination address and port are retrieved from the socket itself and the socket is marked as &#x201C;connected.&#x201D;</p>
<p>In either case <code>daddr</code> and <code>dport</code> will be set to the destination address and port.</p>
<h4 id="socket-transmit-bookkeeping-and-timestamping"><a name="socket-transmit-bookkeeping-and-timestamping" class="anchor-navigation-ex-anchor" href="#socket-transmit-bookkeeping-and-timestamping"><i class="fa fa-link" aria-hidden="true"></i></a>Socket transmit bookkeeping and timestamping</h4>
<p>Next, the source address, device index, and any timestamping options which were set on the socket (like <code>SOCK_TIMESTAMPING_TX_HARDWARE</code>, <code>SOCK_TIMESTAMPING_TX_SOFTWARE</code>, <code>SOCK_WIFI_STATUS</code>) are retrieved and stored:</p>
<pre class="language-"><code class="lang-c">ipc<span class="token punctuation">.</span>addr <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">;</span>

ipc<span class="token punctuation">.</span>oif <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_bound_dev_if<span class="token punctuation">;</span>

<span class="token function">sock_tx_timestamp</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ipc<span class="token punctuation">.</span>tx_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="ancillary-messages-via-sendmsg"><a name="ancillary-messages-via-sendmsg" class="anchor-navigation-ex-anchor" href="#ancillary-messages-via-sendmsg"><i class="fa fa-link" aria-hidden="true"></i></a>Ancillary messages, via sendmsg</h4>
<p>The <code>sendmsg</code> and <code>recvmsg</code> system calls allow the user to set or request ancillary data in addition to sending or receiving packets. User programs can make use of this ancillary data by crafting a <code>struct msghdr</code> with the request embedded in it. Many of the ancillary data types are documented in the <a href="http://man7.org/linux/man-pages/man7/ip.7.html" target="_blank">man page for IP</a>.</p>
<p>One popular example of ancillary data is <code>IP_PKTINFO</code>. In the case of <code>sendmsg</code> this data type allows the program to set a <code>struct in_pktinfo</code> to be used when sending data. The program can specify the source address to be used on the packet by filling in fields in the <code>struct in_pktinfo</code> structure. This is a useful option if the program is a server program listening on multiple IP addresses. In this case, the server program may want to reply to the client with the same IP address that the client used to contact the server. <code>IP_PKTINFO</code> enables precisely this use case.</p>
<p>Similarly, the <code>IP_TTL</code> and <code>IP_TOS</code> ancillary messages allow the user to set the IP packet <a href="https://en.wikipedia.org/wiki/Time_to_live#IP_packets" target="_blank">TTL</a> and <a href="https://en.wikipedia.org/wiki/Type_of_service" target="_blank">TOS</a> values on a per-packet basis, when passed with data to <code>sendmsg</code> from the user program. Note that both <code>IP_TTL</code> and <code>IP_TOS</code> may be set at the socket level for all outgoing packets by using <code>setsockopt</code>, instead of on a per-packet basis if desired. The Linux kernel translates the TOS value specified to a priority <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L179-L197" target="_blank">using an array</a>. The priority affects how and when a packet is transmit from a queuing discipline. We&#x2019;ll see more about what this means later.</p>
<p>We can see how the kernel handles ancillary messages for <code>sendmsg</code> on UDP sockets:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token operator">-&gt;</span>msg_controllen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token function">ip_cmsg_send</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ipc<span class="token punctuation">,</span>
                           sk<span class="token operator">-&gt;</span>sk_family <span class="token operator">==</span> AF_INET6<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                <span class="token keyword">return</span> err<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ipc<span class="token punctuation">.</span>opt<span class="token punctuation">)</span>
                free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        connected <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The internals of parsing the ancillary messages is handled by <code>ip_cmsg_send</code> from <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/ip_sockglue.c#L190-L241" target="_blank">./net/ipv4/ip_sockglue.c</a>. Note that simply providing any ancillary data marks this socket as not connected.</p>
<h4 id="setting-custom-ip-options"><a name="setting-custom-ip-options" class="anchor-navigation-ex-anchor" href="#setting-custom-ip-options"><i class="fa fa-link" aria-hidden="true"></i></a>Setting custom IP options</h4>
<p>Next, <code>sendmsg</code> will check to see if the user specified any custom IP options with ancillary messages. If options were set, they will be used. If not, the options already in use by this socket will be used:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipc<span class="token punctuation">.</span>opt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">ip_options_rcu</span> <span class="token operator">*</span>inet_opt<span class="token punctuation">;</span>

        <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inet_opt <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_opt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>inet_opt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>opt_copy<span class="token punctuation">,</span> inet_opt<span class="token punctuation">,</span>
                       <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>inet_opt<span class="token punctuation">)</span> <span class="token operator">+</span> inet_opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>optlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ipc<span class="token punctuation">.</span>opt <span class="token operator">=</span> <span class="token operator">&amp;</span>opt_copy<span class="token punctuation">.</span>opt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Next up, the function checks to see if the source record route (SRR) IP option is set. There are two types of source record routing: <a href="https://en.wikipedia.org/wiki/Loose_Source_Routing" target="_blank">loose and strict source record routing</a>. If this option was set, the first hop address is recorded and stored as <code>faddr</code> and the socket is marked as &#x201C;not connected&#x201D;. This will be used later:</p>
<pre class="language-"><code class="lang-c">ipc<span class="token punctuation">.</span>addr <span class="token operator">=</span> faddr <span class="token operator">=</span> daddr<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>ipc<span class="token punctuation">.</span>opt <span class="token operator">&amp;&amp;</span> ipc<span class="token punctuation">.</span>opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>srr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>daddr<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
        faddr <span class="token operator">=</span> ipc<span class="token punctuation">.</span>opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>faddr<span class="token punctuation">;</span>
        connected <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>After the SRR option is handled, the TOS IP flag is retrieved either from the value the user set via an ancillary message or the value currently in use by the socket. Followed by a check to determine if:</p>
<ul>
<li><code>SO_DONTROUTE</code> was set on the socket (with <code>setsockopt</code>), or</li>
<li><code>MSG_DONTROUTE</code> was specified as a flag when calling <code>sendto</code> or <code>sendmsg</code>, or</li>
<li><code>is_strictroute</code> was set, indicating that strict <a href="http://www.networksorcery.com/enp/protocol/ip/option009.htm" target="_blank">source record routing</a> is desired</li>
</ul>
<p>Then, the <code>tos</code> has <code>0x1</code> (<code>RTO_ONLINK</code>) added to its bit set and the socket is considered not &#x201C;connected&#x201D;:</p>
<pre class="language-"><code class="lang-c">tos <span class="token operator">=</span> <span class="token function">get_rttos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ipc<span class="token punctuation">,</span> inet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sock_flag</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_LOCALROUTE<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>msg<span class="token operator">-&gt;</span>msg_flags <span class="token operator">&amp;</span> MSG_DONTROUTE<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>ipc<span class="token punctuation">.</span>opt <span class="token operator">&amp;&amp;</span> ipc<span class="token punctuation">.</span>opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>is_strictroute<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tos <span class="token operator">|=</span> RTO_ONLINK<span class="token punctuation">;</span>
        connected <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="multicast-or-unicast"><a name="multicast-or-unicast" class="anchor-navigation-ex-anchor" href="#multicast-or-unicast"><i class="fa fa-link" aria-hidden="true"></i></a>Multicast or unicast?</h4>
<p>Next, the code attempts to deal with multicast. This is a bit tricky, as the user could specify an alternate source address or device index of where to send the packet from by sending an ancillary <code>IP_PKTINFO</code> message, as explained earlier.</p>
<p>If the destination address is a multicast address:</p>
<ol>
<li>The device index of where to write the packet will be set to the multicast device index, and</li>
<li>The source address on the packet will be set to the multicast source address.</li>
</ol>
<p>Unless, the user has not overridden the device index by sending the <code>IP_PKTINFO</code> ancillary message. Let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ipv4_is_multicast</span><span class="token punctuation">(</span>daddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipc<span class="token punctuation">.</span>oif<span class="token punctuation">)</span>
                ipc<span class="token punctuation">.</span>oif <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>mc_index<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>saddr<span class="token punctuation">)</span>
                saddr <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>mc_addr<span class="token punctuation">;</span>
        connected <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipc<span class="token punctuation">.</span>oif<span class="token punctuation">)</span>
        ipc<span class="token punctuation">.</span>oif <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>uc_index<span class="token punctuation">;</span>
</code></pre>
<p>If the destination address is not a multicast address, the device index is set unless it was overridden by the user with <code>IP_PKTINFO</code>.</p>
<h4 id="routing"><a name="routing" class="anchor-navigation-ex-anchor" href="#routing"><i class="fa fa-link" aria-hidden="true"></i></a>Routing</h4>
<p>Now it&#x2019;s time for routing!</p>
<p>The code in the UDP layer that deals with routing begins with a fast path. If the socket is connected try to get the routing structure:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>connected<span class="token punctuation">)</span>
        rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>If the socket was not connected, or if it was but the routing helper <code>sk_dst_check</code> decided the route was obsolete the code moves into the slow path to generate a routing structure. This begins by calling <code>flowi4_init_output</code> to construct a structure describing this UDP flow:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

        fl4 <span class="token operator">=</span> <span class="token operator">&amp;</span>fl4_stack<span class="token punctuation">;</span>
        <span class="token function">flowi4_init_output</span><span class="token punctuation">(</span>fl4<span class="token punctuation">,</span> ipc<span class="token punctuation">.</span>oif<span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_mark<span class="token punctuation">,</span> tos<span class="token punctuation">,</span>
                           RT_SCOPE_UNIVERSE<span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_protocol<span class="token punctuation">,</span>
                           <span class="token function">inet_sk_flowi_flags</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">|</span>FLOWI_FLAG_CAN_SLEEP<span class="token punctuation">,</span>
                           faddr<span class="token punctuation">,</span> saddr<span class="token punctuation">,</span> dport<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Once this flow structure has been constructed, the socket and its flow structure are passed along to the security subsystem so that systems like <a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux" target="_blank">SELinux</a> or <a href="https://en.wikipedia.org/wiki/Smack_(software" target="_blank">SMACK</a>) can set a security id value on the flow structure. Next, <code>ip_route_output_flow</code> will call into the IP routing code to generate a routing structure for this flow:</p>
<pre class="language-"><code class="lang-c"><span class="token function">security_sk_classify_flow</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">flowi4_to_flowi</span><span class="token punctuation">(</span>fl4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rt <span class="token operator">=</span> <span class="token function">ip_route_output_flow</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>If a routing structure could not be generated and the error was <code>ENETUNREACH</code>, the <code>OUTNOROUTES</code> statistic counter is incremented.</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  err <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  rt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token operator">-</span>ENETUNREACH<span class="token punctuation">)</span>
    <span class="token function">IP_INC_STATS</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> IPSTATS_MIB_OUTNOROUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The location of the file holding these statistics counter and the other available counters and their meanings will be discussed below in the UDP monitoring section.</p>
<p>Next, if the route is for broadcast, but the socket option <code>SOCK_BROADCAST</code> was not set on the socket the code terminates. If the socket is considered &#x201C;connected&#x201D; (as described throughout this function), the routing structure is cached on the socket:</p>
<pre class="language-"><code class="lang-c">err <span class="token operator">=</span> <span class="token operator">-</span>EACCES<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rt<span class="token operator">-&gt;</span>rt_flags <span class="token operator">&amp;</span> RTCF_BROADCAST<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">sock_flag</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_BROADCAST<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>connected<span class="token punctuation">)</span>
        <span class="token function">sk_dst_set</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">dst_clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="prevent-the-arp-cache-from-going-stale-with-msgconfirm"><a name="prevent-the-arp-cache-from-going-stale-with-msgconfirm" class="anchor-navigation-ex-anchor" href="#prevent-the-arp-cache-from-going-stale-with-msgconfirm"><i class="fa fa-link" aria-hidden="true"></i></a>Prevent the ARP cache from going stale with <code>MSG_CONFIRM</code></h4>
<p>If the user specified the <code>MSG_CONFIRM</code> flag when calling <code>send</code>, <code>sendto</code>, or <code>sendmsg</code>, the UDP protocol layer will now handle that:</p>
<pre class="language-"><code class="lang-c">  <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token operator">-&gt;</span>msg_flags<span class="token operator">&amp;</span>MSG_CONFIRM<span class="token punctuation">)</span>
          <span class="token keyword">goto</span> do_confirm<span class="token punctuation">;</span>
back_from_confirm<span class="token operator">:</span>
</code></pre>
<p>This flag indicates to the system to confirm that the ARP cache entry is still valid and prevents it from being garbage collected. The <code>dst_confirm</code> function simply sets a flag on destination cache entry which will be checked much later when the neighbour cache has been queried and an entry has been found. We&#x2019;ll see this again later. This feature is commonly used in UDP networking applications to reduce unnecessary ARP traffic. The <code>do_confirm</code> label is found near the end of this function, but it is straightforward:</p>
<pre class="language-"><code class="lang-c">do_confirm<span class="token operator">:</span>
        <span class="token function">dst_confirm</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>msg<span class="token operator">-&gt;</span>msg_flags<span class="token operator">&amp;</span>MSG_PROBE<span class="token punctuation">)</span> <span class="token operator">||</span> len<span class="token punctuation">)</span>
                <span class="token keyword">goto</span> back_from_confirm<span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
</code></pre>
<p>This code confirms the cache entry and jumps back to <code>back_from_confirm</code>, if this was not a probe.</p>
<p>Once the <code>do_confirm</code> code jumps back to <code>back_from_confirm</code> (or no jump happened to <code>do_confirm</code> in the first place), the code will attempt to deal with both the UDP cork and uncorked cases next.</p>
<h4 id="fast-path-for-uncorked-udp-sockets-prepare-data-for-transmit"><a name="fast-path-for-uncorked-udp-sockets-prepare-data-for-transmit" class="anchor-navigation-ex-anchor" href="#fast-path-for-uncorked-udp-sockets-prepare-data-for-transmit"><i class="fa fa-link" aria-hidden="true"></i></a>Fast path for uncorked UDP sockets: Prepare data for transmit</h4>
<p>If UDP corking is not requested, the data can be packed into a <code>struct sk_buff</code> and passed on to <code>udp_send_skb</code> to move down the stack and closer to the IP protocol layer. This is done by calling <code>ip_make_skb</code>. Note that the routing structure generated earlier by calling <code>ip_route_output_flow</code> is passed in as well. It will be affixed to the skb and used later in the IP protocol layer.</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/* Lockless fast path for the non-corking case. */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>corkreq<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        skb <span class="token operator">=</span> <span class="token function">ip_make_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> getfrag<span class="token punctuation">,</span> msg<span class="token operator">-&gt;</span>msg_iov<span class="token punctuation">,</span> ulen<span class="token punctuation">,</span>
                          <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udphdr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ipc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token punctuation">,</span>
                          msg<span class="token operator">-&gt;</span>msg_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR_OR_NULL</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
                err <span class="token operator">=</span> <span class="token function">udp_send_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> fl4<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>ip_make_skb</code> function will attempt to construct an skb taking into consideration a wide range of things, like:</p>
<ul>
<li>The <a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/Maximum_transmission_unit" target="_blank">MTU</a>.</li>
<li>UDP corking (if enabled).</li>
<li>UDP Fragmentation Offloading (<a href="https://wiki.linuxfoundation.org/networking/ufo" target="_blank">UFO</a>).</li>
<li>Fragmentation, if UFO is unsupported and the size of the data to transmit is larger than the MTU.</li>
</ul>
<p>Most network device drivers do not support UFO because the network hardware itself does not support this feature. Let&#x2019;s take a look through this code, keeping in mind that corking is disabled. We&#x2019;ll look at the corking enabled path next.</p>
<h5 id="ipmakeskb"><a name="ipmakeskb" class="anchor-navigation-ex-anchor" href="#ipmakeskb"><i class="fa fa-link" aria-hidden="true"></i></a><code>ip_make_skb</code></h5>
<p>The <code>ip_make_skb</code> function can be found in <a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/LINK" target="_blank">./net/ipv4/ip_output.c</a>. This function is a bit tricky. The lower level code that <code>ip_make_skb</code> needs to use in order to build an skb requires a corking structure and queue where the skb will be queued to be passed in. In the case where the socket is not corked, a faux corking structure and empty queue are passed in as dummies.</p>
<p>Let&#x2019;s take a look at how the faux corking structure and queue are setup:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span><span class="token function">ip_make_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token comment">/* more args */</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">inet_cork</span> cork<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff_head</span> queue<span class="token punctuation">;</span>
        <span class="token keyword">int</span> err<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> MSG_PROBE<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

        <span class="token function">__skb_queue_head_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        cork<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        cork<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        cork<span class="token punctuation">.</span>opt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">ip_setup_cork</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cork<span class="token punctuation">,</span> <span class="token comment">/* more args */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>As seen above, both the corking structure (<code>cork</code>) and the queue (<code>queue</code>) are stack-allocated; neither are needed by the time <code>ip_make_skb</code> has completed. The faux corking structure is setup with a call to <code>ip_setup_cork</code> which allocates memory and initializes the structure. Next, <code>__ip_append_data</code> is called and the queue and corking structure are passed in:</p>
<pre class="language-"><code class="lang-c">err <span class="token operator">=</span> <span class="token function">__ip_append_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cork<span class="token punctuation">,</span>
                       <span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>task_frag<span class="token punctuation">,</span> getfrag<span class="token punctuation">,</span>
                       from<span class="token punctuation">,</span> length<span class="token punctuation">,</span> transhdrlen<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>We&#x2019;ll see how this function works later, as it is used in both cases whether the socket is corked or not. For now, all we need to know is that <code>__ip_append_data</code> will create an skb, append data to it, and add that skb to the queue passed in. If appending the data failed, <code>__ip_flush_pending_frame</code> is called to drop the data on the floor and the error code is passed back upward:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">__ip_flush_pending_frames</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cork<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Finally, if no error occurred, <code>__ip_make_skb</code> will dequeue the queued skb, add the IP options, and return an skb that is ready to be passed on to lower layers for sending:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">return</span> <span class="token function">__ip_make_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cork<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h5 id="transmit-the-data"><a name="transmit-the-data" class="anchor-navigation-ex-anchor" href="#transmit-the-data"><i class="fa fa-link" aria-hidden="true"></i></a>Transmit the data!</h5>
<p>If no errors occurred, the skb is handed to <code>udp_send_skb</code> which will pass the skb to the next layer of the networking stack, the IP protocol stack:</p>
<pre class="language-"><code class="lang-c">err <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR_OR_NULL</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
        err <span class="token operator">=</span> <span class="token function">udp_send_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> fl4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
</code></pre>
<p>If there was an error, it will be accounted later. See the &#x201C;Error Accounting&#x201D; section below the UDP corking case for more information.</p>
<h4 id="slow-path-for-corked-udp-sockets-with-no-preexisting-corked-data"><a name="slow-path-for-corked-udp-sockets-with-no-preexisting-corked-data" class="anchor-navigation-ex-anchor" href="#slow-path-for-corked-udp-sockets-with-no-preexisting-corked-data"><i class="fa fa-link" aria-hidden="true"></i></a>Slow path for corked UDP sockets with no preexisting corked data</h4>
<p>If UDP corking is being used, but no preexisting data is corked, the slow path commences:</p>
<ol>
<li>Lock the socket.</li>
<li>Check for an application bug: a corked socket that is being &#x201C;re-corked&#x201D;.</li>
<li>The flow structure for this UDP flow is prepared for corking.</li>
<li>The data to be sent is appended to existing data.</li>
</ol>
<p>You can see this in the next piece of code, continuing down <code>udp_sendmsg</code>:</p>
<pre class="language-"><code class="lang-c">  <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>up<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">/* The socket is already corked while preparing it. */</span>
          <span class="token comment">/* ... which is an evident application bug. --ANK */</span>
          <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token function">LIMIT_NETDEBUG</span><span class="token punctuation">(</span>KERN_DEBUG <span class="token function">pr_fmt</span><span class="token punctuation">(</span><span class="token string">&quot;cork app bug 2\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
          <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/*
   *      Now cork the socket to pend data.
   */</span>
  fl4 <span class="token operator">=</span> <span class="token operator">&amp;</span>inet<span class="token operator">-&gt;</span>cork<span class="token punctuation">.</span>fl<span class="token punctuation">.</span>u<span class="token punctuation">.</span>ip4<span class="token punctuation">;</span>
  fl4<span class="token operator">-&gt;</span>daddr <span class="token operator">=</span> daddr<span class="token punctuation">;</span>
  fl4<span class="token operator">-&gt;</span>saddr <span class="token operator">=</span> saddr<span class="token punctuation">;</span>
  fl4<span class="token operator">-&gt;</span>fl4_dport <span class="token operator">=</span> dport<span class="token punctuation">;</span>
  fl4<span class="token operator">-&gt;</span>fl4_sport <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">;</span>
  up<span class="token operator">-&gt;</span>pending <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>

do_append_data<span class="token operator">:</span>
  up<span class="token operator">-&gt;</span>len <span class="token operator">+=</span> ulen<span class="token punctuation">;</span>
  err <span class="token operator">=</span> <span class="token function">ip_append_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> getfrag<span class="token punctuation">,</span> msg<span class="token operator">-&gt;</span>msg_iov<span class="token punctuation">,</span> ulen<span class="token punctuation">,</span>
                       <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udphdr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ipc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token punctuation">,</span>
                       corkreq <span class="token operator">?</span> msg<span class="token operator">-&gt;</span>msg_flags<span class="token operator">|</span>MSG_MORE <span class="token operator">:</span> msg<span class="token operator">-&gt;</span>msg_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h5 id="ipappenddata"><a name="ipappenddata" class="anchor-navigation-ex-anchor" href="#ipappenddata"><i class="fa fa-link" aria-hidden="true"></i></a><code>ip_append_data</code></h5>
<p>The <code>ip_append_data</code> is a small wrapper function which does two major things prior to calling down to <code>__ip__append_data</code>:</p>
<ol>
<li>Checks if the <code>MSG_PROBE</code> flag was passed in from the user. This flag indicates that the user does not want to really send data. The path should be probed (for example to determine the <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery" target="_blank">PMTU</a>).</li>
<li>Checks if the socket&#x2019;s send queue is empty. If so, this means that there is no corked data pending, so <code>ip_setup_cork</code> is called to setup corking.</li>
</ol>
<p>Once the above conditions are dealt with the <code>__ip_append_data</code> function is called which contains the bulk of the logic for processing data into packets.</p>
<h5 id="ipappenddata_1"><a name="ipappenddata_1" class="anchor-navigation-ex-anchor" href="#ipappenddata_1"><i class="fa fa-link" aria-hidden="true"></i></a><code>__ip_append_data</code></h5>
<p>This function is called in either from <code>ip_append_data</code> if the socket is corked or from <code>ip_make_skb</code> if the socket is not corked. In either case, this function will either allocate a new buffer to store the data passed in or will append the data with existing data.</p>
<p>The way this work centers around the socket&#x2019;s send queue. Existing data waiting to be sent (for example, if the socket is corked) will have an entry in the queue where additional data can be appended.</p>
<p>This function is complex; it performs several rounds of calculations to determine how to construct the skb that will be passed to the lower level networking layers and examining the buffer allocation process in detail is not strictly necessary for understanding how network data is transmit.</p>
<p>The important highlights of this function include:</p>
<ol>
<li>Handling UDP fragmentation offloading (UFO), if supported by the hardware. The vast majority of network hardware does not support UFO. If your network card&#x2019;s driver does support it, it will set the feature flag <code>NETIF_F_UFO</code>.</li>
<li>Handling network cards that support <a href="https://en.wikipedia.org/wiki/Vectored_I/O" target="_blank">scatter/gather IO</a>. Many cards support this and it is advertised with the <code>NETIF_F_SG</code> feature flag. The availability of this feature indicates that a network card can deal with transmitting a packet where the data has been split amongst a set of buffers; the kernel does not need to spend time coalescing multiple buffers into a single buffer. Avoiding this additional copying is desired and most network cards support this.</li>
<li>Tracking the size of the send queue via calls to <code>sock_wmalloc</code>. When a new skb is allocated, the size of the skb is charged to the socket which owns it and the allocated bytes for a socket&#x2019;s send queue are incremented. If there was not sufficient space in the send queue, the skb is not allocated and an error is returned and tracked. We&#x2019;ll see how to set the socket send queue size in the tuning section below.</li>
<li>Incrementing error statistics. Any error in this function increments &#x201C;discard&#x201D;. We&#x2019;ll see how to read this value in the monitoring section below.</li>
</ol>
<p>Upon successful completion of this function, <code>0</code> is returned and the data to be transmit will be assembled into an skb that is appropriate for the network device and is waiting on the send queue.</p>
<p>In the uncorked case, the queue holding the skb is passed to <code>__ip_make_skb</code> described above where it is dequeued and prepared to be sent to the lower layers via <code>udp_send_skb</code>.</p>
<p>In the corked case, the return value of <code>__ip_append_data</code> is passed upward. The data sits on the send queue until <code>udp_sendmsg</code> determines it is time to call <code>udp_push_pending_frames</code> which will finalize the skb and call <code>udp_send_skb</code>.</p>
<h5 id="flushing-corked-sockets"><a name="flushing-corked-sockets" class="anchor-navigation-ex-anchor" href="#flushing-corked-sockets"><i class="fa fa-link" aria-hidden="true"></i></a>Flushing corked sockets</h5>
<p>Now, <code>udp_sendmsg</code> will move on to check the return value (<code>err</code> below) from <code>__ip_append_skb</code>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token function">udp_flush_pending_frames</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>corkreq<span class="token punctuation">)</span>
        err <span class="token operator">=</span> <span class="token function">udp_push_pending_frames</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_write_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        up<span class="token operator">-&gt;</span>pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Let&#x2019;s take a look at each of these cases:</p>
<ol>
<li>If there is an error (<code>err</code> is non-zero), then <code>udp_flush_pending_frames</code> is called, which cancels corking and drops all data from the socket&#x2019;s send queue.</li>
<li>If this data was sent without <code>MSG_MORE</code> specified, called <code>udp_push_pending_frames</code> which will attempt to deliver the data to the lower networking layers.</li>
<li>If the send queue is empty, mark the socket as no longer corking.</li>
</ol>
<p>If the append operation completed successfully and there is more data to cork coming, the code continues by cleaning up and returning the length of the data appended:</p>
<pre class="language-"><code class="lang-c"><span class="token function">ip_rt_put</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
        <span class="token function">kfree</span><span class="token punctuation">(</span>ipc<span class="token punctuation">.</span>opt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
</code></pre>
<p>That is how the kernel deals with corked UDP sockets.</p>
<h4 id="error-accounting"><a name="error-accounting" class="anchor-navigation-ex-anchor" href="#error-accounting"><i class="fa fa-link" aria-hidden="true"></i></a>Error accounting</h4>
<p>If:</p>
<ol>
<li>The non-corking fast path failed to make an skb or <code>udp_send_skb</code> reports an error, or</li>
<li><code>ip_append_data</code> fails to append data to a corked UDP socket, or</li>
<li><code>udp_push_pending_frames</code> returns an error received from <code>udp_send_skb</code> when trying to transmit a corked skb</li>
</ol>
<p>the <code>SNDBUFERRORS</code> statistic will be incremented only if the error received was <code>ENOBUFS</code> (no kernel memory available) or the socket has <code>SOCK_NOSPACE</code> set (the send queue is full):</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/*
 * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting
 * ENOBUFS might not be good (it&apos;s not tunable per se), but otherwise
 * we don&apos;t have a good statistic (IpOutDiscards but it can be too many
 * things).  We could add another new stat but at least for now that
 * seems like overkill.
 */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token operator">-</span>ENOBUFS <span class="token operator">||</span> <span class="token function">test_bit</span><span class="token punctuation">(</span>SOCK_NOSPACE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_socket<span class="token operator">-&gt;</span>flags<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">UDP_INC_STATS_USER</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span>
                        UDP_MIB_SNDBUFERRORS<span class="token punctuation">,</span> is_udplite<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> err<span class="token punctuation">;</span>
</code></pre>
<p>We&#x2019;ll see how to read these counters in the monitoring section below.</p>
<h3 id="udpsendskb"><a name="udpsendskb" class="anchor-navigation-ex-anchor" href="#udpsendskb"><i class="fa fa-link" aria-hidden="true"></i></a>3.3.2. udp_send_skb</h3>
<p>The <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L765-L819" target="_blank"><code>udp_send_skb</code> function</a> is how <code>udp_sendmsg</code> will eventually push an skb down to the next layer of the networking stack, in this case the IP protocol layer. This function does a few important things:</p>
<ol>
<li>Adds a UDP header to the skb.</li>
<li>Deals with checksums: software checksums, hardware checksums, or no checksum (if disabled).</li>
<li>Attempts to send the skb to the IP protocol layer by calling <code>ip_send_skb</code>.</li>
<li>Increments statistics counters for successful or failed transmissions.</li>
</ol>
<p>Let&#x2019;s take a look. First, a UDP header is created:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">udp_send_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">flowi4</span> <span class="token operator">*</span>fl4<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token comment">/* useful variables ... */</span>

        <span class="token comment">/*
         * Create a UDP header
         */</span>
        uh <span class="token operator">=</span> <span class="token function">udp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        uh<span class="token operator">-&gt;</span>source <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">;</span>
        uh<span class="token operator">-&gt;</span>dest <span class="token operator">=</span> fl4<span class="token operator">-&gt;</span>fl4_dport<span class="token punctuation">;</span>
        uh<span class="token operator">-&gt;</span>len <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        uh<span class="token operator">-&gt;</span>check <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre>
<p>Next, checksumming is handled. There&#x2019;s a few cases:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/UDP-Lite" target="_blank">UDP-Lite</a> checksums are handled first.</li>
<li>Next, if the socket is set to not generate checksums at all (via <code>setsockopt</code> with <code>SO_NO_CHECK</code>), it will be marked as such.</li>
<li>Next, if the hardware supports UDP checksums, <code>udp4_hwcsum</code> will be called to set that up. Note that the kernel will generate checksums in software if the packet is fragmented. You can see this in the <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L720-L763" target="_blank">source for <code>udp4_hwcsum</code></a>.</li>
<li>Lastly, a software checksum is generated with a call to <code>udp_csum</code>.</li>
</ol>
<pre class="language-"><code class="lang-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>is_udplite<span class="token punctuation">)</span>                                  <span class="token comment">/*     UDP-Lite      */</span>
        csum <span class="token operator">=</span> <span class="token function">udplite_csum</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_no_check <span class="token operator">==</span> UDP_CSUM_NOXMIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* UDP csum disabled */</span>

        skb<span class="token operator">-&gt;</span>ip_summed <span class="token operator">=</span> CHECKSUM_NONE<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> send<span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>ip_summed <span class="token operator">==</span> CHECKSUM_PARTIAL<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* UDP hardware csum */</span>

        <span class="token function">udp4_hwcsum</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> fl4<span class="token operator">-&gt;</span>saddr<span class="token punctuation">,</span> fl4<span class="token operator">-&gt;</span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> send<span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token keyword">else</span>
        csum <span class="token operator">=</span> <span class="token function">udp_csum</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Next, the <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol#IPv4_Pseudo_Header" target="_blank">psuedo header</a> is added:</p>
<pre class="language-"><code class="lang-c">uh<span class="token operator">-&gt;</span>check <span class="token operator">=</span> <span class="token function">csum_tcpudp_magic</span><span class="token punctuation">(</span>fl4<span class="token operator">-&gt;</span>saddr<span class="token punctuation">,</span> fl4<span class="token operator">-&gt;</span>daddr<span class="token punctuation">,</span> len<span class="token punctuation">,</span>
                              sk<span class="token operator">-&gt;</span>sk_protocol<span class="token punctuation">,</span> csum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>uh<span class="token operator">-&gt;</span>check <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        uh<span class="token operator">-&gt;</span>check <span class="token operator">=</span> CSUM_MANGLED_0<span class="token punctuation">;</span>
</code></pre>
<p>If the checksum is 0, the equivalent in one&#x2019;s complement is set as the checksum, per <a href="https://tools.ietf.org/html/rfc768" target="_blank">RFC 768</a>. Finally, the skb is passed to the IP protocol stack and statistics are incremented:</p>
<pre class="language-"><code class="lang-c">send<span class="token operator">:</span>
  err <span class="token operator">=</span> <span class="token function">ip_send_skb</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token operator">-</span>ENOBUFS <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>inet<span class="token operator">-&gt;</span>recverr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token function">UDP_INC_STATS_USER</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     UDP_MIB_SNDBUFERRORS<span class="token punctuation">,</span> is_udplite<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span>
          <span class="token function">UDP_INC_STATS_USER</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span>
                             UDP_MIB_OUTDATAGRAMS<span class="token punctuation">,</span> is_udplite<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> err<span class="token punctuation">;</span>
</code></pre>
<p>If <code>ip_send_skb</code> completes successfully, the <code>OUTDATAGRAMS</code> statistic is incremented. If the IP protocol layer reports an error, <code>SNDBUFERRORS</code> is incremented, but only if the error is <code>ENOBUFS</code> (lack of kernel memory) and there is no error queue enabled.</p>
<p>Before moving on to the IP protocol layer, let&#x2019;s take a look at how to monitor and tune the UDP protocol layer in the Linux kernel.</p>
<h3 id="monitoring-udp-protocol-layer-statistics"><a name="monitoring-udp-protocol-layer-statistics" class="anchor-navigation-ex-anchor" href="#monitoring-udp-protocol-layer-statistics"><i class="fa fa-link" aria-hidden="true"></i></a>3.3.3. Monitoring: UDP protocol layer statistics</h3>
<p>Two very useful files for getting UDP protocol statistics are:</p>
<ul>
<li><code>/proc/net/snmp</code></li>
<li><code>/proc/net/udp</code></li>
</ul>
<h4 id="procnetsnmp"><a name="procnetsnmp" class="anchor-navigation-ex-anchor" href="#procnetsnmp"><i class="fa fa-link" aria-hidden="true"></i></a><code>/proc/net/snmp</code></h4>
<p>Monitor detailed UDP protocol statistics by reading <code>/proc/net/snmp</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /proc/net/snmp <span class="token operator">|</span> <span class="token function">grep</span> Udp<span class="token punctuation">\</span>:
Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors
Udp: <span class="token number">16314</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">17161</span> <span class="token number">0</span> <span class="token number">0</span>
</code></pre>
<p>In order to understand precisely where these statistics are incremented, you will need to carefully read the kernel source. There are a few cases where some errors are counted in more than one statistic.</p>
<ul>
<li><code>InDatagrams</code>: Incremented when <code>recvmsg</code> was used by a userland program to read datagram. Also incremented when a UDP packet is encapsulated and sent back for processing.</li>
<li><code>NoPorts</code>: Incremented when UDP packets arrive destined for a port where no program is listening.</li>
<li><code>InErrors</code>: Incremented in several cases: no memory in the receive queue, when a bad checksum is seen, and if <code>sk_add_backlog</code> fails to add the datagram.</li>
<li><code>OutDatagrams</code>: Incremented when a UDP packet is handed down without error to the IP protocol layer to be sent.</li>
<li><code>RcvbufErrors</code>: Incremented when <code>sock_queue_rcv_skb</code> reports that no memory is available; this happens if <code>sk-&gt;sk_rmem_alloc</code> is greater than or equal to <code>sk-&gt;sk_rcvbuf</code>.</li>
<li><code>SndbufErrors</code>: Incremented if the IP protocol layer reported an error when trying to send the packet and no error queue has been setup. Also incremented if no send queue space or kernel memory are available.</li>
<li><code>InCsumErrors</code>: Incremented when a UDP checksum failure is detected. Note that in all cases I could find, <code>InCsumErrors</code> is incremented at the same time as <code>InErrors</code>. Thus, <code>InErrors</code> - <code>InCsumErros</code> should yield the count of memory related errors on the receive side.</li>
</ul>
<p>Note that some errors discovered by the UDP protocol layer are reported in the statistics files for other protocol layers. One example of this: routing errors. A routing error discovered by <code>udp_sendmsg</code> will cause an increment to the IP protocol layer&#x2019;s <code>OutNoRoutes</code> statistic.</p>
<h4 id="procnetudp"><a name="procnetudp" class="anchor-navigation-ex-anchor" href="#procnetudp"><i class="fa fa-link" aria-hidden="true"></i></a><code>/proc/net/udp</code></h4>
<p>Monitor UDP socket statistics by reading <code>/proc/net/udp</code></p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /proc/net/udp
  sl  local_address rem_address   st tx_queue rx_queue <span class="token function">tr</span> tm-<span class="token operator">&gt;</span>when retrnsmt   uid  <span class="token function">timeout</span> inode ref pointer drops
  <span class="token number">515</span>: 00000000:B346 00000000:0000 07 00000000:00000000 00:00000000 00000000   <span class="token number">104</span>        <span class="token number">0</span> <span class="token number">7518</span> <span class="token number">2</span> 0000000000000000 <span class="token number">0</span>
  <span class="token number">558</span>: 00000000:0371 00000000:0000 07 00000000:00000000 00:00000000 00000000     <span class="token number">0</span>        <span class="token number">0</span> <span class="token number">7408</span> <span class="token number">2</span> 0000000000000000 <span class="token number">0</span>
  <span class="token number">588</span>: 0100007F:038F 00000000:0000 07 00000000:00000000 00:00000000 00000000     <span class="token number">0</span>        <span class="token number">0</span> <span class="token number">7511</span> <span class="token number">2</span> 0000000000000000 <span class="token number">0</span>
  <span class="token number">769</span>: 00000000:0044 00000000:0000 07 00000000:00000000 00:00000000 00000000     <span class="token number">0</span>        <span class="token number">0</span> <span class="token number">7673</span> <span class="token number">2</span> 0000000000000000 <span class="token number">0</span>
  <span class="token number">812</span>: 00000000:006F 00000000:0000 07 00000000:00000000 00:00000000 00000000     <span class="token number">0</span>        <span class="token number">0</span> <span class="token number">7407</span> <span class="token number">2</span> 0000000000000000 <span class="token number">0</span>
</code></pre>
<p>The first line describes each of the fields in the lines following:</p>
<ul>
<li><code>sl</code>: Kernel hash slot for the socket</li>
<li><code>local_address</code>: Hexadecimal local address of the socket and port number, separated by <code>:</code>.</li>
<li><code>rem_address</code>: Hexadecimal remote address of the socket and port number, separated by <code>:</code>.</li>
<li><code>st</code>: The state of the socket. Oddly enough, the UDP protocol layer seems to use some TCP socket states. In the example above, <code>7</code> is <code>TCP_CLOSE</code>.</li>
<li><code>tx_queue</code>: The amount of memory allocated in the kernel for outgoing UDP datagrams.</li>
<li><code>rx_queue</code>: The amount of memory allocated in the kernel for incoming UDP datagrams.</li>
<li><code>tr</code>, <code>tm-&gt;when</code>, <code>retrnsmt</code>: These fields are unused by the UDP protocol layer.</li>
<li><code>uid</code>: The effective user id of the user who created this socket.</li>
<li><code>timeout</code>: Unused by the UDP protocol layer.</li>
<li><code>inode</code>: The inode number corresponding to this socket. You can use this to help you determine which user process has this socket open. Check <code>/proc/[pid]/fd</code>, which will contain symlinks to <code>socket[:inode]</code>.</li>
<li><code>ref</code>: The current reference count for the socket.</li>
<li><code>pointer</code>: The memory address in the kernel of the <code>struct sock</code>.</li>
<li><code>drops</code>: The number of datagram drops associated with this socket. Note that this does not include any drops related to sending datagrams (on corked UDP sockets or otherwise); this is only incremented in receive paths as of the kernel version examined by this blog post.</li>
</ul>
<p>The code which outputs this can <a href="https://github.com/torvalds/linux/blob/master/net/ipv4/udp.c#L2396-L2431" target="_blank">be found in <code>net/ipv4/udp.c</code></a>.</p>
<h3 id="tuning-socket-send-queue-memory"><a name="tuning-socket-send-queue-memory" class="anchor-navigation-ex-anchor" href="#tuning-socket-send-queue-memory"><i class="fa fa-link" aria-hidden="true"></i></a>3.3.4. Tuning: Socket send queue memory</h3>
<p>The maximum size of the send queue (also called the write queue) can be adjusted by setting the <code>net.core.wmem_max</code> sysctl.</p>
<p>Increase the maximum send buffer size by setting a <code>sysctl</code>.</p>
<p><code>$ sudo sysctl -w net.core.wmem_max=8388608</code></p>
<p><code>sk-&gt;sk_write_queue</code> starts at the <code>net.core.wmem_default</code> value, which can also be adjusted by setting a sysctl, like so:</p>
<p>Adjust the default initial send buffer size by setting a <code>sysctl</code>.</p>
<p><code>$ sudo sysctl -w net.core.wmem_default=8388608</code></p>
<p>You can also set the <code>sk-&gt;sk_write_queue</code> size by calling <a href="http://www.manpagez.com/man/2/setsockopt/" target="_blank"><code>setsockopt</code></a> from your application and passed <code>SO_SNDBUF</code>. The maximum you can set with <code>setsockopt</code> is <code>net.core.wmem_max</code>.</p>
<p>However, you can override the <code>net.core.wmem_max</code> limit by calling <code>setsockopt</code> and passing <code>SO_SNDBUFFORCE</code>, but the user running the application need the <code>CAP_NET_ADMIN</code> capability.</p>
<p>The <code>sk-&gt;sk_wmem_alloc</code> is incremented each time an skb is allocated by calls to <code>__ip_append_data</code>. As we&#x2019;ll see, UDP datagrams are transmit quickly and typically don&#x2019;t spend much time in the send queue.</p>
<h2 id="ip-protocol-layer"><a name="ip-protocol-layer" class="anchor-navigation-ex-anchor" href="#ip-protocol-layer"><i class="fa fa-link" aria-hidden="true"></i></a>3.4. IP protocol layer</h2>
<p>The UDP protocol layer hands skbs down to the IP protocol by simply calling <code>ip_send_skb</code>, so let&#x2019;s start there and map out the IP protocol layer!</p>
<h3 id="ipsendskb"><a name="ipsendskb" class="anchor-navigation-ex-anchor" href="#ipsendskb"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.1. ip_send_skb</h3>
<p>The <code>ip_send_skb</code> function is found in <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/ip_output.c#L1367-L1380" target="_blank">./net/ipv4/ip_output.c</a> and is very short. It simply calls down to <code>ip_local_out</code> and bumps an error statistic if <code>ip_local_out</code> returns an error of some sort. Let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">ip_send_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> err<span class="token punctuation">;</span>

        err <span class="token operator">=</span> <span class="token function">ip_local_out</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        err <span class="token operator">=</span> <span class="token function">net_xmit_errno</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                        <span class="token function">IP_INC_STATS</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> IPSTATS_MIB_OUTDISCARDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As seen above, <code>ip_local_out</code> is called and the return value is dealt with after that. The call to <code>net_xmit_errno</code> helps to &#x201C;translate&#x201D; any errors from lower levels into an error that is understood by the IP and UDP protocol layers. If any error happens, the IP protocol statistic &#x201C;OutDiscards&#x201D; is incremented. We&#x2019;ll see later which files to read to obtain this statistic. For now, let&#x2019;s continue down the rabbit hole and see where <code>ip_local_out</code> takes us.</p>
<h3 id="iplocalout-and-iplocalout"><a name="iplocalout-and-iplocalout" class="anchor-navigation-ex-anchor" href="#iplocalout-and-iplocalout"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.2. ip_local_out and __ip_local_out</h3>
<p>Luckily for us, both <code>ip_local_out</code> and <code>__ip_local_out</code> are simple. <code>ip_local_out</code> simply calls down to <code>__ip_local_out</code> and based on the return value, will call into the routing layer to output the packet:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">ip_local_out</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> err<span class="token punctuation">;</span>

        err <span class="token operator">=</span> <span class="token function">__ip_local_out</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                err <span class="token operator">=</span> <span class="token function">dst_output</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We can see from the source to <code>__ip_local_out</code> that the function does two important things first:</p>
<ol>
<li>Sets the length of the IP packet</li>
<li>Calls <code>ip_send_check</code> to compute the checksum to be written in the IP packet header. The <code>ip_send_check</code> function will call a function named <code>ip_fast_csum</code> to compute the checksum. On the x86 and x86_64 architectures, this function is implemented in assembly. You can read the <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/checksum_64.h#L40-L73" target="_blank">64bit implementation here</a> and the <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/checksum_32.h#L63-L98" target="_blank">32bit implementation here</a>.</li>
</ol>
<p>Next, the IP protocol layer will call down into netfilter by calling <code>nf_hook</code>. The return value of the <code>nf_hook</code> function will be passed back up to <code>ip_local_out</code>. If <code>nf_hook</code> returns <code>1</code>, this indicates that the packet was allowed to pass and that the caller should pass it along itself. As we saw above, this is precisely what happens: <code>ip_local_out</code> checks for the return value of <code>1</code> and passes the packet on by calling <code>dst_output</code> itself. Let&#x2019;s take a look at the code for <code>__ip_local_out</code>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">__ip_local_out</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">iphdr</span> <span class="token operator">*</span>iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        iph<span class="token operator">-&gt;</span>tot_len <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">ip_send_check</span><span class="token punctuation">(</span>iph<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">nf_hook</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_LOCAL_OUT<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
                       <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> dst_output<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="netfilter-and-nfhook"><a name="netfilter-and-nfhook" class="anchor-navigation-ex-anchor" href="#netfilter-and-nfhook"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.3. netfilter and nf_hook</h3>
<p>In the interest of brevity (and my RSI), I&#x2019;ve decided to skip my deep dive into netfilter, iptables, and conntrack. You can dive into the source for netfilter by starting <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netfilter.h#L142-L147" target="_blank">here</a> and <a href="https://github.com/torvalds/linux/blob/v3.13/net/netfilter/core.c#L168-L209" target="_blank">here</a>.</p>
<p>The short version is that <code>nf_hook</code> is a wrapper which calls <code>nf_hook_thresh</code> that first checks if any filters are installed for the specified protocol family and hook type (<code>NFPROTO_IPV4</code> and <code>NF_INET_LOCAL_OUT</code> in this case, respectively) and attempt to return execution back to the IP protocol layer to avoid going deeper into netfilter and anything that hooks in below that like iptables and conntrack.</p>
<p>Keep in mind: if you have numerous or very complex netfilter or iptables rules, those rules will be executed in the CPU context of the user process which initiated the original <code>sendmsg</code> call. If you have CPU pinning set up to restrict execution of this process to a particular CPU (or set of CPUs), be aware that the CPU will spend system time processing outbound iptables rules. Depending on your system&#x2019;s workload, you may want to carefully pin processes to CPUs or reduce the complexity of your ruleset if you measure a performance regression here.</p>
<p>For the purposes of our discussion, let&#x2019;s assume <code>nf_hook</code> returns <code>1</code> indicating that the caller (in this case, the IP protocol layer) should pass the packet along itself.</p>
<h3 id="destination-cache"><a name="destination-cache" class="anchor-navigation-ex-anchor" href="#destination-cache"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.4. Destination cache</h3>
<p>The <code>dst</code> code implements the protocol independent destination cache in the Linux kernel. To understand how <code>dst</code> entries are setup to proceed with the sending of UDP datagrams, we need to briefly examine how <code>dst</code> entries and routes are generated. The destination cache, routing, and neighbour subsystems can all be examined in extreme detail on their own. For our purposes, we can take a quick look to see how this all fits together.</p>
<p>The code we&#x2019;ve seen above calls <code>dst_output(skb)</code>. This function simply looks up the <code>dst</code> entry attached to the <code>skb</code> and calls the output function. Let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/* Output packet to network from transport.  */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">dst_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">output</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Seems simple enough, but how does that output function get attached to the <code>dst</code> entry in the first place?</p>
<p>It&#x2019;s important to understand that destination cache entries are added in many different ways. One way we&#x2019;ve seen so far in the code path we&#x2019;ve been following is with the call to <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L2252-L2267" target="_blank"><code>ip_route_output_flow</code></a> from <code>udp_sendmsg</code>. The <code>ip_route_output_flow</code> function calls <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L1990-L2173" target="_blank"><code>__ip_route_output_key</code></a> which calls <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L1868-L1988" target="_blank"><code>__mkroute_output</code></a>. The <code>__mkroute_output</code> function creates the route and the destination cache entry. When it does so, it determines which of the output functions is appropriate for this destination. Most of the time, this function is <code>ip_output</code>.</p>
<h3 id="ipoutput"><a name="ipoutput" class="anchor-navigation-ex-anchor" href="#ipoutput"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.5. ip_output</h3>
<p>So, <code>dst_output</code> executes the <code>output</code> function, which in the UDP IPv4 case is <code>ip_output</code>. The <code>ip_output</code> function is straightforward:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">ip_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>

        <span class="token function">IP_UPD_PO_STATS</span><span class="token punctuation">(</span><span class="token function">dev_net</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> IPSTATS_MIB_OUT<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>

        skb<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
        skb<span class="token operator">-&gt;</span>protocol <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token function">NF_HOOK_COND</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_POST_ROUTING<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev<span class="token punctuation">,</span>
                            ip_finish_output<span class="token punctuation">,</span>
                            <span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">IPCB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IPSKB_REROUTED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>First, a statistics counter is updated <code>IPSTATS_MIB_OUT</code>. The <code>IP_UPD_PO_STATS</code> macro will increment both the number of bytes and number packets. We&#x2019;ll see in a later section how to obtain the IP protocol layer statistics and what each of them mean. Next, the device for this <code>skb</code> to be transmit on is set, as is the protocol.</p>
<p>Finally, control is passed off to netfilter with a call to <code>NF_HOOK_COND</code>. Looking at the function prototype for <code>NF_HOOK_COND</code> will help make the explanation of how it works a bit clearer. From <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netfilter.h#L177-L188" target="_blank">./include/linux/netfilter.h</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span>
<span class="token function">NF_HOOK_COND</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> pf<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> hook<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
             <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>out<span class="token punctuation">,</span>
             <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>okfn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bool cond<span class="token punctuation">)</span>
</code></pre>
<p><code>NF_HOOK_COND</code> works by checking the conditional, which is passed in. In this case, that conditional is <code>!(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED</code>. If this conditional is true, then the <code>skb</code> will be passed on to netfilter. If netfilter allows the packet to pass, the <code>okfn</code> is called. In this case, the <code>okfn</code> is <code>ip_finish_output</code>.</p>
<h3 id="ipfinishoutput"><a name="ipfinishoutput" class="anchor-navigation-ex-anchor" href="#ipfinishoutput"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.6. ip_finish_output</h3>
<p>The <code>ip_finish_output</code> function is also short and clear. Let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ip_finish_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_NETFILTER<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_XFRM<span class="token punctuation">)</span></span></span>
        <span class="token comment">/* Policy lookup after SNAT yielded a new policy */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>xfrm <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">IPCB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> IPSKB_REROUTED<span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token function">dst_output</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len <span class="token operator">&gt;</span> <span class="token function">ip_skb_dst_mtu</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">skb_is_gso</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token function">ip_fragment</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> ip_finish_output2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token keyword">return</span> <span class="token function">ip_finish_output2</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>If netfilter and packet transformation are enabled in this kernel, the <code>skb</code>&#x2019;s flags are updated and it is sent back through <code>dst_output</code>. The two more common cases are:</p>
<ol>
<li>If packet&#x2019;s length is larger than the MTU and the packet&#x2019;s segmentation will not be offloaded to the device, <code>ip_fragment</code> is called to help fragment the packet prior to transmission.</li>
<li>Otherwise, the packet is passed straight through to <code>ip_finish_output2</code>.</li>
</ol>
<p>Let&#x2019;s take a short detour to talk about Path MTU Discovery before continuing our way through the kernel.</p>
<h4 id="path-mtu-discovery"><a name="path-mtu-discovery" class="anchor-navigation-ex-anchor" href="#path-mtu-discovery"><i class="fa fa-link" aria-hidden="true"></i></a>Path MTU Discovery</h4>
<p>Linux provides a feature I&#x2019;ve avoided mentioning until now: <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery" target="_blank">Path MTU Discovery</a>. This feature allows the kernel to automatically determine the largest <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit" target="_blank">MTU</a> for a particular route. Determining this value and sending packets that are less than or equal to the MTU for the route means that IP fragmentation can be avoided. This is the preferred setting because fragmenting packets consumes system resources and is seemingly easy to avoid: simply send small enough packets and fragmentation is unnecessary.</p>
<p>You can adjust the Path MTU Discovery settings on a per-socket basis by calling <code>setsockopt</code> in your application with the <code>SOL_IP</code> level and <code>IP_MTU_DISCOVER</code> optname. The optval can be one of the several values described in the <a href="http://man7.org/linux/man-pages/man7/ip.7.html" target="_blank">IP protocol man page</a>. The value you&#x2019;ll likely want to set is: <code>IP_PMTUDISC_DO</code> which means &#x201C;Always do Path MTU Discovery.&#x201D; More advanced network applications or diagnostic tools may choose to implement <a href="https://www.ietf.org/rfc/rfc4821.txt" target="_blank">RFC 4821</a> themselves to determine the PMTU at application start for a particular route or routes. In this case, you can use the <code>IP_PMTUDISC_PROBE</code> option which tells the kernel to set the &#x201C;Don&#x2019;t Fragment&#x201D; bit, but allows you to send data larger than the PMTU.</p>
<p>Your application can retrieve the PMTU by calling <code>getsockopt</code>, with the <code>SOL_IP</code> and <code>IP_MTU</code> optname. You can use this to help guide the size of the UDP datagrams your application will construct prior to attempting transmissions.</p>
<p>If you have enabled PTMU discovery, any attempt to send UDP data larger than the PMTU will result in the application receiving the error code <code>EMSGSIZE</code>. The application can then retry, but with less data.</p>
<p>Enabling PTMU discovery is strongly encouraged, so I&#x2019;ll avoid describing the IP fragmentation code path in detail. When we take a look at the IP protocol layer statistics, I&#x2019;ll explain all the statistics including the fragmentation related statistics. Many of them are incremented in <code>ip_fragment</code>. In both the fragment or non-fragment case <code>ip_finish_output2</code> is called, so let&#x2019;s continue there.</p>
<h3 id="ipfinishoutput2"><a name="ipfinishoutput2" class="anchor-navigation-ex-anchor" href="#ipfinishoutput2"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.7. ip_finish_output2</h3>
<p>The <code>ip_finish_output2</code> is called after IP fragmentation and also directly from <code>ip_finish_output</code>. This function handles bumping various statistics counters prior to handing the packet down to the neighbour cache. Let&#x2019;s see how this works:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">ip_finish_output2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

                <span class="token comment">/* variable declarations */</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>rt<span class="token operator">-&gt;</span>rt_type <span class="token operator">==</span> RTN_MULTICAST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">IP_UPD_PO_STATS</span><span class="token punctuation">(</span><span class="token function">dev_net</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> IPSTATS_MIB_OUTMCAST<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rt<span class="token operator">-&gt;</span>rt_type <span class="token operator">==</span> RTN_BROADCAST<span class="token punctuation">)</span>
                <span class="token function">IP_UPD_PO_STATS</span><span class="token punctuation">(</span><span class="token function">dev_net</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> IPSTATS_MIB_OUTBCAST<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Be paranoid, rather than too clever. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">skb_headroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&lt;</span> hh_len <span class="token operator">&amp;&amp;</span> dev<span class="token operator">-&gt;</span>header_ops<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb2<span class="token punctuation">;</span>

                skb2 <span class="token operator">=</span> <span class="token function">skb_realloc_headroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token function">LL_RESERVED_SPACE</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>skb2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span>
                        <span class="token function">skb_set_owner_w</span><span class="token punctuation">(</span>skb2<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">consume_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                skb <span class="token operator">=</span> skb2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>If the routing structure associated with this packet is of type multicast, both the <code>OutMcastPkts</code> and <code>OutMcastOctets</code> counters are bumped by using the <code>IP_UPD_PO_STATS</code> macro. Otherwise, if the route type is broadcast the <code>OutBcastPkts</code> and <code>OutBcastOctets</code> counters are bumped.</p>
<p>Next, a check is performed to ensure that the skb structure has enough room for any link layer headers that need to be added. If not, additional room is allocated with a call to <code>skb_realloc_headroom</code> and the cost of the new skb is charged to the associated socket.</p>
<pre class="language-"><code class="lang-c">        <span class="token function">rcu_read_lock_bh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nexthop <span class="token operator">=</span> <span class="token punctuation">(</span>__force u32<span class="token punctuation">)</span> <span class="token function">rt_nexthop</span><span class="token punctuation">(</span>rt<span class="token punctuation">,</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        neigh <span class="token operator">=</span> <span class="token function">__ipv4_neigh_lookup_noref</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> nexthop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>neigh<span class="token punctuation">)</span><span class="token punctuation">)</span>
                neigh <span class="token operator">=</span> <span class="token function">__neigh_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arp_tbl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nexthop<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Continuing on, we can see that the next hop is computed by querying the routing layer followed by a lookup against the neighbour cache. If the neighbour is not found, one is created by calling <code>__neigh_create</code>. This could be the case, for example, the first time data is sent to another host. Note that this function is called with <code>arp_tbl</code> (defined in <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L160-L187" target="_blank">./net/ipv4/arp.c</a>) to create the neighbour entry in the ARP table. Other systems (like IPv6 or <a href="https://en.wikipedia.org/wiki/DECnet" target="_blank">DECnet</a>) maintain their own ARP tables and would pass a different structure into <code>__neigh_create</code>. This post does not aim to cover the neighbour cache in full detail, but it is worth nothing that if the neighbour has to be created it is possible that this creation can cause the cache to grow. This post will cover some more details about the neighbour cache in the sections below. At any rate, the neighbour cache exports its own set of statistics so that this growth can be measured. See the monitoring sections below for more information.</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>neigh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">dst_neigh_output</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> neigh<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token function">rcu_read_unlock_bh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">rcu_read_unlock_bh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">net_dbg_ratelimited</span><span class="token punctuation">(</span><span class="token string">&quot;%s: No header cache and no neighbour!\n&quot;</span><span class="token punctuation">,</span>
                            <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Finally, if no error is returned, <code>dst_neigh_output</code> is called to pass the skb along on its journey to be output. Otherwise, the skb is freed and EINVAL is returned. An error here will ripple back and cause <code>OutDiscards</code> to be incremented way back up in <code>ip_send_skb</code>. Let&#x2019;s continue on in <code>dst_neigh_output</code> and continue approaching the Linux kernel&#x2019;s netdevice subsystem.</p>
<h3 id="dstneighoutput"><a name="dstneighoutput" class="anchor-navigation-ex-anchor" href="#dstneighoutput"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.8. dst_neigh_output</h3>
<p>The <code>dst_neigh_output</code> function does two important things for us. First, recall from earlier in this blog post we saw that if a user specified <code>MSG_CONFIRM</code> via an ancillary message to <code>sendmsg</code> the function, a flag is flipped to indicate that the destination cache entry for the remote host is still valid and should not be garbage collected. That check happens here and the <code>confirmed</code> field on the neighbour is set to the current jiffies count.</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">dst_neigh_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>n<span class="token punctuation">,</span>
                                   <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">hh_cache</span> <span class="token operator">*</span>hh<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>pending_confirm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span> now <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>

                dst<span class="token operator">-&gt;</span>pending_confirm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token comment">/* avoid dirtying neighbour */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>confirmed <span class="token operator">!=</span> now<span class="token punctuation">)</span>
                        n<span class="token operator">-&gt;</span>confirmed <span class="token operator">=</span> now<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>Second, the neighbour&#x2019;s state is checked and the appropriate output function is called. Let&#x2019;s take a look at the conditional and try to understand what&#x2019;s going on:</p>
<pre class="language-"><code class="lang-c">        hh <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>hh<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>nud_state <span class="token operator">&amp;</span> NUD_CONNECTED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> hh<span class="token operator">-&gt;</span>hh_len<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token function">neigh_hh_output</span><span class="token punctuation">(</span>hh<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token keyword">return</span> n<span class="token operator">-&gt;</span><span class="token function">output</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>If a neighbour is considered <code>NUD_CONNECTED</code>, meaning it is one or more of:</p>
<ul>
<li><code>NUD_PERMANENT</code>: A static route.</li>
<li><code>NUD_NOARP</code>: Does not require an ARP request (for example, the destination is a multicast or broadcast address, or a loopback device).</li>
<li><code>NUD_REACHABLE</code>: The neighbour is &#x201C;reachable.&#x201D; A destination is marked as reachable whenever an ARP request for it <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L905-L923" target="_blank">is successfully processed</a>.</li>
</ul>
<p><em>and</em> the &#x201C;hardware header&#x201D; (<code>hh</code>) is cached (because we&#x2019;ve sent data before and have previously generated it), call <code>neigh_hh_output</code>. Otherwise, call the <code>output</code> function. Both code paths end with <code>dev_queue_xmit</code> which pass the skb down to the Linux net device subsystem where it will be processed a bit more before hitting the device driver layer. Let&#x2019;s follow both the <code>neigh_hh_output</code> and <code>n-&gt;output</code> code paths until we reach <code>dev_queue_xmit</code>.</p>
<h3 id="neighhhoutput"><a name="neighhhoutput" class="anchor-navigation-ex-anchor" href="#neighhhoutput"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.9. neigh_hh_output</h3>
<p>If the destination is <code>NUD_CONNECTED</code> and the hardware header has been cached, <code>neigh_hh_output</code> will be called, which does a small bit of processing before handing the skb over to <code>dev_queue_xmit</code>. Let&#x2019;s take a look, from <a href="https://github.com/torvalds/linux/blob/v3.13/include/net/neighbour.h#L336-L356" target="_blank">./include/net/neighbour.h</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">neigh_hh_output</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">hh_cache</span> <span class="token operator">*</span>hh<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> seq<span class="token punctuation">;</span>
        <span class="token keyword">int</span> hh_len<span class="token punctuation">;</span>

        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                seq <span class="token operator">=</span> <span class="token function">read_seqbegin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hh<span class="token operator">-&gt;</span>hh_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                hh_len <span class="token operator">=</span> hh<span class="token operator">-&gt;</span>hh_len<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>hh_len <span class="token operator">&lt;=</span> HH_DATA_MOD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">/* this is inlined by gcc */</span>
                        <span class="token function">memcpy</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>data <span class="token operator">-</span> HH_DATA_MOD<span class="token punctuation">,</span> hh<span class="token operator">-&gt;</span>hh_data<span class="token punctuation">,</span> HH_DATA_MOD<span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                         <span class="token keyword">int</span> hh_alen <span class="token operator">=</span> <span class="token function">HH_DATA_ALIGN</span><span class="token punctuation">(</span>hh_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

                         <span class="token function">memcpy</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>data <span class="token operator">-</span> hh_alen<span class="token punctuation">,</span> hh<span class="token operator">-&gt;</span>hh_data<span class="token punctuation">,</span> hh_alen<span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token punctuation">}</span>
         <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read_seqretry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hh<span class="token operator">-&gt;</span>hh_lock<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token function">skb_push</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> hh_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function is a bit tricky to understand, partially due to the locking primitive used to synchronize reading/writing on the cached hardware header. This code uses something called a <a href="https://en.wikipedia.org/wiki/Seqlock" target="_blank">seqlock</a>. You can imagine the <code>do { } while()</code> loop above as a simple retry mechanism which will attempt to perform the operations in the loop until it can be performed successfully.</p>
<p>The loop itself is attempted to determine if the hardware header&#x2019;s length needs to be aligned prior to being copied. This is required because some hardware headers (like the <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/ieee80211.h#L210-L218" target="_blank">IEEE 802.11</a> header) is larger than <code>HH_DATA_MOD</code> (16 bytes).</p>
<p>Once the data is copied to the skb and the skb&#x2019;s internal pointers tracking the data are updated with <code>skb_push</code>, the skb is passed to <code>dev_queue_xmit</code> to enter the Linux net device subsystem.</p>
<h3 id="n-output"><a name="n-output" class="anchor-navigation-ex-anchor" href="#n-output"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.10. n-&gt;output</h3>
<p>If the destination is not <code>NUD_CONNECTED</code> or the hardware header has not been cached the code proceeds down the <code>n-&gt;output</code> path. What is attached to the <code>output</code> function pointer on the neigbour structure? Well, it depends. To understand how this is setup, we&#x2019;ll need to understand a bit more about how the neighbour cache works.</p>
<p>A <code>struct neighbour</code> contains several important fields. The <code>nud_state</code> field as we saw above, an <code>output</code> function, and an <code>ops</code> structure. Recall how earlier we saw that <code>__neigh_create</code> is called from <code>ip_finish_output2</code> if no existing entry was found in the cache. When <code>__neigh_creaet</code> is called a neighbour is allocated with its <code>output</code> <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/neighbour.c#L294" target="_blank">function initially set</a> to <code>neigh_blackhole</code>. As the <code>__neigh_create</code> code progresses, it will adjust the value of <code>output</code> to point to appropriate <code>output</code> functions based on the state of the neighbour.</p>
<p>For example, <code>neigh_connect</code> will be used to set the <code>output</code> pointer to <code>neigh-&gt;ops-&gt;connected_output</code> when the code determines the neighbour to be connected. Alternatively, <code>neigh_suspect</code> will be used to set the <code>output</code> pointer to <code>neigh-&gt;ops-&gt;output</code> when the code suspects that the neighbour may be down (for example if has been more than <code>/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code> seconds since a probe was sent).</p>
<p>In other words: <code>neigh-&gt;output</code> is set to another pointer, either <code>neigh-&gt;ops_connected_output</code> or <code>neigh-&gt;ops-&gt;output</code> depending on it&#x2019;s state. Where does <code>neigh-&gt;ops</code> come from?</p>
<p>After the neighbour is allocated, <code>arp_constructor</code> (from <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L220-L313" target="_blank">./net/ipv4/arp.c</a>) is called to set some of the fields of the <code>struct neighbour</code>. In particular, this function checks the device associated with this neighbour and if the device exposes a <code>header_ops</code> structure that contains a <code>cache</code> function (<a href="https://github.com/torvalds/linux/blob/v3.13/net/ethernet/eth.c#L342-L348" target="_blank">ethernet devices do</a>) <code>neigh-&gt;ops</code> is set to the following structure defined in <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L138-L144" target="_blank">./net/ipv4/arp.c</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">neigh_ops</span> arp_hh_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>family <span class="token operator">=</span>               AF_INET<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>solicit <span class="token operator">=</span>              arp_solicit<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>error_report <span class="token operator">=</span>         arp_error_report<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>output <span class="token operator">=</span>               neigh_resolve_output<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>connected_output <span class="token operator">=</span>     neigh_resolve_output<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>So, regardless of whether or not the neighbour is considered &#x201C;connected&#x201D; or &#x201C;suspect&#x201D; by the neighbour cache code, the <code>neigh_resolve_output</code> function will be attached to <code>neigh-&gt;output</code> and will be called when <code>n-&gt;output</code> is called above.</p>
<h4 id="neighresolveoutput"><a name="neighresolveoutput" class="anchor-navigation-ex-anchor" href="#neighresolveoutput"><i class="fa fa-link" aria-hidden="true"></i></a><code>neigh_resolve_output</code></h4>
<p>This function&#x2019;s purpose is to attempt to resolve a neighbour that is not connected or one which is connected, but has no cached hardware header. Let&#x2019;s take a look at how this function works:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/* Slow and careful. */</span>

<span class="token keyword">int</span> <span class="token function">neigh_resolve_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>neigh<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst <span class="token operator">=</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dst<span class="token punctuation">)</span>
                <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">neigh_event_send</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> err<span class="token punctuation">;</span>
                <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> neigh<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> seq<span class="token punctuation">;</span>
</code></pre>
<p>The code starts by doing some basic checks and proceeds to calling <code>neigh_event_send</code>. The <code>neigh_event_send</code> function is short wrapper around <code>__neigh_event_send</code> which will do the heavy lifting to resolve the neighbour. You can read the source for <code>__neigh_event_send</code> in <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/neighbour.c#L964-L1028" target="_blank">./net/core/neighbour.c</a>, but the high-level takeaway from the code is that there are three cases users will most interested in:</p>
<ol>
<li>Neighbours in state <code>NUD_NONE</code> (the default state when allocated) will cause an immediate ARP request to be sent assuming the values set in <code>/proc/sys/net/ipv4/neigh/default/app_solicit</code> and <code>/proc/sys/net/ipv4/neigh/default/mcast_solicit</code> allow probes to be sent (if not, the state is marked as <code>NUD_FAILED</code>). The neighbour state will be updated and set to <code>NUD_INCOMPLETE</code>.</li>
<li>Neighbours in state <code>NUD_STALE</code> will be updated to <code>NUD_DELAYED</code> and a timer will be set to probe them later (later is the time now + <code>/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code> seconds).</li>
<li>Any neighbours in <code>NUD_INCOMPLETE</code> (including things from case 1 above) will be checked to ensure that the number of queued packets for an unresolved neighbour is less than or equal to <code>/proc/sys/net/ipv4/neigh/default/unres_qlen</code>. If there are more, packets are dequeued and dropped until the length is below or equal to the value in proc. A statistics counter in the neighbour cache stats is bumped for all occurrences of this.</li>
</ol>
<p>If an immediate ARP probe is needed it will be sent. <code>__neigh_event_send</code> will return either <code>0</code> indicating that the neighbour is considered &#x201C;connected&#x201D; or &#x201C;delayed&#x201D; or <code>1</code> otherwise. The return value of <code>0</code> allows <code>neigh_resolve_output</code> to continue:</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>header_ops<span class="token operator">-&gt;</span>cache <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>neigh<span class="token operator">-&gt;</span>hh<span class="token punctuation">.</span>hh_len<span class="token punctuation">)</span>
                        <span class="token function">neigh_hh_init</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>If the device&#x2019;s protocol implementation (ethernet in our case) associated with the neighbour supports caching the hardware header and it is currently not cached, the call to <code>neigh_hh_init</code> will cache it.</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        <span class="token function">__skb_pull</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token function">skb_network_offset</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        seq <span class="token operator">=</span> <span class="token function">read_seqbegin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>neigh<span class="token operator">-&gt;</span>ha_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        err <span class="token operator">=</span> <span class="token function">dev_hard_header</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                              neigh<span class="token operator">-&gt;</span>ha<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read_seqretry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>neigh<span class="token operator">-&gt;</span>ha_lock<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Next, a <a href="https://en.wikipedia.org/wiki/Seqlock" target="_blank">seqlock</a> is used to synchronize access to the neighbour structure&#x2019;s hardware address which will be read by <code>dev_hard_header</code> when attempting to create the ethernet header for the skb. Once the seqlock has allowed execution to continue, error checking takes place:</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        rc <span class="token operator">=</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                        <span class="token keyword">goto</span> out_kfree_skb<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>If the ethernet header was written without returning an error, the skb is handed down to <code>dev_queue_xmit</code> to pass through the Linux network device subsystem for transmit. If there was an error, a <code>goto</code> will drop the skb, set the return code and return the error:</p>
<pre class="language-"><code class="lang-c">out<span class="token operator">:</span>
        <span class="token keyword">return</span> rc<span class="token punctuation">;</span>
discard<span class="token operator">:</span>
        <span class="token function">neigh_dbg</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;%s: dst=%p neigh=%p\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> neigh<span class="token punctuation">)</span><span class="token punctuation">;</span>
out_kfree_skb<span class="token operator">:</span>
        rc <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
        <span class="token function">kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>neigh_resolve_output<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Before we proceed into the Linux network device subsystem, let&#x2019;s take a look at some files for monitoring and turning the IP protocol layer.</p>
<h3 id="monitoring-ip-protocol-layer"><a name="monitoring-ip-protocol-layer" class="anchor-navigation-ex-anchor" href="#monitoring-ip-protocol-layer"><i class="fa fa-link" aria-hidden="true"></i></a>3.4.11. Monitoring: IP protocol layer</h3>
<h4 id="procnetsnmp_1"><a name="procnetsnmp_1" class="anchor-navigation-ex-anchor" href="#procnetsnmp_1"><i class="fa fa-link" aria-hidden="true"></i></a><code>/proc/net/snmp</code></h4>
<p>Monitor detailed IP protocol statistics by reading <code>/proc/net/snmp</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /proc/net/snmp
Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates
Ip: <span class="token number">1</span> <span class="token number">64</span> <span class="token number">25922988125</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">15771700</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">25898327616</span> <span class="token number">22789396404</span> <span class="token number">12987882</span> <span class="token number">51</span> <span class="token number">1</span> <span class="token number">10129840</span> <span class="token number">2196520</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>
<span class="token punctuation">..</span>.
</code></pre>
<p>This file contains statistics for several protocol layers. The IP protocol layer appears first. The first line contains space separate names for each of the corresponding values in the next line.</p>
<p>In the IP protocol layer, you will find statistics counters being bumped. Those counters are referenced by a C enum. All of the valid enum values and the field names they correspond to in <code>/proc/net/snmp</code> can be found in <a href="https://github.com/torvalds/linux/blob/v3.13/include/uapi/linux/snmp.h#L10-L59" target="_blank">include/uapi/linux/snmp.h</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">enum</span>
<span class="token punctuation">{</span>
  IPSTATS_MIB_NUM <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token comment">/* frequently written fields in fast path, kept in same cache line */</span>
  IPSTATS_MIB_INPKTS<span class="token punctuation">,</span>     <span class="token comment">/* InReceives */</span>
  IPSTATS_MIB_INOCTETS<span class="token punctuation">,</span>     <span class="token comment">/* InOctets */</span>
  IPSTATS_MIB_INDELIVERS<span class="token punctuation">,</span>     <span class="token comment">/* InDelivers */</span>
  IPSTATS_MIB_OUTFORWDATAGRAMS<span class="token punctuation">,</span>   <span class="token comment">/* OutForwDatagrams */</span>
  IPSTATS_MIB_OUTPKTS<span class="token punctuation">,</span>      <span class="token comment">/* OutRequests */</span>
  IPSTATS_MIB_OUTOCTETS<span class="token punctuation">,</span>      <span class="token comment">/* OutOctets */</span>

  <span class="token comment">/* ... */</span>
</code></pre>
<p>Some interesting statistics:</p>
<ul>
<li><code>OutRequests</code>: Incremented each time an IP packet is attempted to be sent. It appears that this is incremented for every send, successful or not.</li>
<li><code>OutDiscards</code>: Incremented each time an IP packet is discarded. This can happen if appending data to the skb (for corked sockets) fails, or if the layers below IP return an error.</li>
<li><code>OutNoRoute</code>: Incremented in several places, for example in the UDP protocol layer (<code>udp_sendmsg</code>) if no route can be generated for a given destination. Also incremented when an application calls &#x201C;connect&#x201D; on a UDP socket but no route can be found.</li>
<li><code>FragOKs</code>: Incremented once per packet that is fragmented. For example, a packet split into 3 fragments will cause this counter to be incremented once.</li>
<li><code>FragCreates</code>: Incremented once per fragment that is created. For example, a packet split into 3 fragments will cause this counter to be incremented thrice.</li>
<li><code>FragFails</code>: Incremented if fragmentation was attempted, but is not permitted (because the &#x201C;Don&#x2019;t Fragment&#x201D; bit is set). Also incremented if outputting the fragment fails.</li>
</ul>
<p>Other statistics are documented in <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#monitoring-ip-protocol-layer-statistics" target="_blank">the receive side blog post</a>.</p>
<h4 id="procnetnetstat"><a name="procnetnetstat" class="anchor-navigation-ex-anchor" href="#procnetnetstat"><i class="fa fa-link" aria-hidden="true"></i></a><code>/proc/net/netstat</code></h4>
<p>Monitor extended IP protocol statistics by reading <code>/proc/net/netstat</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /proc/net/netstat <span class="token operator">|</span> <span class="token function">grep</span> IpExt
IpExt: InNoRoutes InTruncatedPkts InMcastPkts OutMcastPkts InBcastPkts OutBcastPkts InOctets OutOctets InMcastOctets OutMcastOctets InBcastOctets OutBcastOctets InCsumErrors InNoECTPkts InECT0Pktsu InCEPkts
IpExt: <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">277959</span> <span class="token number">0</span> <span class="token number">14568040307695</span> <span class="token number">32991309088496</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">58649349</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>
</code></pre>
<p>The format is similar to <code>/proc/net/snmp</code>, except the lines are prefixed with <code>IpExt</code>.</p>
<p>Some interesting statistics:</p>
<ul>
<li><code>OutMcastPkts</code>: Incremented each time a packet destined for a multicast address is sent.</li>
<li><code>OutBcastPkts</code>: Incremented each time a packet destined for a broadcast address is sent.</li>
<li><code>OutOctects</code>: The number of packet bytes output.</li>
<li><code>OutMcastOctets</code>: The number of multicast packet bytes output.</li>
<li><code>OutBcastOctets</code>: The number of broadcast packet bytes output.</li>
</ul>
<p>Other statistics are documented in <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#monitoring-ip-protocol-layer-statistics" target="_blank">the receive side blog post</a>.</p>
<p>Note that each of these is incremented in really specific locations in the IP layer. Code gets moved around from time to time and double counting errors or other accounting bugs can sneak in. If these statistics are important to you, you are strongly encouraged to read the IP protocol layer source code for the metrics that are important to you so you understand when they are (and are not) being incremented.</p>
<h2 id="linux-netdevice-subsystem"><a name="linux-netdevice-subsystem" class="anchor-navigation-ex-anchor" href="#linux-netdevice-subsystem"><i class="fa fa-link" aria-hidden="true"></i></a>3.5. Linux netdevice subsystem</h2>
<p>Before we pick up on the packet transmit path with <code>dev_queue_xmit</code>, let&#x2019;s take a moment to talk about some important concepts which will appear in the coming sections.</p>
<h3 id="linux-traffic-control"><a name="linux-traffic-control" class="anchor-navigation-ex-anchor" href="#linux-traffic-control"><i class="fa fa-link" aria-hidden="true"></i></a>3.5.1. Linux traffic control</h3>
<p>Linux supports a feature called <a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html" target="_blank">traffic control</a>. This feature allows system administrators to control how packets are transmit from a machine. This blog post will not dive into the details of every aspect of Linux traffic control. <a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/" target="_blank">This document</a> provides a great in-depth examination of the system, its control, and its features. There a few concepts that are worth mentioning to make the code seen next easier to understand.</p>
<p>The traffic control system contains several different sets of queuing systems that provide different features for controlling traffic flow. Individual queuing systems are commonly called <code>qdisc</code> and also known as queuing disciplines. You can think of qdiscs as schedulers; qdiscs decide when and how packets are transmit.</p>
<p>On Linux every interface has a default qdisc associated with it. For network hardware that supports only a single transmit queue, the default qdisc <code>pfifo_fast</code> is used. Network hardware that supports multiple transmit queues uses the default qdisc of <code>mq</code>. You can check your system by running <code>tc qdisc</code>.</p>
<p>It is also important to note that some devices support traffic control in hardware which can allow an administrator to offload traffic control to the network hardware and conserve CPU resources on the system.</p>
<p>Now that those ideas have been introduced, let&#x2019;s proceed down <code>dev_queue_xmit</code> from <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2890-L2894" target="_blank">./net/core/dev.c</a>.</p>
<h3 id="devqueuexmit-and-devqueuexmit"><a name="devqueuexmit-and-devqueuexmit" class="anchor-navigation-ex-anchor" href="#devqueuexmit-and-devqueuexmit"><i class="fa fa-link" aria-hidden="true"></i></a>3.5.2. dev_queue_xmit and __dev_queue_xmit</h3>
<p><code>dev_queue_xmit</code> is a simple wrapper around <code>__dev_queue_xmit</code>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>dev_queue_xmit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Following that, <code>__dev_queue_xmit</code> is where the heavy lifting gets done. Let&#x2019;s take a look and step through this code piece by piece. <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2808-L2825" target="_blank">Follow along</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>accel_priv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
        <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>

        <span class="token function">skb_reset_mac_header</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Disable soft irqs for various locks below. Also
         * stops preemption for RCU.
         */</span>
        <span class="token function">rcu_read_lock_bh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">skb_update_prio</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The code above starts out by:</p>
<ol>
<li>Declaring variables.</li>
<li>Preparing the skb to be processed by calling <code>skb_reset_mac_header</code>. This resets the skb&#x2019;s internal pointers so that the ethernet header can be accessed.</li>
<li><code>rcu_read_lock_bh</code> is called to prepare for reading RCU protected data structures in the code below. <a href="https://www.kernel.org/doc/Documentation/RCU/checklist.txt" target="_blank">Read more about safely using RCU</a>.</li>
<li><code>skb_update_prio</code> is called to set the skb&#x2019;s priority, if <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/cgroups/net_prio.txt" target="_blank">the network priority cgroup is being used</a>.</li>
</ol>
<p>Now, we&#x2019;ll get to the more complicated parts of transmitting data ;)</p>
<pre class="language-"><code class="lang-c">        txq <span class="token operator">=</span> <span class="token function">netdev_pick_tx</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> accel_priv<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Here the code attempts to determine which transmit queue to use. As you&#x2019;ll see later in this post, some network devices expose multiple transmit queues for transmitting data. Let&#x2019;s see how this works in detail.</p>
<h4 id="netdevpicktx"><a name="netdevpicktx" class="anchor-navigation-ex-anchor" href="#netdevpicktx"><i class="fa fa-link" aria-hidden="true"></i></a><code>netdev_pick_tx</code></h4>
<p>The <code>netdev_pick_tx</code> code lives in <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L397-L417" target="_blank">./net/core/flow_dissector.c</a>. Let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span><span class="token function">netdev_pick_tx</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
                                    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                                    <span class="token keyword">void</span> <span class="token operator">*</span>accel_priv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> queue_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>real_num_tx_queues <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device_ops</span> <span class="token operator">*</span>ops <span class="token operator">=</span> dev<span class="token operator">-&gt;</span>netdev_ops<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ops<span class="token operator">-&gt;</span>ndo_select_queue<span class="token punctuation">)</span>
                        queue_index <span class="token operator">=</span> ops<span class="token operator">-&gt;</span><span class="token function">ndo_select_queue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span>
                                                            accel_priv<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                        queue_index <span class="token operator">=</span> <span class="token function">__netdev_pick_tx</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>accel_priv<span class="token punctuation">)</span>
                        queue_index <span class="token operator">=</span> <span class="token function">dev_cap_txqueue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> queue_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">skb_set_queue_mapping</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> queue_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">netdev_get_tx_queue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> queue_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As you can see above, if the network device supports only a single TX queue, the more complex code is skipped and that single TX queue is returned. Most devices used on higher end servers will have multiple TX queues. There are two cases for devices with multiple TX queues:</p>
<ol>
<li>The driver implements <code>ndo_select_queue</code>, which can be used to choose a TX queue more intelligently in a hardware or feature specific way, or</li>
<li>The driver does not implement `ndo_select_queue, so the kernel should pick the device itself.</li>
</ol>
<p>As of the 3.13 kernel, not many drivers implement <code>ndo_select_queue</code>. The bnx2x and ixgbe drivers implement this function, but it is only used for <a href="https://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet" target="_blank">fibre channel over ethernet (FCoE)</a>. In light of this, let&#x2019;s assume that the network device does not implement <code>ndo_select_queue</code> and/or that FCoE is not being used. In that case, the kernel will choose the tx queue with <code>__netdev_pick_tx</code>.</p>
<p>Once <code>__netdev_pick_tx</code> determines what the queue is index, <code>skb_set_queue_mapping</code> will cache that value (it will be used later in the traffic control code) and <code>netdev_get_tx_queue</code> will look up and return a pointer to that queue. Let&#x2019;s take a look at how <code>__netdev_pick_tx</code> works before going back up to <code>__dev_queue_xmit</code>.</p>
<h4 id="netdevpicktx_1"><a name="netdevpicktx_1" class="anchor-navigation-ex-anchor" href="#netdevpicktx_1"><i class="fa fa-link" aria-hidden="true"></i></a><code>__netdev_pick_tx</code></h4>
<p>Let&#x2019;s take a look at how the kernel chooses the TX queue to use for transmitting data. From <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L375-L395" target="_blank">./net/core/flow_dissector.c</a>:</p>
<pre class="language-"><code class="lang-c">u16 <span class="token function">__netdev_pick_tx</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
        <span class="token keyword">int</span> queue_index <span class="token operator">=</span> <span class="token function">sk_tx_queue_get</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue_index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> skb<span class="token operator">-&gt;</span>ooo_okay <span class="token operator">||</span>
            queue_index <span class="token operator">&gt;=</span> dev<span class="token operator">-&gt;</span>real_num_tx_queues<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> new_index <span class="token operator">=</span> <span class="token function">get_xps_queue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>new_index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        new_index <span class="token operator">=</span> <span class="token function">skb_tx_hash</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>queue_index <span class="token operator">!=</span> new_index <span class="token operator">&amp;&amp;</span> sk <span class="token operator">&amp;&amp;</span>
                    <span class="token function">rcu_access_pointer</span><span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_dst_cache<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">sk_tx_queue_set</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> new_index<span class="token punctuation">)</span><span class="token punctuation">;</span>

                queue_index <span class="token operator">=</span> new_index<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> queue_index<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The code begins first by checking if the transmit queue has already been cached on the socket by calling <code>sk_tx_queue_get</code>, If it hasn&#x2019;t been cached, <code>-1</code> is returned.</p>
<p>The next if-statement checks if any of the following are true:</p>
<ul>
<li>The queue_index is &lt; 0. This will happen if the queue hasn&#x2019;t been set yet.</li>
<li>If the <code>ooo_okay</code> flag is set. If this flag is set, this means that out of order packets are allowed now. The protocol layers must set this flag appropriately. The TCP protocol layer sets this flag when all outstanding packets for a flow have been acknowledged. When this happens, the kernel can choose a different TX queue for this packet. The UDP protocol layer does not set this flag &#x2013; so UDP packets will never have <code>ooo_okay</code> set to a non-zero value.</li>
<li>If the queue index is larger than the number of queues. This can happen if the user has recently changed the queue count on the device via <code>ethtool</code>. More on this later.</li>
</ul>
<p>In any of those cases, the code descends into the slow path to get the transmit queue. This begins with <code>get_xps_queue</code> which attempts to use a user-configured map linking transmit queues to CPUs. This is called &#x201C;Transmit Packet Steering.&#x201D; We&#x2019;ll look more closely at what Transmit Packet Steering (XPS) is and how it works shortly.</p>
<p>If <code>get_xps_queue</code> returns <code>-1</code> because this kernel does not support XPS, or XPS was not configured by the system administrator, or the mapping configured refers to an invalid queue the code will continue on to call <code>skb_tx_hash</code>.</p>
<p>Once the queue is selected by either XPS or by the kernel automatically with <code>skb_tx_hash</code>, the queue is cached on the socket object with <code>sk_tx_queue_set</code> and returned. Let&#x2019;s see how XPS and <code>skb_tx_hash</code> work before continuing through <code>dev_queue_xmit</code>.</p>
<h5 id="transmit-packet-steering-xps"><a name="transmit-packet-steering-xps" class="anchor-navigation-ex-anchor" href="#transmit-packet-steering-xps"><i class="fa fa-link" aria-hidden="true"></i></a>Transmit Packet Steering (XPS)</h5>
<p>Transmit Packet Steering (XPS) is a feature that allows the system administrator to determine which CPUs can process transmit operations for each available transmit queue supported by the device. The aim of this feature is mainly to avoid lock contention when processing transmit requests. Other benefits like reducing cache evictions and avoiding remote memory access on <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank">NUMA machines</a> are also expected when using XPS.</p>
<p>You can read more about how XPS works by <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L364-L422" target="_blank">checking the kernel documentation for XPS</a>. We&#x2019;ll examine how to tune XPS for your system below, but for now, all you need to know is that to configure XPS the system administrator can define a bitmap mapping transmit queues to CPUs.</p>
<p>The function call in the code above to <code>get_xps_queue</code> will consult this user-specified map in order to determine which transmit queue should be used. If <code>get_xps_queue</code> returns <code>-1</code>, <code>skb_tx_hash</code> will be used instead.</p>
<h5 id="skbtxhash"><a name="skbtxhash" class="anchor-navigation-ex-anchor" href="#skbtxhash"><i class="fa fa-link" aria-hidden="true"></i></a><code>skb_tx_hash</code></h5>
<p>If XPS is not included in the kernel, or is not configured, or suggests a queue that is not available (because perhaps the user adjusted the queue count) <code>skb_tx_hash</code> takes over to determine which queue the data should be sent on. Understanding precisely how <code>skb_tx_hash</code> works is important depending on your transmit workload. Note that this code has been adjusted over time, so if you are using a different kernel version than this document, you should consult your kernel source directly.</p>
<p>Let&#x2019;s take a look at how it works, from <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netdevice.h#L2331-L2340" target="_blank">./include/linux/netdevice.h</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/*
 * Returns a Tx hash for the given packet when dev-&gt;real_num_tx_queues is used
 * as a distribution range limit for the returned value.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> u16 <span class="token function">skb_tx_hash</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
                              <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">__skb_tx_hash</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> dev<span class="token operator">-&gt;</span>real_num_tx_queues<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The code simply calls down to <code>__skb_tx_hash</code>, from <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L239-L271" target="_blank">./net/core/flow_dissector.c</a>. There&#x2019;s some interesting code in this function, so let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/*
 * Returns a Tx hash based on the given packet descriptor a Tx queues&apos; number
 * to be used as a distribution range.
 */</span>
u16 <span class="token function">__skb_tx_hash</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_tx_queues<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        u32 hash<span class="token punctuation">;</span>
        u16 qoffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        u16 qcount <span class="token operator">=</span> num_tx_queues<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skb_rx_queue_recorded</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                hash <span class="token operator">=</span> <span class="token function">skb_get_rx_queue</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>hash <span class="token operator">&gt;=</span> num_tx_queues<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        hash <span class="token operator">-=</span> num_tx_queues<span class="token punctuation">;</span>
                <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>The first if stanza in this function is an interesting short circuit. The function name <code>skb_rx_queue_recorded</code> is a bit misleading. An skb has a <code>queue_mapping</code> field that is used both for rx and tx. At any rate, this if statement can be true if your system is receiving packets and forwarding them elsewhere. If that isn&#x2019;t the case, the code continues.</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>num_tc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                u8 tc <span class="token operator">=</span> <span class="token function">netdev_get_prio_tc_map</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>
                qoffset <span class="token operator">=</span> dev<span class="token operator">-&gt;</span>tc_to_txq<span class="token punctuation">[</span>tc<span class="token punctuation">]</span><span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
                qcount <span class="token operator">=</span> dev<span class="token operator">-&gt;</span>tc_to_txq<span class="token punctuation">[</span>tc<span class="token punctuation">]</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>To understand this piece of code, it is important to mention that a program can set the priority of data sent on a socket. This can be done by using <code>setsockopt</code> with the <code>SOL_SOCKET</code> and <code>SO_PRIORITY</code> level and optname, respectively. See the <a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank">socket(7) man page</a> for more information about <code>SO_PRIORITY</code>.</p>
<p>Note that if you have used the <code>setsockopt</code> option <code>IP_TOS</code> to set the TOS flags on the IP packets sent on a particular socket (or on a per-packet basis if passed as an ancillary message to <code>sendmsg</code>) in your application, the kernel will translate the TOS options set by you to a priority which end up in <code>skb-&gt;priority</code>.</p>
<p>As was mentioned earlier, some network devices support hardware based traffic control systems. If <code>num_tc</code> is non-zero, that means this device supports hardware based traffic control.</p>
<p>If that number is non-zero it means that this device supports hardware based traffic control. The priority map which maps packet priority to hardware based traffic control will be consulted. The appropriate traffic class for the data&#x2019;s priority will be selected based on this map.</p>
<p>Next, the range of appropriate transmit queues for the traffic class will be generated. They will be used to determine the transmit queue.</p>
<p>If <code>num_tc</code> was zero (because the network device does not support hardware based traffic control), the <code>qcount</code> and <code>qoffset</code> variables are set to the number of transmit queues and <code>0</code>, respectively.</p>
<p>Using <code>qcount</code> and <code>qoffset</code>, the index of the transmit queue will be calculated:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>sk <span class="token operator">&amp;&amp;</span> skb<span class="token operator">-&gt;</span>sk<span class="token operator">-&gt;</span>sk_hash<span class="token punctuation">)</span>
                hash <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>sk<span class="token operator">-&gt;</span>sk_hash<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                hash <span class="token operator">=</span> <span class="token punctuation">(</span>__force u16<span class="token punctuation">)</span> skb<span class="token operator">-&gt;</span>protocol<span class="token punctuation">;</span>
        hash <span class="token operator">=</span> <span class="token function">__flow_hash_1word</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span>u16<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u64<span class="token punctuation">)</span> hash <span class="token operator">*</span> qcount<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">+</span> qoffset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>__skb_tx_hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Finally, the appropriate queue index is returned back up to <code>__netdev_pick_tx</code>.</p>
<h3 id="resuming-devqueuexmit"><a name="resuming-devqueuexmit" class="anchor-navigation-ex-anchor" href="#resuming-devqueuexmit"><i class="fa fa-link" aria-hidden="true"></i></a>3.5.3. Resuming __dev_queue_xmit</h3>
<p>At this point the appropriate transmit queue has been selected. <code>__dev_queue_xmit</code> can continue:</p>
<pre class="language-"><code class="lang-c">        q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq<span class="token operator">-&gt;</span>qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NET_CLS_ACT</span></span>
        skb<span class="token operator">-&gt;</span>tc_verd <span class="token operator">=</span> <span class="token function">SET_TC_AT</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>tc_verd<span class="token punctuation">,</span> AT_EGRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token function">trace_net_dev_queue</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                rc <span class="token operator">=</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>It starts by obtaining a reference to the queuing discipline associated with this queue. Recall that earlier we saw that the default for single transmit queue devices is the <code>pfifo_fast</code> qdisc, whereas for multiqueue devices it is the <code>mq</code> qdisc.</p>
<p>Next, the code assigns a traffic classification &#x201C;verdict&#x201D; to the outgoing data, if the packet classification API has been enabled in your kernel. Next, the queue discipline is checked to see if there is a way to queue data. Some queuing disciplines like the <code>noqueue</code> qdisc do not have a queue. If there is a queue, the code calls down to <code>__dev_xmit_skb</code> to continue processing the data for transmit. Afterward, execution jumps to the end of this function. We&#x2019;ll take a look at <code>__dev_xmit_skb</code> shortly. For now, let&#x2019;s see what happens if there is no queue, starting with a very helpful comment:</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* The device has no queue. Common case for software devices:
           loopback, all the sorts of tunnels...

           Really, it is unlikely that netif_tx_lock protection is necessary
           here.  (f.e. loopback and IP tunnels are clean ignoring statistics
           counters.)
           However, it is possible, that they rely on protection
           made by us here.

           Check this and shot the lock. It is not prone from deadlocks.
           Either shot noqueue qdisc, it is even simpler 8)
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IFF_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* ok because BHs are off */</span>
</code></pre>
<p>As the comment illustrates, the only devices that could have a qdisc with no queues are the loopback device and tunnel devices. If the device is currently up, then the current CPU is saved. It used for the next check which is a bit tricky, let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">if</span> <span class="token punctuation">(</span>txq<span class="token operator">-&gt;</span>xmit_lock_owner <span class="token operator">!=</span> cpu<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__this_cpu_read</span><span class="token punctuation">(</span>xmit_recursion<span class="token punctuation">)</span> <span class="token operator">&gt;</span> RECURSION_LIMIT<span class="token punctuation">)</span>
                                <span class="token keyword">goto</span> recursion_alert<span class="token punctuation">;</span>
</code></pre>
<p>There&#x2019;s two cases: the transmit lock on this device queue is owned by this CPU or not. If so, a counter variable <code>xmit_recursion</code>, which is allocated per-CPU, is checked here to determine if the count is over the <code>RECURSION_LIMIT</code>. It is possible that one program could attempt to send data and get preempted right around this place in the code. Another program could be selected by the scheduler to run. If that second program attempts to send data as well and lands here. So, the <code>xmit_recursion</code> counter is used to prevent more than <code>RECURSION_LIMIT</code> programs from racing here to transmit data. Let&#x2019;s keep going:</p>
<pre class="language-"><code class="lang-c">                        <span class="token function">HARD_TX_LOCK</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">netif_xmit_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">__this_cpu_inc</span><span class="token punctuation">(</span>xmit_recursion<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                rc <span class="token operator">=</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token function">__this_cpu_dec</span><span class="token punctuation">(</span>xmit_recursion<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dev_xmit_complete</span><span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                        <span class="token function">HARD_TX_UNLOCK</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                        <span class="token function">HARD_TX_UNLOCK</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">net_crit_ratelimited</span><span class="token punctuation">(</span><span class="token string">&quot;Virtual device %s asks to queue packet!\n&quot;</span><span class="token punctuation">,</span>
                                             dev<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        <span class="token comment">/* Recursion is detected! It is possible,
                         * unfortunately
                         */</span>
recursion_alert<span class="token operator">:</span>
                        <span class="token function">net_crit_ratelimited</span><span class="token punctuation">(</span><span class="token string">&quot;Dead loop on virtual device %s, fix it urgently!\n&quot;</span><span class="token punctuation">,</span>
                                             dev<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>The remainder of the code starts by trying to take the transmit lock. The device&#x2019;s transmit queue to be used is checked to see if transmit is stopped. If not, the <code>xmit_recursion</code> variable is incremented and the data is passed down closer to the device to be transmit. We&#x2019;ll see <code>dev_hard_start_xmit</code> in more detail later. Once this completes, the locks are released and a warning is printed.</p>
<p>Alternatively, if the current CPU is transmit lock owner, or if the <code>RECURSION_LIMIT</code> is hit, no transmit is done, but a warning is printed. The remaining code in the function sets the error code and returns.</p>
<p>Since we are interested in real ethernet devices, let&#x2019;s continue down the code path that would have been taken for those earlier via <code>__dev_xmit_skb</code>.</p>
<h3 id="devxmitskb"><a name="devxmitskb" class="anchor-navigation-ex-anchor" href="#devxmitskb"><i class="fa fa-link" aria-hidden="true"></i></a>3.5.4. __dev_xmit_skb</h3>
<p>And now we descend into <code>__dev_xmit_skb</code> from <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2684-L2745" target="_blank">./net/core/dev.c</a> armed with the queuing discipline, network device, and transmit queue reference:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
                                 <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
                                 <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token class-name">spinlock_t</span> <span class="token operator">*</span>root_lock <span class="token operator">=</span> <span class="token function">qdisc_lock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        bool contended<span class="token punctuation">;</span>
        <span class="token keyword">int</span> rc<span class="token punctuation">;</span>

        <span class="token function">qdisc_pkt_len_init</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">qdisc_calculate_pkt_len</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         * Heuristic to force contended enqueues to serialize on a
         * separate lock before trying to get qdisc main lock.
         * This permits __QDISC_STATE_RUNNING owner to get the lock more often
         * and dequeue packets faster.
         */</span>
        contended <span class="token operator">=</span> <span class="token function">qdisc_is_running</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>contended<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>busylock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This code begins by using <code>qdisc_pkt_len_init</code> and <code>qdisc_calculate_pkt_len</code> to compute an accurate length for the data that will be used by the qdisc later. This is necessary for skbs that will pass through hardware based send offloading (such as UDP Fragmentation Offloading, as we saw earlier) as the additional headers that will be added when fragmentation occurs need to be taken into account.</p>
<p>Next, a lock is used to help reduce contention on the qdisc&#x2019;s main lock (a second lock we&#x2019;ll see later). If qdisc is currently running, then other programs attempting to transmit will contend on the qdisc&#x2019;s <code>busylock</code>. This allows the running qdisc to process packets and contend with a smaller number of programs for the second, main lock. This trick increases throughput as the number of contenders is reduced. You can read the original commit message describing this <a href="https://github.com/torvalds/linux/commit/79640a4ca6955e3ebdb7038508fa7a0cd7fa5527" target="_blank">here</a>. Next the main lock is taken:</p>
<pre class="language-"><code class="lang-c">        <span class="token function">spin_lock</span><span class="token punctuation">(</span>root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Now, we approach an if statement that handles 3 possible cases:</p>
<ol>
<li>The qdisc is deactivated.</li>
<li>The qdisc allows packets to bypass the queuing system, there are no other packets to send, and the qdisc is not currently running. A qdisc allows packet bypass for &#x201C;work-conserving&#x201D; qdisc - in other words, a qdisc that does not delay packet transmit for traffic shaping purposes.</li>
<li>All other cases.</li>
</ol>
<p>Let&#x2019;s take a look at what happens in each of these cases, in order starting with a deactivated qdisc:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">test_bit</span><span class="token punctuation">(</span>__QDISC_STATE_DEACTIVATED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rc <span class="token operator">=</span> NET_XMIT_DROP<span class="token punctuation">;</span>
</code></pre>
<p>This is straightforward. If the qdisc is deactivated, free the data and set the return code to <code>NET_XMIT_DROP</code>. Next, a qdisc allowing packet bypass, with no other outstanding packets, that is not currently running:</p>
<pre class="language-"><code class="lang-c">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> TCQ_F_CAN_BYPASS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">qdisc_qlen</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                   <span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/*
                 * This is a work-conserving queue; there are no old skbs
                 * waiting to be sent out; and the qdisc is not running -
                 * xmit the skb directly.
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>priv_flags <span class="token operator">&amp;</span> IFF_XMIT_DST_RELEASE<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">skb_dst_force</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token function">qdisc_bstats_update</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> root_lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>contended<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>busylock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                contended <span class="token operator">=</span> false<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token function">__qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span>
                        <span class="token function">qdisc_run_end</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>

                rc <span class="token operator">=</span> NET_XMIT_SUCCESS<span class="token punctuation">;</span>
</code></pre>
<p>This if statement is a bit tricky. The entire statement evaluates as <code>true</code> if all of the following are true:</p>
<ol>
<li><code>q-&gt;flags &amp; TCQ_F_CAN_BYPASS</code>: The qdisc allows packets to bypass the queuing system. This will be true for &#x201C;work-conserving&#x201D; qdiscs; i.e. qdiscs that do not delay packet transmit for traffic shaping purposes are considered &#x201C;work-conserving&#x201D; and allow packet bypass. The <code>pfifo_fast</code> qdisc allows packets to bypass the queuing system.</li>
<li><code>!qdisc_qlen(q)</code>: The qdisc&#x2019;s queue has no data in it that is waiting to be transmit.</li>
<li><code>qdisc_run_begin(p)</code>: This function call will either set the qdisc&#x2019;s state as &#x201C;running&#x201D; and return true or return false if the qdisc was already running.</li>
</ol>
<p>If all of the above evaluate to true, then:</p>
<ul>
<li>The <code>IFF_XMIT_DST_RELEASE</code> flag is checked. If enabled, this flag indicates that the kernel is allowed to free the skb&#x2019;s destination cache structure. The code in this function checks if the flag is disabled and forces a reference count on that structure.</li>
<li><code>qdisc_bstats_update</code> is used to increment the number of bytes and packet sent by the qdisc.</li>
<li><code>sch_direct_xmit</code> is used to attempt to transmit the packet. We&#x2019;ll dive more into <code>sch_direct_xmit</code> shortly as it is used in the slower code path, too.</li>
</ul>
<p>The return value of <code>sch_direct_xmit</code> is checked for two cases:</p>
<ol>
<li>The queue is not empty (<code>&gt;0</code> returned). In this case, lock preventing contention from other programs is released and <code>__qdisc_run</code> is called to restart the qdisc processing.</li>
<li>The queue was empty (<code>0</code> is returned). In this case <code>qdisc_run_end</code> is used to turn off qdisc processing.</li>
</ol>
<p>In either case, the return value <code>NET_XMIT_SUCCESS</code> is set as the return code. That wasn&#x2019;t too bad. Let&#x2019;s check the last case, which is catch all:</p>
<pre class="language-"><code class="lang-c">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token function">skb_dst_force</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rc <span class="token operator">=</span> q<span class="token operator">-&gt;</span><span class="token function">enqueue</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token operator">&amp;</span> NET_XMIT_MASK<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>contended<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>busylock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                contended <span class="token operator">=</span> false<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token function">__qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>In all other cases:</p>
<ol>
<li>Call <code>skb_dst_force</code> to force a reference count bump on the skb&#x2019;s destination cache reference.</li>
<li>Queue the data to the qdisc by calling the <code>enqueue</code> function of the queue disc. Store the return code.</li>
<li>Call <code>qdisc_run_begin(p)</code> to mark the qdisc as running. If it was not already running, the <code>busylock</code> is released and <code>__qdisc_run(p)</code> is called to start qdisc processing.</li>
</ol>
<p>The function then finishes up by releasing some locks and returning the return code:</p>
<pre class="language-"><code class="lang-c">        <span class="token function">spin_unlock</span><span class="token punctuation">(</span>root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>contended<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>busylock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> rc<span class="token punctuation">;</span>
</code></pre>
<h3 id="tuning-transmit-packet-steering-xps"><a name="tuning-transmit-packet-steering-xps" class="anchor-navigation-ex-anchor" href="#tuning-transmit-packet-steering-xps"><i class="fa fa-link" aria-hidden="true"></i></a>3.5.5. Tuning: Transmit Packet Steering (XPS)</h3>
<p>For XPS to work, it must be enabled in the kernel configuration (it is on Ubuntu for kernel 3.13.0), and a bitmask describing which CPUs should process packets for a given interface and TX queue.</p>
<p>These bitmasks are similar to the <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#receive-packet-steering-rps" target="_blank">RPS</a> bitmasks and you can find some <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L147-L150" target="_blank">documentation</a> about these bitmasks in the kernel documentation.</p>
<p>In short, the bitmasks to modify are found in:</p>
<p><code>/sys/class/net/DEVICE_NAME/queues/QUEUE/xps_cpus</code></p>
<p>So, for eth0 and transmit queue 0, you would modify the file: <code>/sys/class/net/eth0/queues/tx-0/xps_cpus</code> with a hexadecimal number indicating which CPUs should process transmit completions from <code>eth0</code>&#x2019;s transmit queue 0. As the <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L412-L422" target="_blank">documentation points out</a>, XPS may be unnecessary in certain configurations.</p>
<h2 id="queuing-disciplines"><a name="queuing-disciplines" class="anchor-navigation-ex-anchor" href="#queuing-disciplines"><i class="fa fa-link" aria-hidden="true"></i></a>3.6. Queuing disciplines!</h2>
<p>To follow the path of network data, we&#x2019;ll need to move into the qdisc code a bit. This post does not intend to cover the specific details of each of the different transmit queue options. If you are interested in that, <a href="http://lartc.org/howto/index.html" target="_blank">check this excellent guide</a>.</p>
<p>For the purpose of this blog post, we&#x2019;ll continue the code path by examining how the generic packet scheduler code works. In particular, we&#x2019;ll explore how <code>qdisc_run_begin</code>, <code>qdisc_run_end</code>, <code>__qdisc_run</code>, and <code>sch_direct_xmit</code> work to move network data closer to the driver for transmit.</p>
<p>Let&#x2019;s start by examining how <code>qdisc_run_begin</code> works and proceed from there.</p>
<h3 id="qdiscrunbegin-and-qdiscrunend"><a name="qdiscrunbegin-and-qdiscrunend" class="anchor-navigation-ex-anchor" href="#qdiscrunbegin-and-qdiscrunend"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.1. qdisc_run_begin and qdisc_run_end</h3>
<p>The <code>qdisc_run_begin</code> function can be found in <a href="https://github.com/torvalds/linux/blob/v3.13/include/net/sch_generic.h#L101-L107" target="_blank">./include/net/sch_generic.h</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>qdisc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qdisc_is_running</span><span class="token punctuation">(</span>qdisc<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        qdisc<span class="token operator">-&gt;</span>__state <span class="token operator">|=</span> __QDISC___STATE_RUNNING<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function is simple: the qdisc <code>__state</code> flag is checked. If it&#x2019;s already running, <code>false</code> is returned. Otherwise, <code>__state</code> is updated to enable the <code>__QDISC___STATE_RUNNING</code> bit.</p>
<p>Similarly, <code>qdisc_run_end</code> <a href="https://github.com/torvalds/linux/blob/v3.13/include/net/sch_generic.h#L109-L113" target="_blank">is anti-climactic</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">qdisc_run_end</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>qdisc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        qdisc<span class="token operator">-&gt;</span>__state <span class="token operator">&amp;=</span> <span class="token operator">~</span>__QDISC___STATE_RUNNING<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>It simply disables the <code>__QDISC___STATE_RUNNING</code> bit from the qdisc&#x2019;s <code>__state</code> field. It is important to note that both of these functions simply flip bits; neither actually start or stop processing themselves. The function <code>__qdisc_run</code>, on the other hand, will actually start processing.</p>
<h3 id="qdiscrun"><a name="qdiscrun" class="anchor-navigation-ex-anchor" href="#qdiscrun"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.2. __qdisc_run</h3>
<p>The code for <code>__qdisc_run</code> is deceptively brief:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> quota <span class="token operator">=</span> weight_p<span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/*
                 * Ordered by possible occurrence: Postpone processing if
                 * 1\. we&apos;ve exceeded packet quota
                 * 2\. another process needs the CPU;
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">__netif_schedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token function">qdisc_run_end</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function begins by obtaining the <code>weight_p</code> value. This is set typically via a sysctl and is also used in the receive path. We&#x2019;ll see later how to adjust this value. This loop does two things:</p>
<ol>
<li>It calls <code>qdisc_restart</code> in a busy loop until it returns false (or the break below is triggered).</li>
<li>Determines if either the quota drops below zero or <code>need_resched()</code> returns true. If either is <code>true</code>, <code>__netif_schedule</code> is called and the loop is broken out of.</li>
</ol>
<p>Remember: up to now the kernel is still executing on behalf of the original call to <code>sendmsg</code> by the user program; the user program is currently accumulating system time. If the user program has exhausted its time quota in the kernel, <code>need_resched</code> will return true. If there&#x2019;s still available quota and the user program hasn&#x2019;t used is time slice up yet, <code>qdisc_restart</code> will be called over again.</p>
<p>Let&#x2019;s see how <code>qdisc_restart(q)</code> works and then we&#x2019;ll dive into <code>__netif_schedule(q)</code>.</p>
<h3 id="qdiscrestart"><a name="qdiscrestart" class="anchor-navigation-ex-anchor" href="#qdiscrestart"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.3. qdisc_restart</h3>
<p>Let&#x2019;s jump into <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L156-L192" target="_blank">the code for <code>qdisc_restart</code></a>:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/*
 * NOTE: Called under qdisc_lock(q) with locally disabled BH.
 *
 * __QDISC_STATE_RUNNING guarantees only one CPU can process
 * this qdisc at a time. qdisc_lock(q) serializes queue accesses for
 * this queue.
 *
 *  netif_tx_lock serializes accesses to device driver.
 *
 *  qdisc_lock(q) and netif_tx_lock are mutually exclusive,
 *  if one is grabbed, another must be free.
 *
 * Note, that this procedure can be called by a watchdog timer
 *
 * Returns to the caller:
 *                                0  - queue is empty or throttled.
 *                                &gt;0 - queue is not empty.
 *
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">qdisc_restart</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
        <span class="token class-name">spinlock_t</span> <span class="token operator">*</span>root_lock<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>

        <span class="token comment">/* Dequeue packet */</span>
        skb <span class="token operator">=</span> <span class="token function">dequeue_skb</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">WARN_ON_ONCE</span><span class="token punctuation">(</span><span class="token function">skb_dst_is_noref</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root_lock <span class="token operator">=</span> <span class="token function">qdisc_lock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dev <span class="token operator">=</span> <span class="token function">qdisc_dev</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        txq <span class="token operator">=</span> <span class="token function">netdev_get_tx_queue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> <span class="token function">skb_get_queue_mapping</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>qdisc_restart</code> function begins with a useful comment describing some of the locking constraints for calling this function. The first operation this function performs is to attempt to dequeue an skb from the qdisc.</p>
<p>The function <code>dequeue_skb</code> will attempt to obtain the next packet to transmit. If the queue is empty <code>qdisc_restart</code> will return false (causing the loop in <code>__qdisc_run</code> above to bail).</p>
<p>Assuming there is data to transmit, the code continues by obtaining a reference to the qdisc queue lock, the qdisc&#x2019;s associated device, and the transmit queue.</p>
<p>All of these are passed through to <code>sch_direct_xmit</code>. Let&#x2019;s take a look at <code>dequeue_skb</code> and then we&#x2019;ll come back <code>sch_direct_xmit</code>.</p>
<h4 id="dequeueskb"><a name="dequeueskb" class="anchor-navigation-ex-anchor" href="#dequeueskb"><i class="fa fa-link" aria-hidden="true"></i></a><code>dequeue_skb</code></h4>
<p>Let&#x2019;s take a look at <code>dequeue_skb</code> from <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L59-L78" target="_blank">./net/sched/sch_generic.c</a>. This function handles two major cases:</p>
<ol>
<li>Dequeuing data that was requeued because it could not be sent before, or</li>
<li>Dequeuing new data from the qdisc to be processed.</li>
</ol>
<p>Let&#x2019;s take a look at the first case:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span><span class="token function">dequeue_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb <span class="token operator">=</span> q<span class="token operator">-&gt;</span>gso_skb<span class="token punctuation">;</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq <span class="token operator">=</span> q<span class="token operator">-&gt;</span>dev_queue<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* check the reason of requeuing without tx lock first */</span>
                txq <span class="token operator">=</span> <span class="token function">netdev_get_tx_queue</span><span class="token punctuation">(</span>txq<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token function">skb_get_queue_mapping</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">netif_xmit_frozen_or_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        q<span class="token operator">-&gt;</span>gso_skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                        q<span class="token operator">-&gt;</span>q<span class="token punctuation">.</span>qlen<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span>
                        skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre>
<p>Note that the code begins by taking a reference to <code>gso_skb</code> field of the qdisc. This field holds a reference to data that was requeued. If no data was requeued, this field will be <code>NULL</code>. If that field is not <code>NULL</code>, the code continues by getting the transmit queue for the data and checking if the queue is stopped. If the queue is not stopped, the <code>gso_skb</code> field is cleared and the queue length counter is decreased. If the queue is stopped, the data remains attached to <code>gso_skb</code>, but <code>NULL</code> will be returned from this function.</p>
<p>Let&#x2019;s check the next case, where there is no data that was requeued:</p>
<pre class="language-"><code class="lang-c">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> TCQ_F_ONETXQUEUE<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">netif_xmit_frozen_or_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        skb <span class="token operator">=</span> q<span class="token operator">-&gt;</span><span class="token function">dequeue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> skb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the case where no data was requeued, another tricky compound if statement is evaluated. If:</p>
<ol>
<li>The qdisc does not have a single transmit queue, or</li>
<li>The transmit queue is not stopped</li>
</ol>
<p>Then, the qdisc&#x2019;s <code>dequeue</code> function will be called to obtain new data. The internal implementation of <code>dequeue</code> will vary depending on the qdisc&#x2019;s implementation and features.</p>
<p>The function finishes by returning the data that is up for processing.</p>
<h4 id="schdirectxmit"><a name="schdirectxmit" class="anchor-navigation-ex-anchor" href="#schdirectxmit"><i class="fa fa-link" aria-hidden="true"></i></a><code>sch_direct_xmit</code></h4>
<p>Now we come to <code>sch_direct_xmit</code> (in <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L109-L154" target="_blank">./net/sched/sch_generic.c</a>) which is an important participant in moving data down toward the network device. Let&#x2019;s walk through it, piece by piece:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/*
 * Transmit one skb, and handle the return status as required. Holding the
 * __QDISC_STATE_RUNNING bit guarantees that only one CPU can execute this
 * function.
 *
 * Returns to the caller:
 *                                0  - queue is empty or throttled.
 *                                &gt;0 - queue is not empty.
 */</span>
<span class="token keyword">int</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">,</span>
                    <span class="token class-name">spinlock_t</span> <span class="token operator">*</span>root_lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> NETDEV_TX_BUSY<span class="token punctuation">;</span>

        <span class="token comment">/* And release qdisc */</span>
        <span class="token function">spin_unlock</span><span class="token punctuation">(</span>root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">HARD_TX_LOCK</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">netif_xmit_frozen_or_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span>
                ret <span class="token operator">=</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">HARD_TX_UNLOCK</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The code begins by unlocking the qdisc lock and then locking the transmit lock. Note that <code>HARD_TX_LOCK</code> is a macro:</p>
<pre class="language-"><code class="lang-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HARD_TX_LOCK</span><span class="token expression"><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>features <span class="token operator">&amp;</span> NETIF_F_LLTX<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__netif_tx_lock</span><span class="token punctuation">(</span>txq<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>              </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">}</span>                                               </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span></span></span>
</code></pre>
<p>This macro is checking if the device has the <code>NETIF_F_LLTX</code> flag set in its feature flags. This flag is deprecated and should not be used by new device drivers. Most drivers in this kernel version do not use this flag, so this check will evaluate to to true and the lock for the transmit queue for this data will be obtained.</p>
<p>Next, the transmit queue is checked to ensure that it is not stopped and then <code>dev_hard_start_xmit</code> is called. As we&#x2019;ll see later, <code>dev_hard_start_xmit</code> handles transitioning the network data from the Linux kernel&#x2019;s network device subsystem into the device driver itself for transmission. The return code from this function is stored and will be checked next to determine if the transmit succeeded.</p>
<p>Once this has run (or been skipped because the queue is stopped), the queue&#x2019;s transmit lock is released. Let&#x2019;s continue:</p>
<pre class="language-"><code class="lang-c">        <span class="token function">spin_lock</span><span class="token punctuation">(</span>root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dev_xmit_complete</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* Driver sent out skb successfully or skb was consumed */</span>
                ret <span class="token operator">=</span> <span class="token function">qdisc_qlen</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> NETDEV_TX_LOCKED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* Driver try lock failed */</span>
                ret <span class="token operator">=</span> <span class="token function">handle_dev_cpu_collision</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Next, the lock for this qdisc is taken again and then the return value of <code>dev_hard_start_xmit</code> is examined. The first case is checked by calling <code>dev_xmit_complete</code> which simply checks the return value to determine if the data was sent successfully. If so the qdisc queue length is set as the return value.</p>
<p>If <code>dev_xmit_complete</code> returns false, the return value will be checked to see if <code>dev_hard_start_xmit</code> returned <code>NETDEV_TX_LOCKED</code> up from the device driver. Devices with the deprecated <code>NETIF_F_LLTX</code> feature flag can return <code>NETDEV_TX_LOCKED</code> when the driver attempts to do its own locking of the transmit queue and fails. In this case, <code>handle_dev_cpu_collision</code> is called to deal with the lock contention. We&#x2019;ll take a closer look at <code>handle_dev_cpu_collision</code> shortly, but for now, let&#x2019;s continue down <code>sch_direct_xmit</code> and check out the catch-all case:</p>
<pre class="language-"><code class="lang-c">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">/* Driver returned NETDEV_TX_BUSY - requeue skb */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> NETDEV_TX_BUSY<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">net_warn_ratelimited</span><span class="token punctuation">(</span><span class="token string">&quot;BUG %s code %d qlen %d\n&quot;</span><span class="token punctuation">,</span>
                                             dev<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>q<span class="token punctuation">.</span>qlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

                ret <span class="token operator">=</span> <span class="token function">dev_requeue_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>So if the driver did not transmit the data and it was not due to the transmit lock being held, it is probably due to <code>NETDEV_TX_BUSY</code> (if not a warning is printed). <code>NETDEV_TX_BUSY</code> can be returned by a driver to indicate that either the device or the driver were &#x201C;busy&#x201D; and the data can not be transmit right now. In this case, <code>dev_requeue_skb</code> is used to queue the data to be retried.</p>
<p>The function wraps up by (possibly) adjusting the return value:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&amp;&amp;</span> <span class="token function">netif_xmit_frozen_or_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span>
                ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
</code></pre>
<p>Let&#x2019;s a take a dive into <code>handle_dev_cpu_collision</code> and <code>dev_requeue_skb</code>.</p>
<h4 id="handledevcpucollision"><a name="handledevcpucollision" class="anchor-navigation-ex-anchor" href="#handledevcpucollision"><i class="fa fa-link" aria-hidden="true"></i></a><code>handle_dev_cpu_collision</code></h4>
<p>The code for <code>handle_dev_cpu_collision</code>, from <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L80-L107" target="_blank">./net/sched/sch_generic.c</a> handles two cases:</p>
<ol>
<li>The transmit lock is held by the current CPU.</li>
<li>The transmit lock is held by some other CPU.</li>
</ol>
<p>In the first case, this is handled as a configuration problem and thus a warning is printed. In the second case a statistic counter <code>cpu_collision</code> is incremented and the data is sent through <code>dev_requeue_skb</code> to be requeued for transmission later. Recall earlier we saw code in <code>dequeue_skb</code> that dealt specifically with requeued skbs.</p>
<p>The code for <code>handle_dev_cpu_collision</code> is short and worth a quick read:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">handle_dev_cpu_collision</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                                           <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>dev_queue<span class="token punctuation">,</span>
                                           <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>dev_queue<span class="token operator">-&gt;</span>xmit_lock_owner <span class="token operator">==</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/*
                 * Same CPU holding the lock. It may be a transient
                 * configuration error, when hard_start_xmit() recurses. We
                 * detect it by checking xmit owner and drop the packet when
                 * deadloop is detected. Return OK to try the next skb.
                 */</span>
                <span class="token function">kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">net_warn_ratelimited</span><span class="token punctuation">(</span><span class="token string">&quot;Dead loop on netdevice %s, fix it urgently!\n&quot;</span><span class="token punctuation">,</span>
                                     dev_queue<span class="token operator">-&gt;</span>dev<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ret <span class="token operator">=</span> <span class="token function">qdisc_qlen</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">/*
                 * Another cpu is holding lock, requeue &amp; delay xmits for
                 * some time.
                 */</span>
                <span class="token function">__this_cpu_inc</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">.</span>cpu_collision<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ret <span class="token operator">=</span> <span class="token function">dev_requeue_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Let&#x2019;s take a look at what <code>dev_requeue_skb</code> does, as we&#x2019;ll see this function called from <code>sch_direct_xmit</code>.</p>
<h4 id="devrequeueskb"><a name="devrequeueskb" class="anchor-navigation-ex-anchor" href="#devrequeueskb"><i class="fa fa-link" aria-hidden="true"></i></a><code>dev_requeue_skb</code></h4>
<p>Thankfully, the source for <code>dev_requeue_skb</code> is short and straight to the point, from <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L39-L57" target="_blank">./net/sched/sch_generic.c</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/* Modifications to data participating in scheduling must be protected with
 * qdisc_lock(qdisc) spinlock.
 *
 * The idea is the following:
 * - enqueue, dequeue are serialized via qdisc root lock
 * - ingress filtering is also serialized via qdisc root lock
 * - updates to tree and tree walking are only done under the rtnl mutex.
 */</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">dev_requeue_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">skb_dst_force</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-&gt;</span>gso_skb <span class="token operator">=</span> skb<span class="token punctuation">;</span>
        q<span class="token operator">-&gt;</span>qstats<span class="token punctuation">.</span>requeues<span class="token operator">++</span><span class="token punctuation">;</span>
        q<span class="token operator">-&gt;</span>q<span class="token punctuation">.</span>qlen<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">/* it&apos;s still part of the queue */</span>
        <span class="token function">__netif_schedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function does a few things:</p>
<ol>
<li>It forces a reference count on the skb.</li>
<li>It attaches the skb to the qdisc&#x2019;s <code>gso_skb</code> field. Recall earlier we saw that this field is checked in <code>dequeue_skb</code> before data is pulled off the qdisc&#x2019;s queue.</li>
<li>A statistics counter is bumped.</li>
<li>The size of the queue is increased.</li>
<li><code>__netif_schedule</code> is called.</li>
</ol>
<p>Simple and straightforward. Let&#x2019;s refresh how we got here and then examine <code>__netif_schedule</code>.</p>
<h3 id="reminder-while-loop-in-qdiscrun"><a name="reminder-while-loop-in-qdiscrun" class="anchor-navigation-ex-anchor" href="#reminder-while-loop-in-qdiscrun"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.4. Reminder, while loop in __qdisc_run</h3>
<p>Recall that we got here by examining the function <code>__qdisc_run</code> which contained the following code:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> quota <span class="token operator">=</span> weight_p<span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/*
                 * Ordered by possible occurrence: Postpone processing if
                 * 1\. we&apos;ve exceeded packet quota
                 * 2\. another process needs the CPU;
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">__netif_schedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token function">qdisc_run_end</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This code works by repeatedly calling <code>qdisc_restart</code> in a loop which, internally, dequeues skbs, attempts to transmit them by calling <code>sch_direct_xmit</code>, which calls <code>dev_hard_start_xmit</code> to get down to the driver to do the actual transmit. Anything that could not be transmit is requeued to be transmit in the <code>NET_TX</code> softirq.</p>
<p>The next step in the transmit process is examining <code>dev_hard_start_xmit</code> to see how the drivers are invoked for sending data. Before doing that, we should examine <code>__netif_schedule</code> to fully understand how both <code>__qdisc_run</code> and <code>dev_requeue_skb</code> work.</p>
<h4 id="netifschedule"><a name="netifschedule" class="anchor-navigation-ex-anchor" href="#netifschedule"><i class="fa fa-link" aria-hidden="true"></i></a><code>__netif_schedule</code></h4>
<p>Let&#x2019;s jump into <code>__netif_schedule</code> from <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2127-L2146" target="_blank">./net/core/dev.c</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">void</span> <span class="token function">__netif_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">test_and_set_bit</span><span class="token punctuation">(</span>__QDISC_STATE_SCHED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">__netif_reschedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>__netif_schedule<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This code checks and sets the <code>__QDISC_STATE_SCHED</code> bit in the qdisc&#x2019;s state. If the bit was flipped (meaning that it was not previously in the <code>__QDISC_STATE_SCHED</code> state), the code will call <code>__netif_reschedule</code>, which is not much longer but has very interesting side effects. Let&#x2019;s take a look:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__netif_reschedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>

        <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">__get_cpu_var</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-&gt;</span>next_sched <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>sd<span class="token operator">-&gt;</span>output_queue_tailp <span class="token operator">=</span> q<span class="token punctuation">;</span>
        sd<span class="token operator">-&gt;</span>output_queue_tailp <span class="token operator">=</span> <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>next_sched<span class="token punctuation">;</span>
        <span class="token function">raise_softirq_irqoff</span><span class="token punctuation">(</span>NET_TX_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function does several things:</p>
<ol>
<li>Save the current local IRQ state and disable IRQs with a call to <code>local_irq_save</code>.</li>
<li>Get the current CPUs <code>softnet_data</code> structure.</li>
<li>Add the qdisc to the <code>softnet_data</code>&#x2019;s output queue.</li>
<li>Raise the <code>NET_TX_SOFTIRQ</code> softirq.</li>
<li>Restore the IRQ state and re-enable interrupts.</li>
</ol>
<p>You can read more about <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#linux-network-device-subsystem" target="_blank">the initialization of the <code>softnet_data</code> data structures</a> by reading our previous post about the receive side of the networking stack.</p>
<p>The important piece of code in the above function is: <code>raise_softirq_irqoff</code> which triggers the <code>NET_TX_SOFTIRQ</code> softirq. <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#softirqs" target="_blank">softirqs and their registration</a> are also covered in our previous post. Briefly, you can think of softirqs are kernel threads that execute with a very high priority and process data on behalf of the kernel. They are used for processing incoming network data and also for processing outgoing data.</p>
<p>As you&#x2019;ll see from the previous post, the <code>NET_TX_SOFTIRQ</code> softirq has the function <code>net_tx_action</code> registered to it. This means that there is a kernel thread executing <code>net_tx_action</code>. That thread is occasionally paused and <code>raise_softirq_irqoff</code> resumes it. Let&#x2019;s take a look at what <code>net_tx_action</code> does so we can understand how the kernel processes transmit requests.</p>
<h4 id="nettxaction"><a name="nettxaction" class="anchor-navigation-ex-anchor" href="#nettxaction"><i class="fa fa-link" aria-hidden="true"></i></a><code>net_tx_action</code></h4>
<p>The <code>net_tx_action</code> function from <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3297-L3353" target="_blank">./net/core/dev.c</a> handles two main things when it runs:</p>
<ol>
<li>The completion queue of the <code>softnet_data</code> structure for the executing CPU.</li>
<li>The output queue of the <code>softnet_data</code> structure for the executing CPU.</li>
</ol>
<p>In fact, the code for the function is two large if blocks. Let&#x2019;s take them one at a time, remembering all the while that this code is executing in the softirq context as an independent kernel thread. The purpose of <code>net_tx_action</code> is to execute code that cannot be executed in hot paths throughout the transmit side of the network stack; work is deferred and later processed by the thread executing <code>net_tx_action</code>.</p>
<h5 id="nettxaction-completion-queue"><a name="nettxaction-completion-queue" class="anchor-navigation-ex-anchor" href="#nettxaction-completion-queue"><i class="fa fa-link" aria-hidden="true"></i></a><code>net_tx_action</code> completion queue</h5>
<p>The <code>softnet_data</code>&#x2019;s completion queue is simply a queue of skbs that are waiting to be freed. The function <code>dev_kfree_skb_irq</code> can be used to add skbs to a queue to be freed later. This is commonly used by device drivers to defer freeing consumed skbs. The reason why a driver would want to defer freeing the skb instead of simply freeing the skb is that freeing memory can take time and there are instances (like hardirq handlers) where code needs to execute as quickly as possible and return.</p>
<p>Take a look at the <code>net_tx_action</code> code which deals with freeing skbs on the completion queue:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span>sd<span class="token operator">-&gt;</span>completion_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>clist<span class="token punctuation">;</span>

                <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                clist <span class="token operator">=</span> sd<span class="token operator">-&gt;</span>completion_queue<span class="token punctuation">;</span>
                sd<span class="token operator">-&gt;</span>completion_queue <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">while</span> <span class="token punctuation">(</span>clist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb <span class="token operator">=</span> clist<span class="token punctuation">;</span>
                        clist <span class="token operator">=</span> clist<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

                        <span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>skb<span class="token operator">-&gt;</span>users<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">trace_kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> net_tx_action<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">__kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>If the completion queue has entries, the <code>while</code> loop will walk through the linked list of skbs and call <code>__kfree_skb</code> on each of them to free their memory. Remember, this code is running in a separate &#x201C;thread&#x201D; called a softirq &#x2013; it is not running on behalf of any user program in particular.</p>
<h5 id="nettxaction-output-queue"><a name="nettxaction-output-queue" class="anchor-navigation-ex-anchor" href="#nettxaction-output-queue"><i class="fa fa-link" aria-hidden="true"></i></a><code>net_tx_action</code> output queue</h5>
<p>The output queue serves a different purpose entirely. As we saw earlier, data is added to the output queue by calls to <code>__netif_reschedule</code>, which is typically called from <code>__netif_schedule</code>. The <code>__netif_schedule</code> function is called in two instances we&#x2019;ve seen so far:</p>
<ul>
<li><code>dev_requeue_skb</code>: As we saw, this function can be called if the driver reports back the error code <code>NETDEV_TX_BUSY</code> or if there is a CPU collision.</li>
<li><code>__qdisc_run</code>: We saw this function earlier, as well. It also calls <code>__netif_schedule</code> once the quota has been exceeded or if the process needs to be rescheduled.</li>
</ul>
<p>In either of those cases, the <code>__netif_schedule</code> function will be called which will add the qdisc to the <code>softnet_data</code>&#x2019;s output queue for processing. I&#x2019;ve split out the output queue processing code into three blocks. Let&#x2019;s take a look at the first:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span>sd<span class="token operator">-&gt;</span>output_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>

                <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                head <span class="token operator">=</span> sd<span class="token operator">-&gt;</span>output_queue<span class="token punctuation">;</span>
                sd<span class="token operator">-&gt;</span>output_queue <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                sd<span class="token operator">-&gt;</span>output_queue_tailp <span class="token operator">=</span> <span class="token operator">&amp;</span>sd<span class="token operator">-&gt;</span>output_queue<span class="token punctuation">;</span>
                <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This block simply ensures that there are qdiscs on the output queue, and if so, it sets <code>head</code> to the first entry and moves the tail pointer of the queue.</p>
<p>Next, the <code>while</code> loop for traversing the list of qdsics starts:</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q <span class="token operator">=</span> head<span class="token punctuation">;</span>
                        <span class="token class-name">spinlock_t</span> <span class="token operator">*</span>root_lock<span class="token punctuation">;</span>

                        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next_sched<span class="token punctuation">;</span>

                        root_lock <span class="token operator">=</span> <span class="token function">qdisc_lock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">spin_trylock</span><span class="token punctuation">(</span>root_lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">smp_mb__before_clear_bit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token function">clear_bit</span><span class="token punctuation">(</span>__QDISC_STATE_SCHED<span class="token punctuation">,</span>
                                          <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token function">qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token function">spin_unlock</span><span class="token punctuation">(</span>root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The above section of code moves the head pointer forward and obtains a reference to the qdisc lock. <code>spin_trylock</code> is used to check if the lock can be obtained; note that this call is used specifically because it does not block. If the lock is already held, <code>spin_trylock</code> will return immediately instead of waiting to obtain the lock.</p>
<p>If <code>spin_trylock</code> successfully obtains the lock it returns a non-zero value. In this case, the qdisc&#x2019;s state field has its <code>__QDISC_STATE_SCHED</code> bit flipped and <code>qdisc_run</code> is invoked which flips the <code>__QDISC___STATE_RUNNING</code> bit and kicks begins executing <code>__qdisc_run</code>.</p>
<p>This is important. What&#x2019;s happening here is that the processing loop we examined before which was running on behalf of the system call made by the user is now running again, but in the softirq context because the skb transmit for this qdisc was unable to transmit. This distinction is important because it affects how you monitor CPU usage of applications which send large amounts of data. Let me state this another way:</p>
<ul>
<li>Your program&#x2019;s system time will include time spent calling down to the driver to try to send data, regardless of whether the send completes or the driver returns an error.</li>
<li>If that send is unsuccessful at the driver layer (e.g. because the device was busy sending something else), the qdisc will be added to the output queue and processed later by a softirq thread. In this case, softirq (si) time will be spent attempting to transmit your data.</li>
</ul>
<p>So, the total time spent sending data is a combination of both the system time of send-related system calls and the softirq time for the <code>NET_TX</code> softirq.</p>
<p>At any rate, the code above completes by releasing the qdisc lock. If the <code>spin_trylock</code> call above falls to obtain the lock, the following code is executed:</p>
<pre class="language-"><code class="lang-c">                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">test_bit</span><span class="token punctuation">(</span>__QDISC_STATE_DEACTIVATED<span class="token punctuation">,</span>
                                              <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                        <span class="token function">__netif_reschedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                        <span class="token function">smp_mb__before_clear_bit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                        <span class="token function">clear_bit</span><span class="token punctuation">(</span>__QDISC_STATE_SCHED<span class="token punctuation">,</span>
                                                  <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>This code, which only executes if the qdisc lock couldn&#x2019;t be obtained, handles two cases. Either:</p>
<ol>
<li>The qdisc is not deactivated, but the lock couldn&#x2019;t be obtained for executing <code>qdisc_run</code>. So, call <code>__netif_reschedule</code>. Calling <code>__netif_reschedule</code> here puts the qdisc back on the queue that this function is currently dequeuing from. This allows the qdisc to be checked again later when perhaps the lock has been given up.</li>
<li>The qdisc is marked as deactivated, ensure that the <code>__QDISC_STATE_SCHED</code> state flag is cleared as well.</li>
</ol>
<h3 id="finally-time-to-meet-our-friend-devhardstartxmit"><a name="finally-time-to-meet-our-friend-devhardstartxmit" class="anchor-navigation-ex-anchor" href="#finally-time-to-meet-our-friend-devhardstartxmit"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.5. Finally time to meet our friend dev_hard_start_xmit</h3>
<p>So, we&#x2019;ve traversed the entire network stack down to <code>dev_hard_start_xmit</code>. Maybe you&#x2019;ve arrived here directly from a <code>sendmsg</code> system call or you arrived here via a softirq thread processing network data on the qdisc. <code>dev_hard_start_xmit</code> will call down to the device driver to actually do the transmit operation.</p>
<p>The <code>dev_hard_start_xmit</code> function handles two major cases:</p>
<ul>
<li>Network data that is ready to send, or</li>
<li>Network data that has segmentation offloading that needs to be dealt with.</li>
</ul>
<p>We&#x2019;ll see how both cases are handled, starting with the case of network data that is ready to send. Let&#x2019;s take a look (follow along here: <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2541-L2652" target="_blank">./net/code/dev.c</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">int</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device_ops</span> <span class="token operator">*</span>ops <span class="token operator">=</span> dev<span class="token operator">-&gt;</span>netdev_ops<span class="token punctuation">;</span>
        <span class="token keyword">int</span> rc <span class="token operator">=</span> NETDEV_TX_OK<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> skb_len<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">netdev_features_t</span> features<span class="token punctuation">;</span>

                <span class="token comment">/*
                 * If device doesn&apos;t need skb-&gt;dst, release it right now while
                 * its hot in this cpu cache
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>priv_flags <span class="token operator">&amp;</span> IFF_XMIT_DST_RELEASE<span class="token punctuation">)</span>
                        <span class="token function">skb_dst_drop</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                features <span class="token operator">=</span> <span class="token function">netif_skb_features</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This code starts by obtaining a reference to the device driver&#x2019;s exposed operations with <code>ops</code>. This will be used later when it&#x2019;s time to get the driver to do some work to transmit data. The code checks <code>skb-&gt;next</code> to ensure that this data is not part of a chain of data that is segmented ready to go and moves on to do two things:</p>
<ol>
<li>First, it checks if the <code>IFF_XMIT_DST_RELEASE</code> flag is set on the device. This flag isn&#x2019;t used by any of the &#x201C;real&#x201D; ethernet devices in this kernel. It used by the loopback device and some other software devices, though. If this flag is enabled, the reference count on the destination cache entry can be decreased, since it won&#x2019;t be needed by the driver.</li>
<li>Next, <code>netif_skb_features</code> is used to get the feature flags from the device and modify them a bit based on the protocol for which the data is destined (<code>dev-&gt;protocol</code>). For example, if the protocol is one the device can checksum for, the skb will marked as such. The VLAN tag (if it is set) will also cause additional feature flags to be flipped.</li>
</ol>
<p>Next, the vlan tag will be checked and if the device can&#x2019;t offload VLAN tagging, <code>__vlan_put_tag</code> will be used to do this in software:</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">vlan_tx_tag_present</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token operator">!</span><span class="token function">vlan_hw_offload_capable</span><span class="token punctuation">(</span>features<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>vlan_proto<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        skb <span class="token operator">=</span> <span class="token function">__vlan_put_tag</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>vlan_proto<span class="token punctuation">,</span>
                                             <span class="token function">vlan_tx_tag_get</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

                        skb<span class="token operator">-&gt;</span>vlan_tci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
</code></pre>
<p>Following that, the data will be checked if it&#x2019;s an encapsulation offload request, perhaps for <a href="https://en.wikipedia.org/wiki/Generic_Routing_Encapsulation" target="_blank">GRE</a>, for example. In this case, the feature flags will be updated to include any device-specific hardware encapsulation features that are available:</p>
<pre class="language-"><code class="lang-c">                <span class="token comment">/* If encapsulation offload request, verify we are testing
                 * hardware encapsulation features instead of standard
                 * features for the netdev
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>encapsulation<span class="token punctuation">)</span>
                        features <span class="token operator">&amp;=</span> dev<span class="token operator">-&gt;</span>hw_enc_features<span class="token punctuation">;</span>
</code></pre>
<p>Next, <code>netif_needs_gso</code> is used to determine whether or not an skb itself needs segmentation at all. If the skb needs segmentation, but the device does not support it, then <code>netif_needs_gso</code> will return <code>true</code> indicating that segmentation should occur in software. In this case, <code>dev_gso_segment</code> is called to do the segmentation and the code will jump down to <code>gso</code> to transmit the packets. We&#x2019;ll see the GSO path later.</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">netif_needs_gso</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> features<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">dev_gso_segment</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> features<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                                <span class="token keyword">goto</span> out_kfree_skb<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
                                <span class="token keyword">goto</span> gso<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
</code></pre>
<p>If the data does not need segmentation, a few other cases are handled. First: does the data need to be linearized? That is, can the device support sending network data if the data is spread out across multiple buffers, or does it all need to be combined into a single linear buffer first? The vast majority of network cards do not required the data to be linearized before transmit, so in almost all cases this will evaluated to false and will be skipped.</p>
<pre class="language-"><code class="lang-c">                                     <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skb_needs_linearize</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> features<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                            <span class="token function">__skb_linearize</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                <span class="token keyword">goto</span> out_kfree_skb<span class="token punctuation">;</span>
</code></pre>
<p>A helpful comment is provided next, explaining the next case. The packet will be checked to determine if it still needs a checksum. If the device does not support checksumming, a checksum will be generated in software now:</p>
<pre class="language-"><code class="lang-c">                        <span class="token comment">/* If packet is not checksummed and device does not
                         * support checksumming for this protocol, complete
                         * checksumming here.
                         */</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>ip_summed <span class="token operator">==</span> CHECKSUM_PARTIAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>encapsulation<span class="token punctuation">)</span>
                                        <span class="token function">skb_set_inner_transport_header</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span>
                                                <span class="token function">skb_checksum_start_offset</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                        <span class="token function">skb_set_transport_header</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span>
                                                <span class="token function">skb_checksum_start_offset</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>features <span class="token operator">&amp;</span> NETIF_F_ALL_CSUM<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                                     <span class="token function">skb_checksum_help</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                        <span class="token keyword">goto</span> out_kfree_skb<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
</code></pre>
<p>Now we move on to packet taps! Recall in the <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#netifreceiveskbcore-special-box-delivers-data-to-packet-taps-and-protocol-layers" target="_blank">receive side blog post</a>, we saw how packets were passed off to packet taps (like <a href="http://www.tcpdump.org/manpages/pcap.3pcap.html" target="_blank">PCAP</a>). The next chunk of code in this function hands packets which are about to be transmit over to the packet taps (if there are any).</p>
<pre class="language-"><code class="lang-c">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptype_all<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">dev_queue_xmit_nit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Finally, the driver&#x2019;s <code>ops</code> are used to pass the data down to the device by calling <code>ndo_start_xmit</code>:</p>
<pre class="language-"><code class="lang-c">                skb_len <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span>
                rc <span class="token operator">=</span> ops<span class="token operator">-&gt;</span><span class="token function">ndo_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token function">trace_net_dev_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> rc<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> skb_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">==</span> NETDEV_TX_OK<span class="token punctuation">)</span>
                        <span class="token function">txq_trans_update</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> rc<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>The return value of <code>ndo_start_xmit</code> is returned indicating whether the packet was transmit or not. We saw how this return value will affect the upper layers: the data will likely be requeued by the qdisc above this function so it can be transmit again later.</p>
<p>Let&#x2019;s take a look at the GSO case. This code will run if the skb was already separated into a chain of packets due to segmentation which happened in this function or a packet that was previously segmented, but failed to send and was queued to be sent again.</p>
<pre class="language-"><code class="lang-c">gso<span class="token operator">:</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>nskb <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

                skb<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nskb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                nskb<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptype_all<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">dev_queue_xmit_nit</span><span class="token punctuation">(</span>nskb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

                skb_len <span class="token operator">=</span> nskb<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span>
                rc <span class="token operator">=</span> ops<span class="token operator">-&gt;</span><span class="token function">ndo_start_xmit</span><span class="token punctuation">(</span>nskb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">trace_net_dev_xmit</span><span class="token punctuation">(</span>nskb<span class="token punctuation">,</span> rc<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> skb_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>rc <span class="token operator">!=</span> NETDEV_TX_OK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">&amp;</span> <span class="token operator">~</span>NETDEV_TX_MASK<span class="token punctuation">)</span>
                                <span class="token keyword">goto</span> out_kfree_gso_skb<span class="token punctuation">;</span>
                        nskb<span class="token operator">-&gt;</span>next <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                        skb<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nskb<span class="token punctuation">;</span>
                        <span class="token keyword">return</span> rc<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token function">txq_trans_update</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">netif_xmit_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> skb<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> NETDEV_TX_BUSY<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>As you may have guessed, this code is a while loop that iterates over the list of skbs that were generated when the data was segmented.</p>
<p>Each packet is:</p>
<ul>
<li>Passed through the packet taps (if there are any).</li>
<li>Passed through to the driver via <code>ndo_start_xmit</code> to be transmit.</li>
</ul>
<p>Any error in transmitting a packet is dealt with by adjusting the list of skbs that need to be sent. The error will be returned up the stack and the unsent skbs may be requeued to be sent again later.</p>
<p>The last piece of this function handles cleaning up and potentially freeing data in the event of any errors hit above:</p>
<pre class="language-"><code class="lang-c">out_kfree_gso_skb<span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                skb<span class="token operator">-&gt;</span>destructor <span class="token operator">=</span> <span class="token function">DEV_GSO_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>destructor<span class="token punctuation">;</span>
                <span class="token function">consume_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> rc<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
out_kfree_skb<span class="token operator">:</span>
        <span class="token function">kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
        <span class="token keyword">return</span> rc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>dev_hard_start_xmit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Before continuing into the device driver, let&#x2019;s take a look at some monitoring and tuning that can be done for the code that we just walked through.</p>
<h3 id="monitoring-qdiscs"><a name="monitoring-qdiscs" class="anchor-navigation-ex-anchor" href="#monitoring-qdiscs"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.6. Monitoring qdiscs</h3>
<h4 id="using-the-tc-command-line-tool"><a name="using-the-tc-command-line-tool" class="anchor-navigation-ex-anchor" href="#using-the-tc-command-line-tool"><i class="fa fa-link" aria-hidden="true"></i></a>Using the <code>tc</code> command line tool</h4>
<p>Monitor your qdisc statistics by using <code>tc</code></p>
<pre class="language-"><code class="lang-shell">$ tc <span class="token parameter variable">-s</span> qdisc show dev eth1
qdisc mq <span class="token number">0</span>: root
 Sent <span class="token number">31973946891907</span> bytes <span class="token number">2298757402</span> pkt <span class="token punctuation">(</span>dropped <span class="token number">0</span>, overlimits <span class="token number">0</span> requeues <span class="token number">1776429</span><span class="token punctuation">)</span>
 backlog 0b 0p requeues <span class="token number">1776429</span>
</code></pre>
<p>In order to monitor the packet transmit health of your system, it is vital to examine the statistics of the queue discipline(s) attached to your network device(s). You can check the status by running the command line tool <code>tc</code>. The example above shows how to check the statistics for the <code>eth1</code> interface.</p>
<ul>
<li><code>bytes</code>: The number of bytes that were pushed down to the driver for transmit.</li>
<li><code>pkt</code>: The number of packets that were pushed down to the driver for transmit.</li>
<li><code>dropped</code>: The number of packets that were dropped by the qdisc. This can happen if transmit queue length is not large enough to fit the data being queued to it.</li>
<li><code>overlimits</code>: Depends on the queuing discipline, but can be either the number of packets that could not be enqueued due to a limit being hit, and/or the number of packets which triggered a throttling event when dequeued.</li>
<li><code>requeues</code>: Number of times <code>dev_requeue_skb</code> has been called to requeue an skb. Note that an skb which is requeued multiple times will bump this counter each time it is requeued.</li>
<li><code>backlog</code>: Number of bytes currently on the qdisc&#x2019;s queue. This number is usually bumped each time a packet is enqueued.</li>
</ul>
<p>Some qdsics may export additional statistics. Each qdisc is different and may bump these counters at different times. You may want to study the source for the qdisc you are using to understand precisely when these values can be incremented on your system to help understand what the consequences are for you.</p>
<h3 id="tuning-qdiscs"><a name="tuning-qdiscs" class="anchor-navigation-ex-anchor" href="#tuning-qdiscs"><i class="fa fa-link" aria-hidden="true"></i></a>3.6.7. Tuning qdiscs</h3>
<h4 id="increasing-the-processing-weight-of-qdiscrun"><a name="increasing-the-processing-weight-of-qdiscrun" class="anchor-navigation-ex-anchor" href="#increasing-the-processing-weight-of-qdiscrun"><i class="fa fa-link" aria-hidden="true"></i></a>Increasing the processing weight of <code>__qdisc_run</code></h4>
<p>You can adjust the weight of <code>__qdisc_run</code> loop seen earlier (the <code>quota</code> variable seen above) which will cause more calls to <code>__netif_schedule</code> to be executed. The result will be the current qdisc added to the <code>output_queue</code> list for the current CPU more times, which should result in additional processing of transmit packets.</p>
<p>Example: increase the <code>__qdisc_run</code> quota for all qdiscs with <code>sysctl</code>.</p>
<p><code>$ sudo sysctl -w net.core.dev_weight=600</code></p>
<h4 id="increasing-the-transmit-queue-length"><a name="increasing-the-transmit-queue-length" class="anchor-navigation-ex-anchor" href="#increasing-the-transmit-queue-length"><i class="fa fa-link" aria-hidden="true"></i></a>Increasing the transmit queue length</h4>
<p>Each network device has a <code>txqueuelen</code> tuning knob that can be modified. Most qdisc&#x2019;s will check if the device has sufficient <code>txqueuelen</code> bytes when enqueuing data that should eventually be transmit by the qdisc. You can adjust his parameter to increase the number of bytes that may be queued by a qdisc.</p>
<p>Example: increase the <code>txqueuelen</code> of <code>eth0</code> to <code>10000</code>.</p>
<p><code>$ sudo ifconfig eth0 txqueuelen 10000</code></p>
<p>The default value for ethernet devices is <code>1000</code>. You can check the <code>txqueuelen</code> for network devices by reading the output of <code>ifconfig</code>.</p>
<h2 id="network-device-driver"><a name="network-device-driver" class="anchor-navigation-ex-anchor" href="#network-device-driver"><i class="fa fa-link" aria-hidden="true"></i></a>3.7. Network Device Driver</h2>
<p>We&#x2019;re nearing the end of our journey. There&#x2019;s an important concept to understand about packet transmit. Most devices and drivers deal with packet transmit as a two-step process:</p>
<ol>
<li>Data is arranged properly and the device is triggered to DMA the data from RAM and write it to the network</li>
<li>After the transmit completes, the device will raise an interrupt so the driver can unmap buffers, free memory, or otherwise clean its state.</li>
</ol>
<p>The second phase of this is commonly called the &#x201C;transmit completion&#x201D; phase. We&#x2019;re going to examine both, but we&#x2019;ll start with the first phase: the transmit phase.</p>
<p>We saw that <code>dev_hard_start_xmit</code> calls the <code>ndo_start_xmit</code> (with a lock held) to transmit data, so let&#x2019;s start by examining how a driver registers an <code>ndo_start_xmit</code> and then we&#x2019;ll dive into how that function works.</p>
<p>As in <a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank">the previous blog post</a> we&#x2019;ll be examining the <code>igb</code> driver.</p>
<h3 id="driver-operations-registration"><a name="driver-operations-registration" class="anchor-navigation-ex-anchor" href="#driver-operations-registration"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.1. Driver operations registration</h3>
<p>Drivers implement a series of functions for a variety of operations, like:</p>
<ul>
<li>Sending data (<code>ndo_start_xmit</code>)</li>
<li>Getting statistical information (<code>ndo_get_stats64</code>)</li>
<li>Handling device <code>ioctls</code> (<code>ndo_do_ioctl</code>)</li>
<li>And more.</li>
</ul>
<p>The functions are exported as a series of function pointers arranged in a structure. Let&#x2019;s take a look at the structure defintion for these operations in the <code>igb</code> <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L1905-L1928" target="_blank">driver source</a>:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device_ops</span> igb_netdev_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>ndo_open               <span class="token operator">=</span> igb_open<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ndo_stop               <span class="token operator">=</span> igb_close<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ndo_start_xmit         <span class="token operator">=</span> igb_xmit_frame<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ndo_get_stats64        <span class="token operator">=</span> igb_get_stats64<span class="token punctuation">,</span>

                <span class="token comment">/* ... more fields ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>This structure is registered in the <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L2090" target="_blank"><code>igb_probe</code></a> function:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pci_dev</span> <span class="token operator">*</span>pdev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pci_device_id</span> <span class="token operator">*</span>ent<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
                <span class="token comment">/* ... lots of other stuff ... */</span>

        netdev<span class="token operator">-&gt;</span>netdev_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>igb_netdev_ops<span class="token punctuation">;</span>

                <span class="token comment">/* ... more code ... */</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As we saw in the previous section, higher layers of code will obtain a refernece to a device&#x2019;s <code>netdev_ops</code> structure and call the appropriate function. If you are curious to learn more about how exactly PCI devices are brought up and when/where <code>igb_probe</code> is called, check out <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#initialization" target="_blank">the driver initialization</a> section from our other blog post.</p>
<h3 id="transmit-data-with-ndostartxmit"><a name="transmit-data-with-ndostartxmit" class="anchor-navigation-ex-anchor" href="#transmit-data-with-ndostartxmit"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.2. Transmit data with ndo_start_xmit</h3>
<p>The higher layers of the networking stack use the <code>net_device_ops</code> structure to call into a driver to perform various operations. As we saw earlier, the qdisc code calls <code>ndo_start_xmit</code> to pass data down to the driver for transmit. The <code>ndo_start_xmit</code> function is called while a lock is held, for most hardware devices, as we saw above.</p>
<p>In the <code>igb</code> device driver, the function registered to <code>ndo_start_xmit</code> is called <code>igb_xmit_frame</code>, so let&#x2019;s start at <code>igb_xmit_frame</code> and learn how this driver transmits data. Follow along in <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L4664-L4741" target="_blank">./drivers/net/ethernet/intel/igb/igb_main.c</a> and keep in mind that a lock is beind held the entire time the following code is executing:</p>
<pre class="language-"><code class="lang-c"><span class="token class-name">netdev_tx_t</span> <span class="token function">igb_xmit_frame_ring</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                                <span class="token keyword">struct</span> <span class="token class-name">igb_ring</span> <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">igb_tx_buffer</span> <span class="token operator">*</span>first<span class="token punctuation">;</span>
        <span class="token keyword">int</span> tso<span class="token punctuation">;</span>
        u32 tx_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        u16 count <span class="token operator">=</span> <span class="token function">TXD_USE_COUNT</span><span class="token punctuation">(</span><span class="token function">skb_headlen</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        __be16 protocol <span class="token operator">=</span> <span class="token function">vlan_get_protocol</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        u8 hdr_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment">/* need: 1 descriptor per page * PAGE_SIZE/IGB_MAX_DATA_PER_TXD,
         *       + 1 desc for skb_headlen/IGB_MAX_DATA_PER_TXD,
         *       + 2 desc gap to keep tail from touching head,
         *       + 1 desc for context descriptor,
         * otherwise try next time
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>NETDEV_FRAG_PAGE_MAX_SIZE <span class="token operator">&gt;</span> IGB_MAX_DATA_PER_TXD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">short</span> f<span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> f <span class="token operator">&lt;</span> <span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>nr_frags<span class="token punctuation">;</span> f<span class="token operator">++</span><span class="token punctuation">)</span>
                        count <span class="token operator">+=</span> <span class="token function">TXD_USE_COUNT</span><span class="token punctuation">(</span><span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>frags<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                count <span class="token operator">+=</span> <span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>nr_frags<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>The function starts out be determining use the <code>TXD_USER_COUNT</code> macro to determine how many transmit descriptors will be needed to transmit the data passed in. The <code>count</code> value initialized at the the number of descriptors to fit the skb. It is then adjusted to account for any additional fragments that need to be transmit.</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">igb_maybe_stop_tx</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> count <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* this is a hard error */</span>
                <span class="token keyword">return</span> NETDEV_TX_BUSY<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>The driver then calls an internal function <code>igb_maybe_stop_tx</code> which will check the number of descriptors needed to ensure that the transmit queue has enough available. If not, <code>NETDEV_TX_BUSY</code> is returned here. As we saw earlier in the qdisc code, this will cause the qdisc to requeue the data to be retried later.</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* record the location of the first descriptor for this packet */</span>
        first <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_buffer_info<span class="token punctuation">[</span>tx_ring<span class="token operator">-&gt;</span>next_to_use<span class="token punctuation">]</span><span class="token punctuation">;</span>
        first<span class="token operator">-&gt;</span>skb <span class="token operator">=</span> skb<span class="token punctuation">;</span>
        first<span class="token operator">-&gt;</span>bytecount <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span>
        first<span class="token operator">-&gt;</span>gso_segs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
<p>The code then obtains a regerence to the next available buffer info in the transmit queue. This structure will track the information needed for setting up a buffer descriptor later. A reference to the packet and its size are copied into the buffer info structure.</p>
<pre class="language-"><code class="lang-c">        <span class="token function">skb_tx_timestamp</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The code above starts by calling <code>skb_tx_timestamp</code> which is used to obtain a software based transmit timestamp. An application can use the transmit timestamp to determine the amount of time it takes for a packet to travel through the transmit path of the network stack.</p>
<p>Some devices also support generating timestamps for packets transmit in hardware. This allows the system to offload timestamping to the device and it allows the programmer to obtain a more accurate timestamp, as it will be taken much closer to when the actual transmit by the hardware occurs. We&#x2019;ll see the code for this now:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>tx_flags <span class="token operator">&amp;</span> SKBTX_HW_TSTAMP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">igb_adapter</span> <span class="token operator">*</span>adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>adapter<span class="token operator">-&gt;</span>ptp_tx_skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>tx_flags <span class="token operator">|=</span> SKBTX_IN_PROGRESS<span class="token punctuation">;</span>
                        tx_flags <span class="token operator">|=</span> IGB_TX_FLAGS_TSTAMP<span class="token punctuation">;</span>

                        adapter<span class="token operator">-&gt;</span>ptp_tx_skb <span class="token operator">=</span> <span class="token function">skb_get</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        adapter<span class="token operator">-&gt;</span>ptp_tx_start <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>adapter<span class="token operator">-&gt;</span>hw<span class="token punctuation">.</span>mac<span class="token punctuation">.</span>type <span class="token operator">==</span> e1000_82576<span class="token punctuation">)</span>
                                <span class="token function">schedule_work</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>ptp_tx_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>Some network devices can timestamp packets in hardware using the <a href="https://events.linuxfoundation.org/sites/events/files/slides/lcjp14_ichikawa_0.pdf" target="_blank">Precision Time Protocol</a>. The driver code handles that here when a user requests hardware timestampping.</p>
<p>The <code>if</code> statement above checks for the <code>SKBTX_HW_TSTAMP</code> flag. This flag indicates that the user requested hardware timestamping. If the user requested hardware timestamping, the code will next check if <code>ptp_tx_skb</code> is set. One packet can be timestampped at a time, so a reference to the packet being timestampped is taken here and the <code>SKBTX_IN_PROGRESS</code> flag is set on the skb. The <code>tx_flags</code> are updated to mark the <code>IGB_TX_FLAGS_TSTAMP</code> flag. The <code>tx_flags</code> variable will be copied into the buffer info structure later.</p>
<p>A reference is taken to the skb, the current jiffies count is copied to <code>ptp_tx_start</code>. This value will be used by other code in the driver to ensure that the TX hardware timestampping is not hanging. Finally, the <code>schedule_work</code> function is used to kick the <a href="http://www.makelinux.net/ldd3/chp-7-sect-6" target="_blank">workqueue</a> if this is an <code>82576</code> ethernet hardware adapter.</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">vlan_tx_tag_present</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tx_flags <span class="token operator">|=</span> IGB_TX_FLAGS_VLAN<span class="token punctuation">;</span>
                tx_flags <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token function">vlan_tx_tag_get</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> IGB_TX_FLAGS_VLAN_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>The code above will check if the <code>vlan_tci</code> field of the skb was set. If it is set, then the <code>IGB_TX_FLAGS_VLAN</code> flag is enabled and the vlan ID is stored.</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* record initial flags and protocol */</span>
        first<span class="token operator">-&gt;</span>tx_flags <span class="token operator">=</span> tx_flags<span class="token punctuation">;</span>
        first<span class="token operator">-&gt;</span>protocol <span class="token operator">=</span> protocol<span class="token punctuation">;</span>
</code></pre>
<p>The flags and protocol are recorded to the buffer info structure.</p>
<pre class="language-"><code class="lang-c">        tso <span class="token operator">=</span> <span class="token function">igb_tso</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hdr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tso <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> out_drop<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tso<span class="token punctuation">)</span>
                <span class="token function">igb_tx_csum</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Next, the driver calls its internal function <code>igb_tso</code>. This function will determine if an skb needs fragmentation. If so, the buffer info reference (<code>first</code>) will have its flags updated to indicate to the hardware that <a href="https://en.wikipedia.org/wiki/Large_segment_offload" target="_blank">TSO</a> is required.</p>
<p><code>igb_tso</code> will return <code>0</code> is TSO is unncessary, otherwise <code>1</code> is returned. If <code>0</code> is returned, <code>igb_tx_csum</code> will be called to deal with enabling checksum offloading if needed and if supported for this protocol. The <code>igb_tx_csum</code> function will check the properties of the skb and flip some flag bits in the buffer info <code>first</code> to signal that checksum offloading is needed.</p>
<pre class="language-"><code class="lang-c">        <span class="token function">igb_tx_map</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">,</span> hdr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The <code>igb_tx_map</code> function is called to prepare the data to be consumed by the device for transmit. We&#x2019;ll examine this function in detail next.</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* Make sure there is space in the ring for the next send. */</span>
        <span class="token function">igb_maybe_stop_tx</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> DESC_NEEDED<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> NETDEV_TX_OK<span class="token punctuation">;</span>
</code></pre>
<p>Once the the transmit is complete, the driver checks to ensure that there is sufficient space available for another transmit. If not, the queue is shutdown. In either case <code>NETDEV_TX_OK</code> is returned to the higher layer (the qdisc code).</p>
<pre class="language-"><code class="lang-c">out_drop<span class="token operator">:</span>
        <span class="token function">igb_unmap_and_free_tx_resource</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> NETDEV_TX_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Finally, some error handling code. This code is only hit if <code>igb_tso</code> hits an error of some kind. The <code>igb_unmap_and_free_tx_resource</code> is used to clean up data. <code>NETDEV_TX_OK</code> is returned in this case as well. The transmit was not successful, but the driver freed the resources associated and there is nothing left to do. Note that this driver does not increment packet drops in this case, but it probably should.</p>
<h3 id="igbtxmap"><a name="igbtxmap" class="anchor-navigation-ex-anchor" href="#igbtxmap"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.3. igb_tx_map</h3>
<p>The <code>igb_tx_map</code> function handles the details of mapping skb data to DMA-able regions of RAM. It also updates the transmit queue&#x2019;s tail pointer on the device, which is what triggers the device to &#x201C;wake up&#x201D;, fetch the data from RAM, and begin transmitting the data.</p>
<p>Let&#x2019;s take a look, briefly, at how <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L4501-L4627" target="_blank">this function</a> works:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">igb_tx_map</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">igb_ring</span> <span class="token operator">*</span>tx_ring<span class="token punctuation">,</span>
                       <span class="token keyword">struct</span> <span class="token class-name">igb_tx_buffer</span> <span class="token operator">*</span>first<span class="token punctuation">,</span>
                       <span class="token keyword">const</span> u8 hdr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb <span class="token operator">=</span> first<span class="token operator">-&gt;</span>skb<span class="token punctuation">;</span>

                <span class="token comment">/* ... other variables ... */</span>

        u32 tx_flags <span class="token operator">=</span> first<span class="token operator">-&gt;</span>tx_flags<span class="token punctuation">;</span>
        u32 cmd_type <span class="token operator">=</span> <span class="token function">igb_tx_cmd_type</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> tx_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        u16 i <span class="token operator">=</span> tx_ring<span class="token operator">-&gt;</span>next_to_use<span class="token punctuation">;</span>

        tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">igb_tx_olinfo_status</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> tx_desc<span class="token punctuation">,</span> tx_flags<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len <span class="token operator">-</span> hdr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

        size <span class="token operator">=</span> <span class="token function">skb_headlen</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        data_len <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>data_len<span class="token punctuation">;</span>

        dma <span class="token operator">=</span> <span class="token function">dma_map_single</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> size<span class="token punctuation">,</span> DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The code above does a few things:</p>
<ol>
<li>Declares a set of variables and initializes them.</li>
<li>Uses the <code>IGB_TX_DESC</code> macro to determine obtain a reference to the next available descriptor.</li>
<li><code>igb_tx_olinfo_status</code> will update the <code>tx_flags</code> and copy them into the descriptor (<code>tx_desc</code>).</li>
<li>The size and data length are captured so they can be used later.</li>
<li><code>dma_map_single</code> is used to construct any memory mapping necessary to obtain a DMA-able address for <code>skb-&gt;data</code>. This is done so that the device can read the packet data from memory.</li>
</ol>
<p>What follows next is a very dense loop in the driver to deal with generating a valid mapping for each fragment of a skb. The details of how exactly this happens are not particularly important, but are worth mentioning:</p>
<ul>
<li>The driver iterates across the set of packet fragments.</li>
<li>The current descriptor has the DMA address of the data filled in.</li>
<li>If the size of the fragment is larger than what a single IGB descriptor can transmit, multiple descriptors are constructed to point to chunks of the DMA-able region until the entire fragment is pointed to by descriptors.</li>
<li>The descriptor iterator is bumped.</li>
<li>The remaining length is reduced.</li>
<li>The loop terminates when either: no fragments are remaining or the entire data length has been consumed.</li>
</ul>
<p>The code for the loop is provided below for reference with the above description. This should illustrate further to readers that avoiding fragmentation, if at all possible, is a good idea. Lots of additional code needs to run to deal with it at every layer of the stack, including the driver.</p>
<pre class="language-"><code class="lang-c">        tx_buffer <span class="token operator">=</span> first<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>frag <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>frags<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span> frag<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dma_mapping_error</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> dma<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">goto</span> dma_error<span class="token punctuation">;</span>

                <span class="token comment">/* record length, and DMA address */</span>
                <span class="token function">dma_unmap_len_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">dma_unmap_addr_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> dma<span class="token punctuation">,</span> dma<span class="token punctuation">)</span><span class="token punctuation">;</span>

                tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>buffer_addr <span class="token operator">=</span> <span class="token function">cpu_to_le64</span><span class="token punctuation">(</span>dma<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> IGB_MAX_DATA_PER_TXD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span>
                                <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>cmd_type <span class="token operator">^</span> IGB_MAX_DATA_PER_TXD<span class="token punctuation">)</span><span class="token punctuation">;</span>

                        i<span class="token operator">++</span><span class="token punctuation">;</span>
                        tx_desc<span class="token operator">++</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>olinfo_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

                        dma <span class="token operator">+=</span> IGB_MAX_DATA_PER_TXD<span class="token punctuation">;</span>
                        size <span class="token operator">-=</span> IGB_MAX_DATA_PER_TXD<span class="token punctuation">;</span>

                        tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>buffer_addr <span class="token operator">=</span> <span class="token function">cpu_to_le64</span><span class="token punctuation">(</span>dma<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>data_len<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>

                tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>cmd_type <span class="token operator">^</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

                i<span class="token operator">++</span><span class="token punctuation">;</span>
                tx_desc<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>olinfo_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

                size <span class="token operator">=</span> <span class="token function">skb_frag_size</span><span class="token punctuation">(</span>frag<span class="token punctuation">)</span><span class="token punctuation">;</span>
                data_len <span class="token operator">-=</span> size<span class="token punctuation">;</span>

                dma <span class="token operator">=</span> <span class="token function">skb_frag_dma_map</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> frag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                                       size<span class="token punctuation">,</span> DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>

                tx_buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_buffer_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>Once all the necessary descriptors have been constructed and all of the skb&#x2019;s data has been mapped to DMA-able addresses, the driver proceeds to its final steps to trigger a transmit:</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* write last descriptor with RS and EOP bits */</span>
        cmd_type <span class="token operator">|=</span> size <span class="token operator">|</span> IGB_TXD_DCMD<span class="token punctuation">;</span>
        tx_desc<span class="token operator">-&gt;</span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>cmd_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>A terminating descriptor is written to indicate to the device that it is the last descriptor.</p>
<pre class="language-"><code class="lang-c">        <span class="token function">netdev_tx_sent_queue</span><span class="token punctuation">(</span><span class="token function">txring_txq</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">,</span> first<span class="token operator">-&gt;</span>bytecount<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* set the timestamp */</span>
        first<span class="token operator">-&gt;</span>time_stamp <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
</code></pre>
<p>The <code>netdev_tx_sent_queue</code> function is called with the number of bytes being added to this transmit queue. This function is part of the byte query limit feature that we&#x2019;ll see shortly in more detail. The current jiffies are stored in the first buffer info structure.</p>
<p>Next, something a bit tricky:</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* Force memory writes to complete before letting h/w know there
         * are new descriptors to fetch.  (Only applicable for weak-ordered
         * memory model archs, such as IA-64).
         *
         * We also need this memory barrier to make certain all of the
         * status bits have been updated before next_to_watch is written.
         */</span>
        <span class="token function">wmb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* set next_to_watch value indicating a packet is present */</span>
        first<span class="token operator">-&gt;</span>next_to_watch <span class="token operator">=</span> tx_desc<span class="token punctuation">;</span>

        i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span>
                i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        tx_ring<span class="token operator">-&gt;</span>next_to_use <span class="token operator">=</span> i<span class="token punctuation">;</span>

        <span class="token function">writel</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> tx_ring<span class="token operator">-&gt;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* we need this if more than one processor can write to our tail
         * at a time, it synchronizes IO on IA64/Altix systems
         */</span>
        <span class="token function">mmiowb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span><span class="token punctuation">;</span>
</code></pre>
<p>The code above is doing a few important things:</p>
<p>1.Start by using the <code>wmb</code> function is called to force memory writes to complete. This executed as a special instruction appropriate for the CPU platform and is commonly referred to as a &#x201C;write barrier.&#x201D; This is important on certain CPU architectures because if we trigger the device to start DMA without ensuring that all memory writes to update internal state have completed, the device may read data from RAM that is not in a consistent state. <a href="http://preshing.com/20120930/weak-vs-strong-memory-models/" target="_blank">This article</a> and this <a href="http://www.cs.utexas.edu/~pingali/CS378/2012fa/lectures/consistency.pdf" target="_blank">lecture</a> dive into the details on memory ordering.</p>
<ol>
<li>The <code>next_to_watch</code> field is set. It will be used later during the completion phase.</li>
<li>Counters are bumped, and the <code>next_to_use</code> field of the transmit queue is updated to the next available descriptor.</li>
<li>The transmit queue&#x2019;s tail is updated with a <code>writel</code> function. <code>writel</code> writes a &#x201C;long&#x201D; to a <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O" target="_blank">memory mapped I/O</a> address. In this case, the address is <code>tx_ring-&gt;tail</code> (which is a hardware address) and the value to be written is <code>i</code>. This write to the device triggers the device to let it know that additional data is ready to be DMA&#x2019;d from RAM and written to the network.</li>
<li>Finally, call the <code>mmiowb</code> function. This function will execute the appropriate instruction for the CPU architecture causing memory mapped write operations to be ordered. It is also a write barrier, but for memory mapped I/O writes.</li>
</ol>
<p>You can read some excellent <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/memory-barriers.txt" target="_blank">documentation about memory barriers</a> included with the Linux kernel, if you are curious to learn more about <code>wmb</code>, <code>mmiowb</code>, and when to use them.</p>
<p>Finally, the code wraps up with some error handling. This code only executes if an error was returned from the DMA API when attemtping to map skb data addresses to DMA-able addresses.</p>
<pre class="language-"><code class="lang-c">dma_error<span class="token operator">:</span>
        <span class="token function">dev_err</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token string">&quot;TX DMA map failed\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* clear dma mappings for failed tx_buffer_info map */</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tx_buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_buffer_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token function">igb_unmap_and_free_tx_resource</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> tx_buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tx_buffer <span class="token operator">==</span> first<span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        i <span class="token operator">=</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
                i<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        tx_ring<span class="token operator">-&gt;</span>next_to_use <span class="token operator">=</span> i<span class="token punctuation">;</span>
</code></pre>
<p>Before moving on to the transmit completion, let&#x2019;s examine something we passed over above: dynamic queue limits.</p>
<h4 id="dynamic-queue-limits-dql"><a name="dynamic-queue-limits-dql" class="anchor-navigation-ex-anchor" href="#dynamic-queue-limits-dql"><i class="fa fa-link" aria-hidden="true"></i></a>Dynamic Queue Limits (DQL)</h4>
<p>As you&#x2019;ve seen throughout this post, network data spends a lot of time sitting queues at various stages as it moves closer and closer to the device for transmission. As queue sizes increase, packets spend longer sitting in queues not being transmit i.e. packet transmit latency increases as queue size increases.</p>
<p>One way to fight this is with back pressure. The dynamic queue limit (DQL) system is a mechanism that device drivers can use to apply back pressure to the networking system to prevent too much data from being queued for transmit when the device is unable to transmit,</p>
<p>To use this system, network device drivers need to make a few simple API calls during their transmit and completion routines. The DQL system internally will use an algorithm to determine when sufficient data is in transmit. Once this limit is reached, the transmit queue will be temporarily disabled. This queue disabling is what produces the back pressure against the networking system. The queue will be automatically re-enabled when the DQL system determines enough data has finished transmission.</p>
<p>Check out this excellent set of <a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf" target="_blank">slides about the DQL system</a> for some performance data and an explanation of the internal algorithm in DQL.</p>
<p>The function <code>netdev_tx_sent_queue</code> called in the code we just saw is part of the DQL API. This function is called when data is queued to the device for transmit. Once the transmit completes, the driver calls <code>netdev_tx_completed_queue</code>. Internally, both of these functions will call into the DQL library (found in <a href="https://github.com/torvalds/linux/blob/v3.13/lib/dynamic_queue_limits.c" target="_blank">./lib/dynamic_queue_limits.c</a> and <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/dynamic_queue_limits.h" target="_blank">./include/linux/dynamic_queue_limits.h</a>) to determine if the transmit queue should be disabled, re-enabled, or left as-is.</p>
<p>DQL exports statistics and tuning knobs in sysfs. Tuning DQL should not be necessary; the algorithm will adjust its parameters over time. Nevertheless, in the interest of completeness we&#x2019;ll see later how to monitor and tune DQL.</p>
<h3 id="transmit-completions"><a name="transmit-completions" class="anchor-navigation-ex-anchor" href="#transmit-completions"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.4. Transmit completions</h3>
<p>Once the device has transmit the data, it will generate an interrupt to signal that transmission is complete. The device driver can then schedule some long running work to be completed, like unmapping memory regions and freeing data. How exactly this works is device specific. In the case of the <code>igb</code> driver (and its associated devices), the same IRQ is fired for transmit completion and packet receive. This means that for the <code>igb</code> driver the <code>NET_RX</code> is used to process <em>both</em> transmit completions and incoming packet receives.</p>
<p>Let me re-state that to emphasize the importance of this: your device may raise the same interrupt for receiving packets that it raises to signal that a packet transmit has completed. If it does, the <code>NET_RX</code> softirq runs to process <em>both</em> incoming packets and transmit completions.</p>
<p>Since both operations share the same IRQ, only a single IRQ handler function can be registered and it must deal with both possible cases. Recall the following flow when network data is received:</p>
<ol>
<li>Network data is received.</li>
<li>The network device raises an IRQ.</li>
<li>The device driver&#x2019;s IRQ handler executes, clearing the IRQ and ensuring that a <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#softirqs" target="_blank">softIRQ</a> is scheduled to run (if not running already). This softIRQ that is triggered here is the <code>NET_RX</code> softIRQ.</li>
<li>The softIRQ executes essentially as a separate kernel thread. It runs and implements the <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi" target="_blank">NAPI</a> poll loop.</li>
<li>The NAPI poll loop is simply a piece of code which executes in loop harvesting packets as long as sufficient budget is available.</li>
<li>Each time a packet is processed, the budget is decreased until there are no more packets to process, the budget reaches 0, or the time slice has expired.</li>
</ol>
<p>Step 5 above in the <code>igb</code> driver (and the <code>ixgbe</code> driver [greetings, tyler]) processes TX completions before processing incoming data. Keep in mind that depending on the implementation of the driver, both processing functions for TX completions and incoming data may share the same processing budget. The <code>igb</code> and <code>ixgbe</code> drivers track the TX completion and incoming packet budgets separately, so processing TX completions will not necessarily exhaust the RX budget.</p>
<p>That said, the entire NAPI poll loop runs <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#netrxaction-processing-loop" target="_blank">within a hard coded time slice</a>. This means that if you have a lot of TX completion processing to handle, TX completions may eat more of the time slice than processing incoming data does. This may be an important consideration for those running network hardware in very high load environments.</p>
<p>Let&#x2019;s see how this happens in practice for the <code>igb</code> driver.</p>
<h4 id="transmit-completion-irq"><a name="transmit-completion-irq" class="anchor-navigation-ex-anchor" href="#transmit-completion-irq"><i class="fa fa-link" aria-hidden="true"></i></a>Transmit completion IRQ</h4>
<p>Instead of restating information already covered in the <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank">Linux kernel receive side networking blog post</a>, this post will instead list the steps in order and link to the appropriate sections in the receive side blog post until transmit completions are reached.</p>
<p>So, let&#x2019;s start from the beginning:</p>
<ol>
<li>The network device is <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#bringing-a-network-device-up" target="_blank">brought up</a>.</li>
<li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#register-an-interrupt-handler" target="_blank">IRQ handlers are registered</a>.</li>
<li>The user program sends data to a network socket. The data travels the network stack until the device fetches it from memory and transmits it.</li>
<li>The device finishes transmitting the data and raises an IRQ to signal transmit completion.</li>
<li>The driver&#x2019;s <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#interrupt-handler" target="_blank">IRQ handler executes to handle the interrupt</a>.</li>
<li>The IRQ handler calls <code>napi_schedule</code> in response to the IRQ.</li>
<li>The <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi-and-napischedule" target="_blank">NAPI code</a> triggers the <code>NET_RX</code> softirq to execute.</li>
<li>The <code>NET_RX</code> sofitrq function, <code>net_rx_action</code> <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#network-data-processing-begins" target="_blank">begins to execute</a>.</li>
<li>The <code>net_rx_action</code> function calls the <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi-poll-function-and-weight" target="_blank">driver&#x2019;s registered NAPI poll function</a>.</li>
<li>The NAPI poll function, <code>igb_poll</code>, <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#igbpoll" target="_blank">is executed</a>.</li>
</ol>
<p>The poll function <code>igb_poll</code> is where the code splits off and processes both incoming packets and transmit completions. Let&#x2019;s dive into the code for this function and see where that happens.</p>
<h4 id="igbpoll"><a name="igbpoll" class="anchor-navigation-ex-anchor" href="#igbpoll"><i class="fa fa-link" aria-hidden="true"></i></a><code>igb_poll</code></h4>
<p>Let&#x2019;s take a look at the code for <code>igb_poll</code> (from <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L5987-L6018" target="_blank">./drivers/net/ethernet/intel/igb/igb_main.c</a>):</p>
<pre class="language-"><code class="lang-c"><span class="token comment">/**
 *  igb_poll - NAPI Rx polling callback
 *  @napi: napi polling structure
 *  @budget: count of how many packets we should handle
 **/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">napi_struct</span> <span class="token operator">*</span>napi<span class="token punctuation">,</span> <span class="token keyword">int</span> budget<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">igb_q_vector</span> <span class="token operator">*</span>q_vector <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>napi<span class="token punctuation">,</span>
                                                     <span class="token keyword">struct</span> <span class="token class-name">igb_q_vector</span><span class="token punctuation">,</span>
                                                     napi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        bool clean_complete <span class="token operator">=</span> true<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_IGB_DCA</span></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q_vector<span class="token operator">-&gt;</span>adapter<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IGB_FLAG_DCA_ENABLED<span class="token punctuation">)</span>
                <span class="token function">igb_update_dca</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q_vector<span class="token operator">-&gt;</span>tx<span class="token punctuation">.</span>ring<span class="token punctuation">)</span>
                clean_complete <span class="token operator">=</span> <span class="token function">igb_clean_tx_irq</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>q_vector<span class="token operator">-&gt;</span>rx<span class="token punctuation">.</span>ring<span class="token punctuation">)</span>
                clean_complete <span class="token operator">&amp;=</span> <span class="token function">igb_clean_rx_irq</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">,</span> budget<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* If all work not completed, return budget and keep polling */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clean_complete<span class="token punctuation">)</span>
                <span class="token keyword">return</span> budget<span class="token punctuation">;</span>

        <span class="token comment">/* If not enough Rx work done, exit the polling mode */</span>
        <span class="token function">napi_complete</span><span class="token punctuation">(</span>napi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">igb_ring_irq_enable</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function performs a few operations, in order:</p>
<ol>
<li>If <a href="https://lwn.net/Articles/247493/" target="_blank">Direct Cache Access (DCA)</a> support is enabled in the kernel, the CPU cache is warmed so that accesses to the RX ring will hit CPU cache. You can <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#direct-cache-access-dca" target="_blank">read more about DCA in the Extras section</a> of the receive side networking post.</li>
<li><code>igb_clean_tx_irq</code> is called which performs the transmit completion operations.</li>
<li><code>igb_clean_rx_irq</code> is called next which performs the incoming packet processing.</li>
<li>Finally, <code>clean_complete</code> is checked to determine if there was still more work that could have been done. If so, the <code>budget</code> is returned. If this happens, <code>net_rx_action</code> will move this NAPI structure to the end of the poll list to be processed again later.</li>
</ol>
<p>To learn more about how <code>igb_clean_rx_irq</code> works, read <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#igbcleanrxirq" target="_blank">this section</a> of the previous blog post.</p>
<p>This blog post is concerned primarily with the transmit side, so we&#x2019;ll continue by examining how <code>igb_clean_tx_irq</code> above works.</p>
<h4 id="igbcleantxirq"><a name="igbcleantxirq" class="anchor-navigation-ex-anchor" href="#igbcleantxirq"><i class="fa fa-link" aria-hidden="true"></i></a><code>igb_clean_tx_irq</code></h4>
<p>Take a look at the source for this function in <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L6020-L6189" target="_blank">./drivers/net/ethernet/intel/igb/igb_main.c</a>.</p>
<p>It&#x2019;s a bit long, so we&#x2019;ll break it into chunks and go through it:</p>
<pre class="language-"><code class="lang-c"><span class="token keyword">static</span> bool <span class="token function">igb_clean_tx_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">igb_q_vector</span> <span class="token operator">*</span>q_vector<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">igb_adapter</span> <span class="token operator">*</span>adapter <span class="token operator">=</span> q_vector<span class="token operator">-&gt;</span>adapter<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">igb_ring</span> <span class="token operator">*</span>tx_ring <span class="token operator">=</span> q_vector<span class="token operator">-&gt;</span>tx<span class="token punctuation">.</span>ring<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">igb_tx_buffer</span> <span class="token operator">*</span>tx_buffer<span class="token punctuation">;</span>
        <span class="token keyword">union</span> e1000_adv_tx_desc <span class="token operator">*</span>tx_desc<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> total_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> total_packets <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> budget <span class="token operator">=</span> q_vector<span class="token operator">-&gt;</span>tx<span class="token punctuation">.</span>work_limit<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> tx_ring<span class="token operator">-&gt;</span>next_to_clean<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_bit</span><span class="token punctuation">(</span>__IGB_DOWN<span class="token punctuation">,</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>
</code></pre>
<p>The function begins by initializing some useful variables. One important one to take a look at is <code>budget</code>. As you can see above <code>budget</code> is initialized to this queue&#x2019;s <code>tx.work_limit</code>. In the <code>igb</code> driver, <code>tx.work_limit</code> is initialized to a hardcoded value <code>IGB_DEFAULT_TX_WORK</code> (128).</p>
<p>It is important to note that while the TX completion code we are looking at now runs in the same <code>NET_RX</code> softirq as receive processing does, the TX and RX functions do not share a processing budget with each other in the <code>igb</code> driver. Since the entire poll function runs within the same <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#netrxaction-processing-loop" target="_blank">time slice</a>, it is not possible for a single run of the <code>igb_poll</code> function to starve incoming packet processing or transmit completions. As long as <code>igb_poll</code> is called, both will be handled.</p>
<p>Moving on, the snippet of code above finishes by checking if the network device is down. If so, it returns <code>true</code> and exits <code>igb_clean_tx_irq</code>.</p>
<pre class="language-"><code class="lang-c">        tx_buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_buffer_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">-=</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
</code></pre>
<ol>
<li>The <code>tx_buffer</code> variable is initialized to transmit buffer info structure at location <code>tx_ring-&gt;next_to_clean</code> (which itself is initialized to <code>0</code>).</li>
<li>A reference to the associated descriptor is obtained and stored in <code>tx_desc</code>.</li>
<li>The counter <code>i</code> is decreased by the size of the transmit queue. This value can be adjusted (as we&#x2019;ll see in the tuning section), but is initialized to <code>IGB_DEFAULT_TXD</code> (256).</li>
</ol>
<p>Next, a loop begins. It includes some helpful comments to explain what is happening at each step:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token keyword">union</span> e1000_adv_tx_desc <span class="token operator">*</span>eop_desc <span class="token operator">=</span> tx_buffer<span class="token operator">-&gt;</span>next_to_watch<span class="token punctuation">;</span>

                <span class="token comment">/* if next_to_watch is not set then there is no work pending */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>eop_desc<span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token comment">/* prevent any other reads prior to eop_desc */</span>
                <span class="token function">read_barrier_depends</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">/* if DD is not set pending work has not been completed */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>eop_desc<span class="token operator">-&gt;</span>wb<span class="token punctuation">.</span>status <span class="token operator">&amp;</span> <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>E1000_TXD_STAT_DD<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token comment">/* clear next_to_watch to prevent false hangs */</span>
                tx_buffer<span class="token operator">-&gt;</span>next_to_watch <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

                <span class="token comment">/* update the statistics for this packet */</span>
                total_bytes <span class="token operator">+=</span> tx_buffer<span class="token operator">-&gt;</span>bytecount<span class="token punctuation">;</span>
                total_packets <span class="token operator">+=</span> tx_buffer<span class="token operator">-&gt;</span>gso_segs<span class="token punctuation">;</span>

                <span class="token comment">/* free the skb */</span>
                <span class="token function">dev_kfree_skb_any</span><span class="token punctuation">(</span>tx_buffer<span class="token operator">-&gt;</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">/* unmap skb header data */</span>
                <span class="token function">dma_unmap_single</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span>
                                 <span class="token function">dma_unmap_addr</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> dma<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 <span class="token function">dma_unmap_len</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">/* clear tx_buffer data */</span>
                tx_buffer<span class="token operator">-&gt;</span>skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                <span class="token function">dma_unmap_len_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol>
<li>First <code>eop_desc</code> is set to the buffer&#x2019;s <code>next_to_watch</code> field. This was set in the transmit code we saw earlier.</li>
<li>If <code>eop_desc</code> (eop = end of packet) is <code>NULL</code>, then there is no work pending.</li>
<li>The <code>read_barrier_depends</code> function is called, which will execute the appropriate CPU instruction for this CPU architecture to prevent reads from being reordered over this barrier.</li>
<li>Next, a status bit is checked in the end of packet descriptor <code>eop_desc</code>. If the <code>E1000_TXD_STAT_DD</code> bit is not set, then the transmit has not completed yet, so break from the loop.</li>
<li>Clear the <code>tx_buffer-&gt;next_to_watch</code>. A watchdog timer in the driver will be watching this field to determine if a transmit was hung. Clearing this field will prevent the watchdog from triggering.</li>
<li>Statistics counters are updated for total bytes and packets sent. These will be copied into the statistics counters that the driver reads once all descriptors have been processed.</li>
<li>The skb is freed.</li>
<li><code>dma_unmap_single</code> is used to unmap the skb data region.</li>
<li>The <code>tx_buffer-&gt;skb</code> is set to <code>NULL</code> and the <code>tx_buffer</code> is unmapped.</li>
</ol>
<p>Next, another loop is started inside of the loop above:</p>
<pre class="language-"><code class="lang-c">                <span class="token comment">/* clear last DMA location and unmap remaining buffers */</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>tx_desc <span class="token operator">!=</span> eop_desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        tx_buffer<span class="token operator">++</span><span class="token punctuation">;</span>
                        tx_desc<span class="token operator">++</span><span class="token punctuation">;</span>
                        i<span class="token operator">++</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                i <span class="token operator">-=</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
                                tx_buffer <span class="token operator">=</span> tx_ring<span class="token operator">-&gt;</span>tx_buffer_info<span class="token punctuation">;</span>
                                tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>

                        <span class="token comment">/* unmap any remaining paged data */</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dma_unmap_len</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">dma_unmap_page</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span>
                                               <span class="token function">dma_unmap_addr</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> dma<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                               <span class="token function">dma_unmap_len</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                               DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token function">dma_unmap_len_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
</code></pre>
<p>This inner loop will loop over each transmit descriptor until <code>tx_desc</code> arrives at the <code>eop_desc</code>. This code unmaps data referenced by any of the additional descriptors.</p>
<p>The outer loop continues:</p>
<pre class="language-"><code class="lang-c">                <span class="token comment">/* move us one more past the eop_desc for start of next pkt */</span>
                tx_buffer<span class="token operator">++</span><span class="token punctuation">;</span>
                tx_desc<span class="token operator">++</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        i <span class="token operator">-=</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
                        tx_buffer <span class="token operator">=</span> tx_ring<span class="token operator">-&gt;</span>tx_buffer_info<span class="token punctuation">;</span>
                        tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">/* issue prefetch for next Tx descriptor */</span>
                <span class="token function">prefetch</span><span class="token punctuation">(</span>tx_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">/* update budget accounting */</span>
                budget<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>budget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The outer loop increments iterators and reduces the <code>budget</code> value. The loop invariant is checked to determine if the loop should continue.</p>
<pre class="language-"><code class="lang-c">        <span class="token function">netdev_tx_completed_queue</span><span class="token punctuation">(</span><span class="token function">txring_txq</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  total_packets<span class="token punctuation">,</span> total_bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">+=</span> tx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
        tx_ring<span class="token operator">-&gt;</span>next_to_clean <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token function">u64_stats_update_begin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_syncp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tx_ring<span class="token operator">-&gt;</span>tx_stats<span class="token punctuation">.</span>bytes <span class="token operator">+=</span> total_bytes<span class="token punctuation">;</span>
        tx_ring<span class="token operator">-&gt;</span>tx_stats<span class="token punctuation">.</span>packets <span class="token operator">+=</span> total_packets<span class="token punctuation">;</span>
        <span class="token function">u64_stats_update_end</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_syncp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        q_vector<span class="token operator">-&gt;</span>tx<span class="token punctuation">.</span>total_bytes <span class="token operator">+=</span> total_bytes<span class="token punctuation">;</span>
        q_vector<span class="token operator">-&gt;</span>tx<span class="token punctuation">.</span>total_packets <span class="token operator">+=</span> total_packets<span class="token punctuation">;</span>
</code></pre>
<p>This code:</p>
<ol>
<li>Calls <code>netdev_tx_completed_queue</code>, which is part of the DQL API explained above. This will potentially re-enable a transmit queue if enough completions were processed.</li>
<li>Statistics are added to their appropriate places so that they can be accessed by the user as we&#x2019;ll see later.</li>
</ol>
<p>The code continues by first checking if the <code>IGB_RING_FLAG_TX_DETECT_HANG</code> flag is set. A watchdog timer sets this flag each time the timer callback is run, to enforce periodic checking of the transmit queue. If that flag happens to be on now, the code will continue and check if the transmit queue is hung:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_bit</span><span class="token punctuation">(</span>IGB_RING_FLAG_TX_DETECT_HANG<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>flags<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">e1000_hw</span> <span class="token operator">*</span>hw <span class="token operator">=</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>hw<span class="token punctuation">;</span>

                <span class="token comment">/* Detect a transmit hang in hardware, this serializes the
                 * check with the clearing of time_stamp and movement of i
                 */</span>
                <span class="token function">clear_bit</span><span class="token punctuation">(</span>IGB_RING_FLAG_TX_DETECT_HANG<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tx_buffer<span class="token operator">-&gt;</span>next_to_watch <span class="token operator">&amp;&amp;</span>
                    <span class="token function">time_after</span><span class="token punctuation">(</span>jiffies<span class="token punctuation">,</span> tx_buffer<span class="token operator">-&gt;</span>time_stamp <span class="token operator">+</span>
                               <span class="token punctuation">(</span>adapter<span class="token operator">-&gt;</span>tx_timeout_factor <span class="token operator">*</span> HZ<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">rd32</span><span class="token punctuation">(</span>E1000_STATUS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> E1000_STATUS_TXOFF<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                        <span class="token comment">/* detected Tx unit hang */</span>
                        <span class="token function">dev_err</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span>
                                <span class="token string">&quot;Detected Tx Unit Hang\n&quot;</span>
                                <span class="token string">&quot;  Tx Queue             &lt;%d&gt;\n&quot;</span>
                                <span class="token string">&quot;  TDH                  &lt;%x&gt;\n&quot;</span>
                                <span class="token string">&quot;  TDT                  &lt;%x&gt;\n&quot;</span>
                                <span class="token string">&quot;  next_to_use          &lt;%x&gt;\n&quot;</span>
                                <span class="token string">&quot;  next_to_clean        &lt;%x&gt;\n&quot;</span>
                                <span class="token string">&quot;buffer_info[next_to_clean]\n&quot;</span>
                                <span class="token string">&quot;  time_stamp           &lt;%lx&gt;\n&quot;</span>
                                <span class="token string">&quot;  next_to_watch        &lt;%p&gt;\n&quot;</span>
                                <span class="token string">&quot;  jiffies              &lt;%lx&gt;\n&quot;</span>
                                <span class="token string">&quot;  desc.status          &lt;%x&gt;\n&quot;</span><span class="token punctuation">,</span>
                                tx_ring<span class="token operator">-&gt;</span>queue_index<span class="token punctuation">,</span>
                                <span class="token function">rd32</span><span class="token punctuation">(</span><span class="token function">E1000_TDH</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>reg_idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                <span class="token function">readl</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>tail<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                tx_ring<span class="token operator">-&gt;</span>next_to_use<span class="token punctuation">,</span>
                                tx_ring<span class="token operator">-&gt;</span>next_to_clean<span class="token punctuation">,</span>
                                tx_buffer<span class="token operator">-&gt;</span>time_stamp<span class="token punctuation">,</span>
                                tx_buffer<span class="token operator">-&gt;</span>next_to_watch<span class="token punctuation">,</span>
                                jiffies<span class="token punctuation">,</span>
                                tx_buffer<span class="token operator">-&gt;</span>next_to_watch<span class="token operator">-&gt;</span>wb<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">netif_stop_subqueue</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>netdev<span class="token punctuation">,</span>
                                            tx_ring<span class="token operator">-&gt;</span>queue_index<span class="token punctuation">)</span><span class="token punctuation">;</span>

                        <span class="token comment">/* we are about to reset, no point in enabling stuff */</span>
                        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
</code></pre>
<p>The <code>if</code> statement above checks:</p>
<ul>
<li><code>tx_buffer-&gt;next_to_watch</code> is set, and</li>
<li>That the current <code>jiffies</code> is greater than the <code>time_stamp</code> recorded on the transmit path to the <code>tx_buffer</code> with a timeout factor added, and</li>
<li>The device&#x2019;s transmit status register is not set to <code>E1000_STATUS_TXOFF</code>.</li>
</ul>
<p>If those three tests are all true, then an error is printed that a hang has been detected. <code>netif_stop_subqueue</code> is used to turn off the queue and <code>true</code> is returned.</p>
<p>Let&#x2019;s continue reading the code to see what happens if there was no transmit hang check, or if there was, but no hang was detected:</p>
<pre class="language-"><code class="lang-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TX_WAKE_THRESHOLD</span> <span class="token expression"><span class="token punctuation">(</span>DESC_NEEDED <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>total_packets <span class="token operator">&amp;&amp;</span>
            <span class="token function">netif_carrier_ok</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>netdev<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">igb_desc_unused</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> TX_WAKE_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* Make sure that anybody stopping the queue after this
                 * sees the new next_to_clean.
                 */</span>
                <span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__netif_subqueue_stopped</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>netdev<span class="token punctuation">,</span>
                                             tx_ring<span class="token operator">-&gt;</span>queue_index<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">test_bit</span><span class="token punctuation">(</span>__IGB_DOWN<span class="token punctuation">,</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">netif_wake_subqueue</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-&gt;</span>netdev<span class="token punctuation">,</span>
                                            tx_ring<span class="token operator">-&gt;</span>queue_index<span class="token punctuation">)</span><span class="token punctuation">;</span>

                        <span class="token function">u64_stats_update_begin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_syncp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        tx_ring<span class="token operator">-&gt;</span>tx_stats<span class="token punctuation">.</span>restart_queue<span class="token operator">++</span><span class="token punctuation">;</span>
                        <span class="token function">u64_stats_update_end</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tx_ring<span class="token operator">-&gt;</span>tx_syncp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>budget<span class="token punctuation">;</span>
</code></pre>
<p>In the above code the driver will restart the transmit queue if it was previously disabled. It first checks if:</p>
<ul>
<li>Some packets were processed for completions (<code>total_packets</code> is non-zero), and</li>
<li><code>netif_carrier_ok</code> to ensure the device has not been brought down, and</li>
<li>The number of unused descriptors in the transmit queue is greater than or equal to <code>TX_WAKE_THRESHOLD</code>. This threshold value appears to be <code>42</code> on my x86_64 system.</li>
</ul>
<p>If all conditions are satisfied, a write barrier is used (<code>smp_mb</code>). Next another set of conditions are checked:</p>
<ul>
<li>If the queue is stopped, and</li>
<li>The device is not down</li>
</ul>
<p>Then <code>netif_wake_subqueue</code> called to wake up the transmit queue and signal to the higher layers that they may queue data again. The <code>restart_queue</code> statistics counter is incremented. We&#x2019;ll see how to read this value next.</p>
<p>Finally, a boolean value is returned. If there was any remaining un-used budget <code>true</code> is returned, otherwise <code>false</code>. This value is checked in <code>igb_poll</code> to determine what to return back to <code>net_rx_action</code>.</p>
<h4 id="igbpoll-return-value"><a name="igbpoll-return-value" class="anchor-navigation-ex-anchor" href="#igbpoll-return-value"><i class="fa fa-link" aria-hidden="true"></i></a><code>igb_poll</code> return value</h4>
<p>The <code>igb_poll</code> function has this code to determine what to return to <code>net_rx_action</code>:</p>
<pre class="language-"><code class="lang-c">        <span class="token keyword">if</span> <span class="token punctuation">(</span>q_vector<span class="token operator">-&gt;</span>tx<span class="token punctuation">.</span>ring<span class="token punctuation">)</span>
                clean_complete <span class="token operator">=</span> <span class="token function">igb_clean_tx_irq</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>q_vector<span class="token operator">-&gt;</span>rx<span class="token punctuation">.</span>ring<span class="token punctuation">)</span>
                clean_complete <span class="token operator">&amp;=</span> <span class="token function">igb_clean_rx_irq</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">,</span> budget<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* If all work not completed, return budget and keep polling */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clean_complete<span class="token punctuation">)</span>
                <span class="token keyword">return</span> budget<span class="token punctuation">;</span>
</code></pre>
<p>In other words, if:</p>
<ul>
<li><code>igb_clean_tx_irq</code> cleared all transmit completions without exhausting its transmit completion budget, and</li>
<li><code>igb_clean_rx_irq</code> cleared all incoming packets without exhausting its packet processing budget</li>
</ul>
<p>Then, the entire budget amount (which is hardcoded to <code>64</code> for most drivers including <code>igb</code>) will be returned. If either of RX or TX processing could not complete (because there was more work to do), then NAPI is disabled with a call to <code>napi_complete</code> and <code>0</code> is returned:</p>
<pre class="language-"><code class="lang-c">        <span class="token comment">/* If not enough Rx work done, exit the polling mode */</span>
        <span class="token function">napi_complete</span><span class="token punctuation">(</span>napi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">igb_ring_irq_enable</span><span class="token punctuation">(</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="monitoring-network-devices"><a name="monitoring-network-devices" class="anchor-navigation-ex-anchor" href="#monitoring-network-devices"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.5. Monitoring network devices</h3>
<p>There are several different ways to monitor your network devices offering different levels of granularity and complexity. Let&#x2019;s start with most granular and move to least granular.</p>
<h4 id="using-ethtool--s"><a name="using-ethtool--s" class="anchor-navigation-ex-anchor" href="#using-ethtool--s"><i class="fa fa-link" aria-hidden="true"></i></a>Using <code>ethtool -S</code></h4>
<p>You can install <code>ethtool</code> on an Ubuntu system by running: <code>sudo apt-get install ethtool</code>.</p>
<p>Once it is installed, you can access the statistics by passing the <code>-S</code> flag along with the name of the network device you want statistics about.</p>
<p>Monitor detailed NIC device statistics (e.g., transmit errors) with <code>ethtool -S</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">sudo</span> <span class="token function">ethtool</span> <span class="token parameter variable">-S</span> eth0
NIC statistics:
     rx_packets: <span class="token number">597028087</span>
     tx_packets: <span class="token number">5924278060</span>
     rx_bytes: <span class="token number">112643393747</span>
     tx_bytes: <span class="token number">990080156714</span>
     rx_broadcast: <span class="token number">96</span>
     tx_broadcast: <span class="token number">116</span>
     rx_multicast: <span class="token number">20294528</span>
     <span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre>
<p>Monitoring this data can be difficult. It is easy to obtain, but there is no standardization of the field values. Different drivers, or even different versions of the <em>same</em> driver might produce different field names that have the same meaning.</p>
<p>You should look for values with &#x201C;drop&#x201D;, &#x201C;buffer&#x201D;, &#x201C;miss&#x201D;, &#x201C;errors&#x201D; etc in the label. Next, you will have to read your driver source. You&#x2019;ll be able to determine which values are accounted for totally in software (e.g., incremented when there is no memory) and which values come directly from hardware via a register read. In the case of a register value, you should consult the data sheet for your hardware to determine what the meaning of the counter really is; many of the labels given via <code>ethtool</code> can be misleading.</p>
<h4 id="using-sysfs"><a name="using-sysfs" class="anchor-navigation-ex-anchor" href="#using-sysfs"><i class="fa fa-link" aria-hidden="true"></i></a>Using sysfs</h4>
<p>sysfs also provides a lot of statistics values, but they are slightly higher level than the direct NIC level stats provided.</p>
<p>You can find the number of dropped incoming network data frames for, e.g. eth0 by using <code>cat</code> on a file.</p>
<p>Monitor higher level NIC statistics with sysfs.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /sys/class/net/eth0/statistics/tx_aborted_errors
<span class="token number">2</span>
</code></pre>
<p>The counter values will be split into files like <code>tx_aborted_errors</code>, <code>tx_carrier_errors</code>, <code>tx_compressed</code>, <code>tx_dropped</code>, etc.</p>
<p>Unfortunately, it is up to the drivers to decide what the meaning of each field is, and thus, when to increment them and where the values come from. You may notice that some drivers count a certain type of error condition as a drop, but other drivers may count the same as a miss.</p>
<p>If these values are critical to you, you will need to read your driver source and device data sheet to understand exactly what your driver thinks each of these values means.</p>
<h4 id="using-procnetdev"><a name="using-procnetdev" class="anchor-navigation-ex-anchor" href="#using-procnetdev"><i class="fa fa-link" aria-hidden="true"></i></a>Using <code>/proc/net/dev</code></h4>
<p>An even higher level file is <code>/proc/net/dev</code> which provides high-level summary-esque information for each network adapter on the system.</p>
<p>Monitor high level NIC statistics by reading <code>/proc/net/dev</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /proc/net/dev
Inter-<span class="token operator">|</span>   Receive                                                <span class="token operator">|</span>  Transmit
 face <span class="token operator">|</span>bytes    packets errs drop fifo frame compressed multicast<span class="token operator">|</span>bytes    packets errs drop fifo colls carrier compressed
  eth0: <span class="token number">110346752214</span> <span class="token number">597737500</span>    <span class="token number">0</span>    <span class="token number">2</span>    <span class="token number">0</span>     <span class="token number">0</span>          <span class="token number">0</span>  <span class="token number">20963860</span> <span class="token number">990024805984</span> <span class="token number">6066582604</span>    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>       <span class="token number">0</span>          <span class="token number">0</span>
    lo: <span class="token number">428349463836</span> <span class="token number">1579868535</span>    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>          <span class="token number">0</span>         <span class="token number">0</span> <span class="token number">428349463836</span> <span class="token number">1579868535</span>    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>       <span class="token number">0</span>          <span class="token number">0</span>
</code></pre>
<p>This file shows a subset of the values you&#x2019;ll find in the sysfs files mentioned above, but it may serve as a useful general reference.</p>
<p>The caveat mentioned above applies here, as well: if these values are important to you, you will still need to read your driver source to understand exactly when, where, and why they are incremented to ensure your understanding of an error, drop, or fifo are the same as your driver.</p>
<h3 id="monitoring-dynamic-queue-limits"><a name="monitoring-dynamic-queue-limits" class="anchor-navigation-ex-anchor" href="#monitoring-dynamic-queue-limits"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.6. Monitoring dynamic queue limits</h3>
<p>You can monitor dynamic queue limits for a network device by reading the files located under: <code>/sys/class/net/NIC/queues/tx-QUEUE_NUMBER/byte_queue_limits/</code>.</p>
<p>Replacing <code>NIC</code> with your device name (<code>eth0</code>, <code>eth1</code>, etc) and <code>tx-QUEUE_NUMBER</code> with the transmit queue number (<code>tx-0</code>, <code>tx-1</code>, <code>tx-2</code>, etc).</p>
<p>Some of those files are:</p>
<ul>
<li><code>hold_time</code>: Initialized to <code>HZ</code> (a single hertz). If the queue has been full for <code>hold_time</code>, then the maximum size is decreased.</li>
<li><code>inflight</code>: This value is equal to (number of packets queued - number of packets completed). It is the current number of packets being transmit for which a completion has not been processed.</li>
<li><code>limit_max</code>: A hardcoded value, set to <code>DQL_MAX_LIMIT</code> (<code>1879048192</code> on my x86_64 system).</li>
<li><code>limit_min</code>: A hardcoded value, set to <code>0</code>.</li>
<li><code>limit</code>: A value between <code>limit_min</code> and <code>limit_max</code> which represents the current maximum number of objects which can be queued.</li>
</ul>
<p>Before modifying any of these values, it is strongly recommended to <a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf" target="_blank">read these presentation slides</a> for an in-depth explanation of the algorithm.</p>
<p>Monitor packet transmits in flight by reading <code>/sys/class/net/eth0/queues/tx-0/byte_queue_limits/inflight</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">cat</span> /sys/class/net/eth0/queues/tx-0/byte_queue_limits/inflight
<span class="token number">350</span>
</code></pre>
<h3 id="tuning-network-devices"><a name="tuning-network-devices" class="anchor-navigation-ex-anchor" href="#tuning-network-devices"><i class="fa fa-link" aria-hidden="true"></i></a>3.7.7. Tuning network devices</h3>
<h4 id="check-the-number-of-tx-queues-being-used"><a name="check-the-number-of-tx-queues-being-used" class="anchor-navigation-ex-anchor" href="#check-the-number-of-tx-queues-being-used"><i class="fa fa-link" aria-hidden="true"></i></a>Check the number of TX queues being used</h4>
<p>If your NIC and the device driver loaded on your system support multiple transmit queues, you can usually adjust the number of TX queues (also called TX channels), by using <code>ethtool</code>.</p>
<p>Check the number of NIC transmit queues with <code>ethtool</code></p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">sudo</span> <span class="token function">ethtool</span> <span class="token parameter variable">-l</span> eth0
Channel parameters <span class="token keyword">for</span> eth0:
Pre-set maximums:
RX:   <span class="token number">0</span>
TX:   <span class="token number">0</span>
Other:    <span class="token number">0</span>
Combined: <span class="token number">8</span>
Current hardware settings:
RX:   <span class="token number">0</span>
TX:   <span class="token number">0</span>
Other:    <span class="token number">0</span>
Combined: <span class="token number">4</span>
</code></pre>
<p>This output is displaying the pre-set maximums (enforced by the driver and the hardware) and the current settings.</p>
<p><strong>Note:</strong> not all device drivers will have support for this operation.</p>
<p>Error seen if your NIC doesn&apos;t support this operation.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">sudo</span> <span class="token function">ethtool</span> <span class="token parameter variable">-l</span> eth0
Channel parameters <span class="token keyword">for</span> eth0:
Cannot get device channel parameters
<span class="token builtin class-name">:</span> Operation not supported
</code></pre>
<p>This means that your driver has not implemented the ethtool <code>get_channels</code> operation. This could be because the NIC doesn&#x2019;t support adjusting the number of queues, doesn&#x2019;t support multiple transmit queues, or your driver has not been updated to handle this feature.</p>
<h4 id="adjust-the-number-of-tx-queues-used"><a name="adjust-the-number-of-tx-queues-used" class="anchor-navigation-ex-anchor" href="#adjust-the-number-of-tx-queues-used"><i class="fa fa-link" aria-hidden="true"></i></a>Adjust the number of TX queues used</h4>
<p>Once you&#x2019;ve found the current and maximum queue count, you can adjust the values by using <code>sudo ethtool -L</code>.</p>
<p><strong>Note:</strong> some devices and their drivers only support combined queues that are paired for transmit and receive, as in the example in the above section.</p>
<p>Set combined NIC transmit and receive queues to 8 with <code>ethtool -L</code></p>
<p><code>$ sudo ethtool -L eth0 combined 8</code></p>
<p>If your device and driver support individual settings for RX and TX and you&#x2019;d like to change only the TX queue count to 8, you would run:</p>
<p>Set the number of NIC transmit queues to 8 with <code>ethtool -L</code>.</p>
<p><code>$ sudo ethtool -L eth0 tx 8</code></p>
<p><strong>Note:</strong> making these changes will, for most drivers, take the interface down and then bring it back up; connections to this interface will be interrupted. This may not matter much for a one-time change, though.</p>
<h4 id="adjust-the-size-of-the-tx-queues"><a name="adjust-the-size-of-the-tx-queues" class="anchor-navigation-ex-anchor" href="#adjust-the-size-of-the-tx-queues"><i class="fa fa-link" aria-hidden="true"></i></a>Adjust the size of the TX queues</h4>
<p>Some NICs and their drivers also support adjusting the size of the TX queue. Exactly how this works is hardware specific, but luckily <code>ethtool</code> provides a generic way for users to adjust the size. Increasing the size of the TX may not make a drastic difference because DQL is used to prevent higher layer networking code from queueing more data at times. Nevertheless, you may want to increase the TX queues to the maximum size and let DQL sort everything else out for you:</p>
<p>Check current NIC queue sizes with <code>ethtool -g</code></p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">sudo</span> <span class="token function">ethtool</span> <span class="token parameter variable">-g</span> eth0
Ring parameters <span class="token keyword">for</span> eth0:
Pre-set maximums:
RX:   <span class="token number">4096</span>
RX Mini:  <span class="token number">0</span>
RX Jumbo: <span class="token number">0</span>
TX:   <span class="token number">4096</span>
Current hardware settings:
RX:   <span class="token number">512</span>
RX Mini:  <span class="token number">0</span>
RX Jumbo: <span class="token number">0</span>
TX:   <span class="token number">512</span>
</code></pre>
<p>the above output indicates that the hardware supports up to 4096 receive and transmit descriptors, but it is currently only using 512.</p>
<p>Increase size of each TX queue to 4096 with <code>ethtool -G</code></p>
<p><code>$ sudo ethtool -G eth0 tx 4096</code></p>
<p><strong>Note:</strong> making these changes will, for most drivers, take the interface down and then bring it back up; connections to this interface will be interrupted. This may not matter much for a one-time change, though.</p>
<h2 id="the-end"><a name="the-end" class="anchor-navigation-ex-anchor" href="#the-end"><i class="fa fa-link" aria-hidden="true"></i></a>3.8. The End</h2>
<p>The end! Now you know everything about how packet transmit works on Linux: from the user program to the device driver and back.</p>
<h1 id="extras"><a name="extras" class="anchor-navigation-ex-anchor" href="#extras"><i class="fa fa-link" aria-hidden="true"></i></a>4. Extras</h1>
<p>There are a few extra things worth mentioning that are worth mentioning which didn&#x2019;t seem quite right anywhere else.</p>
<h2 id="reducing-arp-traffic-msgconfirm"><a name="reducing-arp-traffic-msgconfirm" class="anchor-navigation-ex-anchor" href="#reducing-arp-traffic-msgconfirm"><i class="fa fa-link" aria-hidden="true"></i></a>4.1. Reducing ARP traffic (MSG_CONFIRM)</h2>
<p>The <code>send</code>, <code>sendto</code>, and and <code>sendmsg</code> system calls all take a <code>flags</code> parameter. If you pass the <code>MSG_CONFIRM</code> flag to these system calls from your application, it will cause the <code>dst_neigh_output</code> function in the kernel on the send path to update the timestamp of the neighbour structure. The consequence of this is that the neighbour structure will not be garbage collected. This prevents additional ARP traffic from being generated as the neighbour cache entry will stay warmer, longer.</p>
<h2 id="udp-corking_1"><a name="udp-corking_1" class="anchor-navigation-ex-anchor" href="#udp-corking_1"><i class="fa fa-link" aria-hidden="true"></i></a>4.2. UDP Corking</h2>
<p>We examined UDP corking extensively throughout the UDP protocol stack. If you want to use it in your application, you can enable UDP corking by calling <code>setsockopt</code> with level set to <code>IPPROTO_UDP</code>, optname set to <code>UDP_CORK</code>, and <code>optval</code> set to <code>1</code>.</p>
<h2 id="timestamping"><a name="timestamping" class="anchor-navigation-ex-anchor" href="#timestamping"><i class="fa fa-link" aria-hidden="true"></i></a>4.3. Timestamping</h2>
<p>As mentioned in the above blog post, the networking stack can collect timestamps of outgoing data. See the above network stack walkthrough to see where transmit timestamping happens in software. Some NICs even support timestamping in hardware, too.</p>
<p>This is a useful feature if you&#x2019;d like to try to determine how much latency the kernel network stack is adding to sending packets.</p>
<p>The <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/timestamping.txt" target="_blank">kernel documentation about timestamping</a> is excellent and there is even an included sample program and Makefile <a href="https://github.com/torvalds/linux/tree/v3.13/Documentation/networking/timestamping" target="_blank">you can check out!</a>.</p>
<p>Determine which timestamp modes your driver and device support with <code>ethtool -T</code>.</p>
<pre class="language-"><code class="lang-shell">$ <span class="token function">sudo</span> <span class="token function">ethtool</span> <span class="token parameter variable">-T</span> eth0
Time stamping parameters <span class="token keyword">for</span> eth0:
Capabilities:
  software-transmit     <span class="token punctuation">(</span>SOF_TIMESTAMPING_TX_SOFTWARE<span class="token punctuation">)</span>
  software-receive      <span class="token punctuation">(</span>SOF_TIMESTAMPING_RX_SOFTWARE<span class="token punctuation">)</span>
  software-system-clock <span class="token punctuation">(</span>SOF_TIMESTAMPING_SOFTWARE<span class="token punctuation">)</span>
PTP Hardware Clock: none
Hardware Transmit Timestamp Modes: none
Hardware Receive Filter Modes: none
</code></pre>
<p>This NIC, unfortunately, does not support hardware transmit timestamping, but software timestamping can still be used on this system to help me determine how much latency the kernel is adding to my packet transmit path.</p>
<h1 id="conclusion"><a name="conclusion" class="anchor-navigation-ex-anchor" href="#conclusion"><i class="fa fa-link" aria-hidden="true"></i></a>5. Conclusion</h1>
<p>The Linux networking stack is complicated.</p>
<p>As we saw above, even something as simple as the <code>NET_RX</code> can&#x2019;t be guaranteed to work as we expect it to. Even though <code>RX</code> is in the name, transmit completions are still processed in this softIRQ.</p>
<p>This highlights what I believe to be the core of the issue: optimizing and monitoring the network stack is impossible unless you carefully read and understand how it works. You cannot monitor code you don&#x2019;t understand at a deep level.</p>
<h1 id="help-with-linux-networking-or-other-systems"><a name="help-with-linux-networking-or-other-systems" class="anchor-navigation-ex-anchor" href="#help-with-linux-networking-or-other-systems"><i class="fa fa-link" aria-hidden="true"></i></a>6. Help with Linux networking or other systems</h1>
<p>Need some extra help navigating the network stack? Have questions about anything in this post or related things not covered? Send us an <a href="mailto:support@packagecloud.io" target="_blank">email</a> and let us know how we can help.</p>
<h1 id="related-posts"><a name="related-posts" class="anchor-navigation-ex-anchor" href="#related-posts"><i class="fa fa-link" aria-hidden="true"></i></a>7. Related posts</h1>
<p>If you enjoyed this post, you may enjoy some of our other low-level technical posts:</p>
<ul>
<li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank">Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank">The Definitive Guide to Linux System Calls</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/" target="_blank">How does <code>strace</code> work?</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/" target="_blank">How does <code>ltrace</code> work?</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/03/21/apt-hash-sum-mismatch/" target="_blank">APT Hash sum mismatch</a></li>
<li><a href="https://blog.packagecloud.io/eng/2014/10/28/howto-gpg-sign-verify-deb-packages-apt-repositories/" target="_blank">HOWTO: GPG sign and verify deb packages and APT repositories</a></li>
<li><a href="https://blog.packagecloud.io/eng/2014/11/24/howto-gpg-sign-verify-rpm-packages-yum-repositories/" target="_blank">HOWTO: GPG sign and verify RPM packages and yum repositories</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="networking_优化linux网络栈_接收路径.html" class="navigation navigation-prev " aria-label="Previous page: 优化linux网络栈: 接收路径(网摘)">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="networking_Potential_Performance_Bottleneck_in_Linux_TCP.html" class="navigation navigation-next " aria-label="Next page: Potential Performance Bottleneck in Linux TCP(网摘)">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"优化linux网络栈: 发送路径(网摘)","level":"1.6.4","depth":2,"next":{"title":"Potential Performance Bottleneck in Linux TCP(网摘)","level":"1.6.5","depth":2,"path":"notes/networking_Potential_Performance_Bottleneck_in_Linux_TCP.md","ref":"notes/networking_Potential_Performance_Bottleneck_in_Linux_TCP.md","articles":[]},"previous":{"title":"优化linux网络栈: 接收路径(网摘)","level":"1.6.3","depth":2,"path":"notes/networking_优化linux网络栈_接收路径.md","ref":"notes/networking_优化linux网络栈_接收路径.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-livereload","-sharing","-lunr","-search","search-plus","-highlight","theme-comscore","prism","code","chapter-fold","github","splitter","wide-page","hide-navigation-buttons","anchor-navigation-ex","sequence@0.1.1","mermaid-gb3"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"chapter-fold":{},"prism":{"css":["prismjs/themes/prism.css"],"ignore":["mermaid","sequence"]},"sequence":{"theme":"simple"},"github":{"url":"https://github.com/Bai-Yingjie/Bai-Yingjie.github.io"},"splitter":{},"wide-page":{},"code":{"copyButtons":true},"fontsettings":{"theme":"white","family":"sans","size":2},"hide-navigation-buttons":{},"mermaid-gb3":{},"anchor-navigation-ex":{"mode":"float","pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"isRewritePageTitle":true,"showLevel":true,"tocLevel1Icon":"fa fa-hand-o-right","tocLevel2Icon":"fa fa-hand-o-right","tocLevel3Icon":"fa fa-hand-o-right","showGoTop":true,"isShowTocTitleIcon":true,"printLog":false,"multipleH1":true,"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false}},"theme-comscore":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"search-plus":{}},"theme":"default","author":"Bai Yingjie","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"My Notes","language":"zh-hans","gitbook":"*"},"file":{"path":"notes/networking_优化linux网络栈_发送路径.md","mtime":"2024-08-09T01:32:43.498Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2024-08-09T01:33:36.325Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    <script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>

    </body>
</html>

