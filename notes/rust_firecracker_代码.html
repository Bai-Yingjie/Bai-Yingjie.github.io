
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>firecracker代码 · My Notes</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Bai Yingjie">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-hide-navigation-buttons/index.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="rust_firecracker_使用.html" />
    
    
    <link rel="prev" href="rust_vmm_简介.html" />
    

    </head>
    <body>
        


<div class="book">
    <div class="book-summary">
        
            <div class="theme-code-header">
                <a href="" class="link">
                    <h1 class="title">My Notes</h1>
                </a>
            </div>
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    开源
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="my_opensource.html">
            
                <a href="my_opensource.html">
            
                    
                    我的开源项目
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="my_upstream.html">
            
                <a href="my_upstream.html">
            
                    
                    我的upstream commit
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    系统分析和性能
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="system_analysis_bcc和ebpf.html">
            
                <a href="system_analysis_bcc和ebpf.html">
            
                    
                    bcc和ebpf(starting)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="performance_ovs进程调查.html">
            
                <a href="performance_ovs进程调查.html">
            
                    
                    OVS进程调查
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="performance_ping流程和函数调用解析.html">
            
                <a href="performance_ping流程和函数调用解析.html">
            
                    
                    ping流程和函数调用解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="CentOS_系统性能优化配置.html">
            
                <a href="CentOS_系统性能优化配置.html">
            
                    
                    CentOS 性能优化系统配置
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    ARM server
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="arm_server_杂记.html">
            
                <a href="arm_server_杂记.html">
            
                    
                    Arm server 杂记
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    嵌入式系统开发调试
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="embedded_debugging.html">
            
                <a href="embedded_debugging.html">
            
                    
                    嵌入式调试杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="uboot_杂记.html">
            
                <a href="uboot_杂记.html">
            
                    
                    uboot杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="buildroot_杂记.html">
            
                <a href="buildroot_杂记.html">
            
                    
                    buildroot杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="toolchain_升级gcc问题解决.html">
            
                <a href="toolchain_升级gcc问题解决.html">
            
                    
                    升级GCC7.3问题解决
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Linux工程实践
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="linux_日常使用.html">
            
                <a href="linux_日常使用.html">
            
                    
                    日常linux使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="git_日常使用.html">
            
                <a href="git_日常使用.html">
            
                    
                    日常git使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="向kernel提交补丁.html">
            
                <a href="向kernel提交补丁.html">
            
                    
                    向kernel提交补丁
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="linux_ssh_relay.html">
            
                <a href="linux_ssh_relay.html">
            
                    
                    ssh relay
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="gitlab_ci.html">
            
                <a href="gitlab_ci.html">
            
                    
                    gitlab CI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="docker_操作记录.html">
            
                <a href="docker_操作记录.html">
            
                    
                    docker操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="centos_操作记录.html">
            
                <a href="centos_操作记录.html">
            
                    
                    centos操作记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Golang
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    入门
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1.1" data-path="golang_语法基础.html">
            
                <a href="golang_语法基础.html">
            
                    
                    Golang 语法基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.1.2" data-path="golang_json性能.html">
            
                <a href="golang_json性能.html">
            
                    
                    Golang json性能比较
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="golang_原理.html">
            
                <a href="golang_原理.html">
            
                    
                    Golang 原理相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.2.1" data-path="golang_interface原理.html">
            
                <a href="golang_interface原理.html">
            
                    
                    Golang interface原理(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2.2" data-path="golang_内存分配.html">
            
                <a href="golang_内存分配.html">
            
                    
                    Golang 内存分配(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="golang_标准库.html">
            
                <a href="golang_标准库.html">
            
                    
                    Golang 标准库
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="golang_我的反射代码.html">
            
                <a href="golang_我的反射代码.html">
            
                    
                    Golang 我的反射代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="golang_问答.html">
            
                <a href="golang_问答.html">
            
                    
                    Golang 问答
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="golang_高效go.html">
            
                <a href="golang_高效go.html">
            
                    
                    Golang 高效go
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="golang_进阶.html">
            
                <a href="golang_进阶.html">
            
                    
                    Golang 进阶
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Golang 杂记
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.8.1" data-path="golang_杂记1.html">
            
                <a href="golang_杂记1.html">
            
                    
                    Golang 杂记1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.2" data-path="golang_杂记2.html">
            
                <a href="golang_杂记2.html">
            
                    
                    Golang 杂记2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.3" data-path="golang_杂记3.html">
            
                <a href="golang_杂记3.html">
            
                    
                    Golang 杂记3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.4" data-path="golang_lib选型.html">
            
                <a href="golang_lib选型.html">
            
                    
                    Golang lib选型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.5" data-path="golang_mod_proxy.html">
            
                <a href="golang_mod_proxy.html">
            
                    
                    go mod和go proxy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.6" data-path="golang_汇编_arm64.html">
            
                <a href="golang_汇编_arm64.html">
            
                    
                    Golang 汇编语法和arm64小知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.7" data-path="golang_cgo_swig.html">
            
                <a href="golang_cgo_swig.html">
            
                    
                    go调用c可以用swig
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.9" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Golang 环境和工具链生成
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.9.1" data-path="golang_toolchain_ppc.html">
            
                <a href="golang_toolchain_ppc.html">
            
                    
                    go tools增加ppc32支持.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.2" data-path="golang_toolchain_compile_gccgo.html">
            
                <a href="golang_toolchain_compile_gccgo.html">
            
                    
                    编译gccgo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3" data-path="golang_go_on_mips.html">
            
                <a href="golang_go_on_mips.html">
            
                    
                    go on mips boards(not so updated)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.9.3.1" data-path="golang_go_on_mips_part1.html">
            
                <a href="golang_go_on_mips_part1.html">
            
                    
                    part 1: cross compile go
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.2" data-path="golang_go_on_mips_part2.html">
            
                <a href="golang_go_on_mips_part2.html">
            
                    
                    part 2: build native go compiler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.3" data-path="golang_go_on_mips_part3.html">
            
                <a href="golang_go_on_mips_part3.html">
            
                    
                    part 3: gccgo experiments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.4" data-path="golang_go_on_mips_part4.html">
            
                <a href="golang_go_on_mips_part4.html">
            
                    
                    part 4: Golang json performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.5" data-path="golang_gentoo_on_mips_board_and_build_go.html">
            
                <a href="golang_gentoo_on_mips_board_and_build_go.html">
            
                    
                    Gentoo on mips board and build go
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.10" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    微服务
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.10.1" data-path="golang_micro.html">
            
                <a href="golang_micro.html">
            
                    
                    go-micro和micro
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.10.2" data-path="golang_微服务概念.html">
            
                <a href="golang_微服务概念.html">
            
                    
                    微服务概念
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.11" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    解释器和编解码
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.11.1" data-path="golang_yeagi.html">
            
                <a href="golang_yeagi.html">
            
                    
                    解释器yeagi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.2" data-path="golang_tengo.html">
            
                <a href="golang_tengo.html">
            
                    
                    解释器tengo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.3" data-path="golang_govaluate.html">
            
                <a href="golang_govaluate.html">
            
                    
                    解释器govaluate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.4" data-path="golang_encoding_gotiny.html">
            
                <a href="golang_encoding_gotiny.html">
            
                    
                    gotiny编解码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.5" data-path="golang_abs.html">
            
                <a href="golang_abs.html">
            
                    
                    解释器abs
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.12" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    调试和性能
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.12.1" data-path="golang_调试记录.html">
            
                <a href="golang_调试记录.html">
            
                    
                    Golang 调试记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.12.2" data-path="golang_topid性能优化.html">
            
                <a href="golang_topid性能优化.html">
            
                    
                    Golang topid性能优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.12.3" data-path="golang_gshell性能调试.html">
            
                <a href="golang_gshell性能调试.html">
            
                    
                    Golang gshell性能调试
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.13" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    网络和消息中间件
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.13.1" data-path="golang_zmq.html">
            
                <a href="golang_zmq.html">
            
                    
                    消息中间件基本概念和zero mq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.13.2" data-path="golang_mango.html">
            
                <a href="golang_mango.html">
            
                    
                    消息中间件mango
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.13.3" data-path="golang_libp2p.html">
            
                <a href="golang_libp2p.html">
            
                    
                    Golang p2p网络
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Rust
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="rust_入门_brief.html">
            
                <a href="rust_入门_brief.html">
            
                    
                    Rust 入门系列
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1.1" data-path="rust_books.html">
            
                <a href="rust_books.html">
            
                    
                    Rust reference books
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.2" data-path="rust_入门1.html">
            
                <a href="rust_入门1.html">
            
                    
                    Rust 安装和基础语法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.3" data-path="rust_入门2.html">
            
                <a href="rust_入门2.html">
            
                    
                    Rust 泛型和内存所有权
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.4" data-path="rust_入门3.html">
            
                <a href="rust_入门3.html">
            
                    
                    Rust 闭包 容器 迭代器 生成器 线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.5" data-path="rust_工程构建.html">
            
                <a href="rust_工程构建.html">
            
                    
                    Rust 工程构建
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="rust_coding_brief.html">
            
                <a href="rust_coding_brief.html">
            
                    
                    Rust 代码积累
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.2.1" data-path="rust_序列化.html">
            
                <a href="rust_序列化.html">
            
                    
                    Rust 序列化原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.2" data-path="rust_知识点积累.html">
            
                <a href="rust_知识点积累.html">
            
                    
                    Rust 知识点更新
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.3" data-path="rust_adaptiveservice.html">
            
                <a href="rust_adaptiveservice.html">
            
                    
                    rust版本的adaptiveservice探索
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.4" data-path="rust_常用设施.html">
            
                <a href="rust_常用设施.html">
            
                    
                    Rust 常用设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.5" data-path="rust_代码小段.html">
            
                <a href="rust_代码小段.html">
            
                    
                    Rust 代码小段
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="others.html">
            
                <a href="others.html">
            
                    
                    其他
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.3.1" data-path="rust_mdbook_使用.html">
            
                <a href="rust_mdbook_使用.html">
            
                    
                    Rust 使用mdbook
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    C开发
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="c_automake_autoconf.html">
            
                <a href="c_automake_autoconf.html">
            
                    
                    automake autoconf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="makefile_原理和实践.html">
            
                <a href="makefile_原理和实践.html">
            
                    
                    makefile
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="c_编程杂记高级篇.html">
            
                <a href="c_编程杂记高级篇.html">
            
                    
                    C编程杂记高级篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="c_编程杂记基础篇.html">
            
                <a href="c_编程杂记基础篇.html">
            
                    
                    C编程杂记基础篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="c_networking_socket高阶用法.html">
            
                <a href="c_networking_socket高阶用法.html">
            
                    
                    网络编程: Advanced Socket Topics(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="c_protobuf介绍.html">
            
                <a href="c_protobuf介绍.html">
            
                    
                    序列化: protobuf介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="c_进程间通信_共享文件和共享内存.html">
            
                <a href="c_进程间通信_共享文件和共享内存.html">
            
                    
                    进程间通信: 共享文件和共享内存(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="c_pthread_condition和mutex.html">
            
                <a href="c_pthread_condition和mutex.html">
            
                    
                    并发 任务 事件 和锁.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="kernel_user_space_howto.html">
            
                <a href="kernel_user_space_howto.html">
            
                    
                    kernel space和user space交互(网摘, linux2.6)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    脚本
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="shell_变量.html">
            
                <a href="shell_变量.html">
            
                    
                    shell变量
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="shell_基础篇.html">
            
                <a href="shell_基础篇.html">
            
                    
                    shell命令和脚本记录-基础篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="shell_高级篇.html">
            
                <a href="shell_高级篇.html">
            
                    
                    shell命令和脚本记录-高级篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="shell_脚本片段.html">
            
                <a href="shell_脚本片段.html">
            
                    
                    shell脚本片段
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="python_记录.html">
            
                <a href="python_记录.html">
            
                    
                    python记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="lua_记录.html">
            
                <a href="lua_记录.html">
            
                    
                    lua记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="shell_rds脚本阅读.html">
            
                <a href="shell_rds脚本阅读.html">
            
                    
                    RDS脚本阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="Project_Euler.html">
            
                <a href="Project_Euler.html">
            
                    
                    Project Euler
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    cloud和容器相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="cloud_杂记.html">
            
                <a href="cloud_杂记.html">
            
                    
                    云杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="container_当代容器读书笔记.html">
            
                <a href="container_当代容器读书笔记.html">
            
                    
                    当代容器读书笔记
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Operating System
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="system_libc_part1.html">
            
                <a href="system_libc_part1.html">
            
                    
                    libc概览1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="system_libc_part2.html">
            
                <a href="system_libc_part2.html">
            
                    
                    libc概览2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="system_libc_part3.html">
            
                <a href="system_libc_part3.html">
            
                    
                    libc概览3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="system_原理杂记.html">
            
                <a href="system_原理杂记.html">
            
                    
                    系统原理杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="system_alpine.html">
            
                <a href="system_alpine.html">
            
                    
                    Alpine Linux
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="system_进程间通信.html">
            
                <a href="system_进程间通信.html">
            
                    
                    进程间通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="system_特殊功能fd.html">
            
                <a href="system_特殊功能fd.html">
            
                    
                    eventfd timerfd signalfd和fd共享
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    CPU和device虚拟化
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    gvisor
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1.1" data-path="golang_gvisor代码_KVM.html">
            
                <a href="golang_gvisor代码_KVM.html">
            
                    
                    gvisor KVM模式代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.1.2" data-path="golang_gvisor调试.html">
            
                <a href="golang_gvisor调试.html">
            
                    
                    gvisor调试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.1.3" data-path="golang_gvisor_ptrace.html">
            
                <a href="golang_gvisor_ptrace.html">
            
                    
                    gvisor ptrace模式介绍(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="rust_vmm_brief.html">
            
                <a href="rust_vmm_brief.html">
            
                    
                    rust VMM(virtual machine monitor)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.2.1" data-path="rust_vmm_简介.html">
            
                <a href="rust_vmm_简介.html">
            
                    
                    rust-vmm简介
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.13.2.2" data-path="rust_firecracker_代码.html">
            
                <a href="rust_firecracker_代码.html">
            
                    
                    firecracker代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.3" data-path="rust_firecracker_使用.html">
            
                <a href="rust_firecracker_使用.html">
            
                    
                    firecracker使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.4" data-path="rust_cloud-hypervisor_代码.html">
            
                <a href="rust_cloud-hypervisor_代码.html">
            
                    
                    cloud hypervisor代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.5" data-path="rust_cloud-hypervisor_使用.html">
            
                <a href="rust_cloud-hypervisor_使用.html">
            
                    
                    cloud hypervisor使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.6" data-path="rust_cloud-hypervisor_问题与解决.html">
            
                <a href="rust_cloud-hypervisor_问题与解决.html">
            
                    
                    cloud hypervisor问题与解决
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="virtualization_virtio规范阅读笔记.html">
            
                <a href="virtualization_virtio规范阅读笔记.html">
            
                    
                    virtio规范阅读笔记.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" data-path="qemu_ovs_虚拟化环境.html">
            
                <a href="qemu_ovs_虚拟化环境.html">
            
                    
                    qemu OVS 虚拟化环境准备
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" data-path="qemu使用.html">
            
                <a href="qemu使用.html">
            
                    
                    Qemu使用(old)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    计算机网络相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="networking_杂记1.html">
            
                <a href="networking_杂记1.html">
            
                    
                    networking杂记1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Qemu OVS和DPDK
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.2.1" data-path="OVS_DPDK_编译运行.html">
            
                <a href="OVS_DPDK_编译运行.html">
            
                    
                    OVS-DPDK编译运行
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.2" data-path="OVS_架构和代码.html">
            
                <a href="OVS_架构和代码.html">
            
                    
                    OVS架构和代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.3" data-path="OVS_DPDK_performance_HXT_ARM_server.html">
            
                <a href="OVS_DPDK_performance_HXT_ARM_server.html">
            
                    
                    OVS-DPDK for ARM server 性能测试环境
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.4" data-path="DPDK_Mellanox.html">
            
                <a href="DPDK_Mellanox.html">
            
                    
                    DPDK Mellanox
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.5" data-path="OVS_phy-vm-phy.html">
            
                <a href="OVS_phy-vm-phy.html">
            
                    
                    OVS PHY-VM-PHY
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.6" data-path="networking_网络虚拟化用例记录.html">
            
                <a href="networking_网络虚拟化用例记录.html">
            
                    
                    网络虚拟化用例记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.7" data-path="networking_网络虚拟化操作记录.html">
            
                <a href="networking_网络虚拟化操作记录.html">
            
                    
                    网络虚拟化操作记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    虚拟化网络
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.3.1" data-path="networking_tc_filter_连接veth和tap.html">
            
                <a href="networking_tc_filter_连接veth和tap.html">
            
                    
                    Connecting a veth device to tap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.2" data-path="networking_multicast_vxlan_flannel.html">
            
                <a href="networking_multicast_vxlan_flannel.html">
            
                    
                    multicast vxlan和flannel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.3" data-path="networking_virtio网络介绍.html">
            
                <a href="networking_virtio网络介绍.html">
            
                    
                    virtio网络介绍(网摘): vhost-net virtio-net vhost-user SRIOV
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.4" data-path="networking_virtualization_杂记.html">
            
                <a href="networking_virtualization_杂记.html">
            
                    
                    虚拟化网络杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.5" data-path="networking_linux虚拟网络接口.html">
            
                <a href="networking_linux虚拟网络接口.html">
            
                    
                    linux虚拟网络接口(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    内核 设备和驱动相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="driver_驱动中使用工作队列轮询.html">
            
                <a href="driver_驱动中使用工作队列轮询.html">
            
                    
                    驱动中使用工作队列轮询
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="device_driver_杂记.html">
            
                <a href="device_driver_杂记.html">
            
                    
                    驱动调试杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="device_driver_原理相关.html">
            
                <a href="device_driver_原理相关.html">
            
                    
                    kernel和驱动原理相关
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="device_localbus_16bit读写.html">
            
                <a href="device_localbus_16bit读写.html">
            
                    
                    CPLD做8bit到16bit转换
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    nand
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.5.1" data-path="device_driver_octeon_nand.html">
            
                <a href="device_driver_octeon_nand.html">
            
                    
                    octeon nand flash驱动
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5.2" data-path="device_driver_nand概率写失败问题分析.html">
            
                <a href="device_driver_nand概率写失败问题分析.html">
            
                    
                    Nand flash概率写失败问题分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15.6" data-path="octeon_remote_pci.html">
            
                <a href="octeon_remote_pci.html">
            
                    
                    octeon remote-pci.c阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.7" data-path="Device_VFIO_notes.html">
            
                <a href="Device_VFIO_notes.html">
            
                    
                    VFIO简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    智能网卡和DPDK
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.8.1" data-path="smartNIC_智能网卡对比.html">
            
                <a href="smartNIC_智能网卡对比.html">
            
                    
                    智能网卡对比
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.2" data-path="octeon_pci_NIC.html">
            
                <a href="octeon_pci_NIC.html">
            
                    
                    octeon PCI NIC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    octeon liquidIO
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.8.3.1" data-path="smartNIC_liquidIO_代码阅读app篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读app篇.html">
            
                    
                    PCI-NIC 代码阅读 --app篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.2" data-path="smartNIC_liquidIO_代码阅读api篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读api篇.html">
            
                    
                    PCI-NIC 代码阅读 --api篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.3" data-path="smartNIC_liquidIO_代码阅读driver篇之结构体.html">
            
                <a href="smartNIC_liquidIO_代码阅读driver篇之结构体.html">
            
                    
                    PCI-NIC 代码阅读 --driver篇之结构体
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.4" data-path="smartNIC_liquidIO_代码阅读driver篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读driver篇.html">
            
                    
                    PCI-NIC 代码阅读 --driver篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.5" data-path="smartNIC_liquidIO_代码阅读真NIC篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读真NIC篇.html">
            
                    
                    PCI-NIC 代码阅读 --真NIC篇
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15.8.4" data-path="networking_dpdk使用_2014.html">
            
                <a href="networking_dpdk使用_2014.html">
            
                    
                    DPDK使用(2014)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15.9" data-path="device_nvme要点介绍.html">
            
                <a href="device_nvme要点介绍.html">
            
                    
                    nvme要点介绍
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    CPU Arch相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    ARM64
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1.1" data-path="CPU_ARM64_thunder_overview.html">
            
                <a href="CPU_ARM64_thunder_overview.html">
            
                    
                    thunder 概览
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.2" data-path="CPU_ARM64_thunder_开发板操作记录.html">
            
                <a href="CPU_ARM64_thunder_开发板操作记录.html">
            
                    
                    thunder 开发板操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.3" data-path="CPU_ARM64_thunder_bdk.html">
            
                <a href="CPU_ARM64_thunder_bdk.html">
            
                    
                    thunder BDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.4" data-path="CPU_ARM64_thunder_efi_rtc.html">
            
                <a href="CPU_ARM64_thunder_efi_rtc.html">
            
                    
                    thunder RTC时间和efi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.5" data-path="CPU_ARM64_thunder_uefi_fdt.html">
            
                <a href="CPU_ARM64_thunder_uefi_fdt.html">
            
                    
                    thunder uefi和fdt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.6" data-path="CPU_ARM64_thunder_atf.html">
            
                <a href="CPU_ARM64_thunder_atf.html">
            
                    
                    thunder atf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.7" data-path="CPU_ARM64_thunder_kernel_boot.html">
            
                <a href="CPU_ARM64_thunder_kernel_boot.html">
            
                    
                    thunder kernel启动打印流程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    PPC
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.2.1" data-path="CPU_PPC启动多核Linux_流程和内存映射.html">
            
                <a href="CPU_PPC启动多核Linux_流程和内存映射.html">
            
                    
                    PPC启动多核linux: 流程和内存映射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2.2" data-path="CPU_PPC_kernel升级记录.html">
            
                <a href="CPU_PPC_kernel升级记录.html">
            
                    
                    PPC kernel升级记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    MIPS
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.3.1" data-path="CPU_MIPS_octeon地址空间和寄存器访问.html">
            
                <a href="CPU_MIPS_octeon地址空间和寄存器访问.html">
            
                    
                    octeon 地址空间和寄存器访问
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.2" data-path="CPU_MIPS_octeon操作记录.html">
            
                <a href="CPU_MIPS_octeon操作记录.html">
            
                    
                    octeon 操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.3" data-path="CPU_MIPS_octeon_包处理性能.html">
            
                <a href="CPU_MIPS_octeon_包处理性能.html">
            
                    
                    octeon 系列处理器包处理性能
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.4" data-path="CPU_MIPS_octeon_ddr调试记录.html">
            
                <a href="CPU_MIPS_octeon_ddr调试记录.html">
            
                    
                    octeon DDR调试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.5" data-path="CPU_MIPS_octeon_BDK.html">
            
                <a href="CPU_MIPS_octeon_BDK.html">
            
                    
                    octeon CN78xx BDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.6" data-path="kernel_增加ECC中断.html">
            
                <a href="kernel_增加ECC中断.html">
            
                    
                    octeon 增加ECC中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.7" data-path="CPU_MIPS_octeon_hw-ddr2代码走读.html">
            
                <a href="CPU_MIPS_octeon_hw-ddr2代码走读.html">
            
                    
                    octeon hw-ddr2代码走读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.8" data-path="CPU_MIPS_octeon_reboot调试和ddr中断.html">
            
                <a href="CPU_MIPS_octeon_reboot调试和ddr中断.html">
            
                    
                    octeon reboot调试和DDR中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.9" data-path="CPU_MIPS_octeon中断.html">
            
                <a href="CPU_MIPS_octeon中断.html">
            
                    
                    octeon 中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.10" data-path="CPU_MIPS_octeon原子操作.html">
            
                <a href="CPU_MIPS_octeon原子操作.html">
            
                    
                    octeon 原子操作
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.11" data-path="CPU_MIPS_octeon网口代码分析.html">
            
                <a href="CPU_MIPS_octeon网口代码分析.html">
            
                    
                    octeon 网口代码分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="" target="_blank" class="gitbook-link">
            Author: Bai Yingjie
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >firecracker代码</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#runwithoutapi&#x6D41;&#x7A0B;"><b>1. </b>run_without_api&#x6D41;&#x7A0B;</a></li><ul><li><span class="title-icon "></span><a href="#buildmicrovmfromjson"><b>1.1. </b>build_microvm_from_json</a></li></ul><li><span class="title-icon "></span><a href="#event-manager"><b>2. </b>event manager</a></li><li><span class="title-icon "></span><a href="#aarch64-&#x7269;&#x7406;&#x5185;&#x5B58;layout"><b>3. </b>aarch64 &#x7269;&#x7406;&#x5185;&#x5B58;layout</a></li><li><span class="title-icon "></span><a href="#devicesbus"><b>4. </b>devices::Bus</a></li><li><span class="title-icon "></span><a href="#&#x5E95;&#x5C42;serial"><b>5. </b>&#x5E95;&#x5C42;serial</a></li><ul><li><span class="title-icon "></span><a href="#&#x7528;&#x6CD5;"><b>5.1. </b>&#x7528;&#x6CD5;</a></li><li><span class="title-icon "></span><a href="#serial&#x7ED3;&#x6784;&#x4F53;"><b>5.2. </b>Serial&#x7ED3;&#x6784;&#x4F53;</a></li><li><span class="title-icon "></span><a href="#&#x4E09;&#x4E2A;trait"><b>5.3. </b>&#x4E09;&#x4E2A;Trait</a></li><li><span class="title-icon "></span><a href="#&#x81EA;&#x5B9A;&#x4E49;error"><b>5.4. </b>&#x81EA;&#x5B9A;&#x4E49;Error</a></li><li><span class="title-icon "></span><a href="#&#x7528;noevents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;serial"><b>5.5. </b>&#x7528;NoEvents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;Serial</a></li><li><span class="title-icon "></span><a href="#driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;"><b>5.6. </b>driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;?</a></li></ul><li><span class="title-icon "></span><a href="#serialwrapper"><b>6. </b>SerialWrapper</a></li><ul><li><span class="title-icon "></span><a href="#&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;"><b>6.1. </b>&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;</a></li><li><span class="title-icon "></span><a href="#&#x5B9E;&#x73B0;&#x4E86;busdevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait"><b>6.2. </b>&#x5B9E;&#x73B0;&#x4E86;BusDevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait</a></li></ul><li><span class="title-icon "></span><a href="#attachvirtiodevice"><b>7. </b>attach_virtio_device</a></li><ul><li><span class="title-icon "></span><a href="#vmregisterioeventqueueevt-ioaddr-i--as--u32"><b>7.1. </b>vm.register_ioevent(queue_evt, &amp;io_addr, i  as  u32)</a></li><li><span class="title-icon "></span><a href="#vmregisterirqfd"><b>7.2. </b>vm.register_irqfd</a></li><li><span class="title-icon "></span><a href="#kvm&#x7684;irq&#x76F8;&#x5173;api"><b>7.3. </b>kvm&#x7684;irq&#x76F8;&#x5173;API</a></li><ul><li><span class="title-icon "></span><a href="#kvmcreateirqchip"><b>7.3.1. </b>KVM_CREATE_IRQCHIP</a></li><li><span class="title-icon "></span><a href="#kvmsetgsirouting"><b>7.3.2. </b>KVM_SET_GSI_ROUTING</a></li><li><span class="title-icon "></span><a href="#kvmirqfd"><b>7.3.3. </b>KVM_IRQFD</a></li><li><span class="title-icon "></span><a href="#kvmcreatedevice"><b>7.3.4. </b>KVM_CREATE_DEVICE</a></li><li><span class="title-icon "></span><a href="#arm-gic-v3"><b>7.3.5. </b>ARM gic v3</a></li></ul><li><span class="title-icon "></span><a href="#mmiotransport"><b>7.4. </b>MmioTransport</a></li><ul><li><span class="title-icon "></span><a href="#impl-mmiotransport"><b>7.4.1. </b>impl MmioTransport</a></li><li><span class="title-icon "></span><a href="#&#x5B9E;&#x73B0;busdevice"><b>7.4.2. </b>&#x5B9E;&#x73B0;BusDevice</a></li></ul><li><span class="title-icon "></span><a href="#device"><b>7.5. </b>device</a></li><ul><li><span class="title-icon "></span><a href="#device&#x7684;&#x72B6;&#x6001;&#x6709;"><b>7.5.1. </b>device&#x7684;&#x72B6;&#x6001;&#x6709;</a></li><li><span class="title-icon "></span><a href="#irqtrigger"><b>7.5.2. </b>IrqTrigger</a></li><li><span class="title-icon "></span><a href="#virtiodevice-trait"><b>7.5.3. </b>VirtioDevice trait</a></li></ul><li><span class="title-icon "></span><a href="#virtio&#x8BBE;&#x5907;&#x6846;&#x56FE;"><b>7.6. </b>VirtIO&#x8BBE;&#x5907;&#x6846;&#x56FE;</a></li><li><span class="title-icon "></span><a href="#virtio-net"><b>7.7. </b>virtIO net</a></li><ul><li><span class="title-icon "></span><a href="#net&#x5B9E;&#x73B0;&#x4E86;virtiodevice"><b>7.7.1. </b>Net&#x5B9E;&#x73B0;&#x4E86;VirtioDevice</a></li><li><span class="title-icon "></span><a href="#net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;muteventsubscriber"><b>7.7.2. </b>Net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;MutEventSubscriber</a></li></ul></ul></ul></div><a href="#runwithoutapi&#x6D41;&#x7A0B;" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p>firecracker&#x662F;&#x6700;&#x7EC8;&#x7684;&#x53EF;&#x6267;&#x884C;&#x6587;&#x4EF6;:<br><img src="img/rust_firecracker_&#x4EE3;&#x7801;_20220825223907.png" alt="">  </p>
<ul>
<li><a href="#run_without_api&#x6D41;&#x7A0B;">run_without_api&#x6D41;&#x7A0B;</a><ul>
<li><a href="#build_microvm_from_json">build_microvm_from_json</a></li>
</ul>
</li>
<li><a href="#event-manager">event manager</a></li>
<li><a href="#aarch64-&#x7269;&#x7406;&#x5185;&#x5B58;layout">aarch64 &#x7269;&#x7406;&#x5185;&#x5B58;layout</a></li>
<li><a href="#devicesbus">devices::Bus</a></li>
<li><a href="#&#x5E95;&#x5C42;serial">&#x5E95;&#x5C42;serial</a><ul>
<li><a href="#&#x7528;&#x6CD5;">&#x7528;&#x6CD5;</a></li>
<li><a href="#serial&#x7ED3;&#x6784;&#x4F53;">Serial&#x7ED3;&#x6784;&#x4F53;</a></li>
<li><a href="#&#x4E09;&#x4E2A;trait">&#x4E09;&#x4E2A;Trait</a></li>
<li><a href="#&#x81EA;&#x5B9A;&#x4E49;error">&#x81EA;&#x5B9A;&#x4E49;Error</a></li>
<li><a href="#&#x7528;noevents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;serial">&#x7528;NoEvents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;Serial</a></li>
<li><a href="#driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;">driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;?</a></li>
</ul>
</li>
<li><a href="#serialwrapper">SerialWrapper</a><ul>
<li><a href="#&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;">&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;</a></li>
<li><a href="#&#x5B9E;&#x73B0;&#x4E86;busdevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait">&#x5B9E;&#x73B0;&#x4E86;BusDevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait</a></li>
</ul>
</li>
<li><a href="#attach_virtio_device">attach_virtio_device</a><ul>
<li><a href="#vmregister_ioeventqueue_evt-io_addr-i--as--u32">vm.register_ioevent(queue_evt, &amp;io_addr, i  as  u32)</a></li>
<li><a href="#vmregister_irqfd">vm.register_irqfd</a></li>
<li><a href="#kvm&#x7684;irq&#x76F8;&#x5173;api">kvm&#x7684;irq&#x76F8;&#x5173;API</a><ul>
<li><a href="#kvm_create_irqchip">KVM_CREATE_IRQCHIP</a></li>
<li><a href="#kvm_set_gsi_routing">KVM_SET_GSI_ROUTING</a></li>
<li><a href="#kvm_irqfd">KVM_IRQFD</a></li>
<li><a href="#kvm_create_device">KVM_CREATE_DEVICE</a><ul>
<li><a href="#&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x53EF;&#x4EE5;&#x88AB;create">&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x53EF;&#x4EE5;&#x88AB;create</a></li>
</ul>
</li>
<li><a href="#arm-gic-v3">ARM gic v3</a><ul>
<li><a href="#kvm_dev_arm_vgic_grp_addr">KVM_DEV_ARM_VGIC_GRP_ADDR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mmiotransport">MmioTransport</a><ul>
<li><a href="#impl-mmiotransport">impl MmioTransport</a></li>
<li><a href="#&#x5B9E;&#x73B0;busdevice">&#x5B9E;&#x73B0;BusDevice</a></li>
</ul>
</li>
<li><a href="#device">device</a><ul>
<li><a href="#device&#x7684;&#x72B6;&#x6001;&#x6709;">device&#x7684;&#x72B6;&#x6001;&#x6709;</a></li>
<li><a href="#irqtrigger">IrqTrigger</a></li>
<li><a href="#virtiodevice-trait">VirtioDevice trait</a></li>
</ul>
</li>
<li><a href="#virtio&#x8BBE;&#x5907;&#x6846;&#x56FE;">VirtIO&#x8BBE;&#x5907;&#x6846;&#x56FE;</a></li>
<li><a href="#virtio-net">virtIO net</a><ul>
<li><a href="#net&#x5B9E;&#x73B0;&#x4E86;virtiodevice">Net&#x5B9E;&#x73B0;&#x4E86;VirtioDevice</a></li>
<li><a href="#net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;muteventsubscriber">Net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;MutEventSubscriber</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="runwithoutapi&#x6D41;&#x7A0B;"><a name="runwithoutapi&#x6D41;&#x7A0B;" class="anchor-navigation-ex-anchor" href="#runwithoutapi&#x6D41;&#x7A0B;"><i class="fa fa-link" aria-hidden="true"></i></a>1. run_without_api&#x6D41;&#x7A0B;</h1>
<p>&#x8FD9;&#x91CC;&#x91CD;&#x70B9;&#x8003;&#x5BDF;<code>build/cargo_target/x86_64-unknown-linux-musl/release/firecracker --no-api --config-file myvmconfig.json</code>&#x65B9;&#x5F0F;&#x8FD0;&#x884C;&#x7684;firecracker<br>myvmconfig.json&#x5185;&#x5BB9;&#x5982;&#x4E0B;:</p>
<pre><code class="lang-json">{
  &quot;boot-source&quot;: {
    &quot;kernel_image_path&quot;: &quot;build/kernel/linux-5.10/vmlinux-5.10-x86_64.bin&quot;,
    &quot;boot_args&quot;: &quot;console=ttyS0 reboot=k panic=1 pci=off&quot;,
    &quot;initrd_path&quot;: null
  },
  &quot;drives&quot;: [
    {
      &quot;drive_id&quot;: &quot;rootfs&quot;,
      &quot;path_on_host&quot;: &quot;build/rootfs/bionic.rootfs.ext4&quot;,
      &quot;is_root_device&quot;: true,
      &quot;partuuid&quot;: null,
      &quot;is_read_only&quot;: false,
      &quot;cache_type&quot;: &quot;Unsafe&quot;,
      &quot;io_engine&quot;: &quot;Sync&quot;,
      &quot;rate_limiter&quot;: null
    }
  ],
  &quot;machine-config&quot;: {
    &quot;vcpu_count&quot;: 2,
    &quot;mem_size_mib&quot;: 1024,
    &quot;smt&quot;: false,
    &quot;track_dirty_pages&quot;: false
  },
  &quot;balloon&quot;: null,
  &quot;network-interfaces&quot;: [],
  &quot;vsock&quot;: null,
  &quot;logger&quot;: null,
  &quot;metrics&quot;: null,
  &quot;mmds-config&quot;: null
}
</code></pre>
<p>&#x7ECF;&#x8FC7;&#x524D;&#x9762;&#x7684;&#x547D;&#x4EE4;&#x884C;&#x53C2;&#x6570;&#x89E3;&#x6790;, &#x6700;&#x540E;&#x8C03;&#x7528;</p>
<pre><code class="lang-rust">run_without_api(
    &amp;seccomp_filters, //&#x8FD9;&#x4E2A;&#x662F;seccomp&#x7684;bpf&#x4EE3;&#x7801;
    vmm_config_json, //&#x8FD9;&#x4E2A;&#x662F;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7684;&#x5B57;&#x7B26;&#x4E32;
    instance_info,
    boot_timer_enabled,
    mmds_size_limit,
    metadata_json.as_deref(),
)
</code></pre>
<p>&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5148;&#x4ECE;json&#x6784;&#x5EFA;vmm, &#x7136;&#x540E;&#x5728;&#x5FAA;&#x73AF;&#x91CC;run:</p>
<pre><code class="lang-rust">fn run_without_api(
    seccomp_filters: &amp;BpfThreadMap,
    config_json: Option&lt;String&gt;,
    instance_info: InstanceInfo,
    bool_timer_enabled: bool,
    mmds_size_limit: usize,
    metadata_json: Option&lt;&amp;str&gt;,
) -&gt; FcExitCode {
    let mut event_manager = EventManager::new().expect(&quot;Unable to create EventManager&quot;);

    // Create the firecracker metrics object responsible for periodically printing metrics.
    let firecracker_metrics = Arc::new(Mutex::new(metrics::PeriodicMetrics::new()));
    event_manager.add_subscriber(firecracker_metrics.clone());

    // Build the microVm. We can ignore VmResources since it&apos;s not used without api.
    let (_, vmm) = match build_microvm_from_json(
        seccomp_filters,
        &amp;mut event_manager,
        // Safe to unwrap since &apos;--no-api&apos; requires this to be set.
        config_json.unwrap(),
        instance_info,
        bool_timer_enabled,
        mmds_size_limit,
        metadata_json,
    ) {
        Ok((res, vmm)) =&gt; (res, vmm),
        Err(exit_code) =&gt; return exit_code,
    };

    // Start the metrics.
    firecracker_metrics
        .lock()
        .expect(&quot;Poisoned lock&quot;)
        .start(metrics::WRITE_METRICS_PERIOD_MS);

    // Run the EventManager that drives everything in the microVM.
    loop {
        event_manager
            .run()
            .expect(&quot;Failed to start the event manager&quot;);

        if let Some(exit_code) = vmm.lock().unwrap().shutdown_exit_code() {
            return exit_code;
        }
    }
}
</code></pre>
<p>build_microvm_from_json&#x5C31;&#x7528;&#x5230;&#x4E86;&#x6838;&#x5FC3;&#x6A21;&#x5757;vmm <code>firecracker/src/vmm/src</code></p>
<h2 id="buildmicrovmfromjson"><a name="buildmicrovmfromjson" class="anchor-navigation-ex-anchor" href="#buildmicrovmfromjson"><i class="fa fa-link" aria-hidden="true"></i></a>1.1. build_microvm_from_json</h2>
<pre><code class="lang-rust">build_microvm_from_json
    //&#x6839;&#x636E;json&#x586B;&#x5145;VmResources&#x7ED3;&#x6784;&#x4F53;&#x5E76;&#x521D;&#x59CB;&#x5316;
    let mut vm_resources = VmResources::from_json()
    let vmm = vmm::builder::build_microvm_for_boot(&amp;vm_resources)
        //&#x5EFA;&#x7ACB;guest&#x5185;&#x5B58;, &#x601D;&#x8DEF;&#x662F;&#x5728;host&#x4E0A;mmap, &#x5E76;&#x8BB0;&#x5F55;&#x5185;&#x5B58;region&#x5230;&#x53D8;&#x91CF;
        let guest_memory = create_guest_memory()
            //&#x5728;x86&#x4E0A;, 0-768M&#x662F;&#x5185;&#x5B58;, 768M&#x5230;4G&#x662F;MMIO, 4G&#x4EE5;&#x4E0A;&#x8FD8;&#x662F;&#x5185;&#x5B58;
            let arch_mem_regions = arch::arch_memory_regions(mem_size)
            vm_memory::create_guest_memory(&amp;arch_mem_regions)
                &#x4E3A;&#x6BCF;&#x4E2A;region mmap&#x4E00;&#x4E2A;region
                    //&#x5148;mmap&#x4E00;&#x4E2A;&#x5927;&#x7684;size, size=&#x539F;size+2&#x4E2A;page, &#x5C5E;&#x6027;&#x662F;libc::PROT_NONE
                    // Map the guarded range to PROT_NONE
                    let guard_addr = unsafe {
                        libc::mmap(
                            std::ptr::null_mut(),
                            guarded_size,
                            libc::PROT_NONE,
                            libc::MAP_ANONYMOUS | libc::MAP_PRIVATE | libc::MAP_NORESERVE,
                            -1,
                            0,
                        )
                    };

                    //&#x518D;&#x5728;&#x521A;&#x521A;map&#x7684;region&#x91CC;&#x9762;, &#x7528;&#x539F;size map&#x4E00;&#x4E2A;&#x8BFB;&#x5199;region
                    // Inside the protected range, starting with guard_addr + PAGE_SIZE,
                    // map the requested range with received protection and flags
                    let region_addr = unsafe {
                        libc::mmap(
                            region_start_addr as *mut libc::c_void, //&#x524D;&#x9762;&#x8FD4;&#x56DE;&#x7684;addr&#x52A0;&#x4E2A;page
                            size,
                            prot,
                            flags | libc::MAP_FIXED,
                            fd,
                            offset as libc::off_t,
                        )
                    };

                //&#x6700;&#x540E;build MmapRegion&#x5E76;&#x8FD4;&#x56DE;, &#x7528;&#x7684;&#x662F;https://github.com/rust-vmm/vm-memory
                //&#x5230;&#x8FD9;&#x91CC;&#x597D;&#x50CF;&#x53EA;&#x662F;&#x751F;&#x6210;GuestMemoryMmap&#x6570;&#x636E;&#x7ED3;&#x679C;, &#x5E76;&#x6CA1;&#x6709;&#x5B9E;&#x9645;&#x64CD;&#x4F5C;&#x5565;
        //&#x52A0;&#x8F7D;linux &#x5185;&#x6838;, &#x4EE3;&#x7801;&#x5728;firecracker/src/vmm/src/builder.rs
        let entry_addr = load_kernel(boot_config, &amp;guest_memory)?;
            let kernel_file = &#x5148;open kernel&#x6587;&#x4EF6;
            //&#x4F7F;&#x7528;&#x4E86;https://github.com/rust-vmm/linux-loader
            //&#x4E0B;&#x9762;&#x7684;Loader&#x5728;x86&#x4E0A;&#x662F;ELF, &#x5728;ARM&#x4E0A;&#x662F;PE
            //&#x628A;kernel_file&#x52A0;&#x8F7D;&#x5230;guest_memory
            let entry_addr = Loader::load::&lt;std::fs::File, GuestMemoryMmap&gt;(
                            &amp;guest_memory, &amp;kernel_file, arch::get_kernel_start())
                            //&#x4E0A;&#x9762;&#x8FD9;&#x4E2A;get_kernel_start()&#x5728;x86&#x4E0A;&#x662F;1MB, aarch64&#x4E0A;&#x662F;2GB
                            //&#x5148;&#x8BFB;elf header, &#x89E3;&#x6790;&#x6240;&#x6709;program header&#x5230;
                            let mut phdrs: Vec&lt;elf::Elf64_Phdr&gt; = vec![];
                            for &#x6BCF;&#x4E2A;phdr
                                //&#x5199;&#x5165;guest&#x5185;&#x5B58;, &#x4F3C;&#x4E4E;&#x53EA;&#x662F;&#x5199;&#x5165;host&#x4E0A;mmap&#x7684;&#x5185;&#x5B58;. &#x53EF;&#x80FD;&#x540E;&#x9762;&#x4F1A;&#x7528;kvm&#x7684;api&#x628A;&#x8FD9;&#x4E9B;&#x5185;&#x5B58;&#x6620;&#x5C04;&#x6210;guest&#x5185;&#x5B58;
                                guest_mem.read_exact_from(mem_offset, kernel_image, phdr.p_filesz as usize)

        //&#x4ECE;guest_memory find &#x4E00;&#x4E2A;region, &#x5E76;&#x5199;&#x5165;initrd&#x7684;&#x5185;&#x5BB9;;
        //&#x5728;&#x6211;&#x4EEC;&#x7684;&#x914D;&#x7F6E;&#x91CC;, initrd&#x662F;null
        let initrd = load_initrd_from_config(boot_config, &amp;guest_memory)?;

        //&#x91CD;&#x5199;cmdline, &#x518D;&#x539F;&#x57FA;&#x7840;&#x4E0A;&#x589E;&#x52A0;virtio&#x7B49;&#x914D;&#x7F6E;

        //&#x521B;&#x5EFA;VM
        let (mut vmm, mut vcpus) = create_vmm_and_vcpus(
            instance_info,
            event_manager,
            guest_memory,
            None,
            track_dirty_pages,
            vcpu_config.vcpu_count,
        )?;
            // Set up Kvm Vm and register memory regions.
            //&#x8C03;&#x7528;kvm-ioctls
            let mut vm = setup_kvm_vm(&amp;guest_memory, track_dirty_pages)?;
                //open /dev/kvm, &#x7136;&#x540E;ioctl KVM_CREATE_VM
                let mut vm = Vm::new()
                vm.memory_init()
                    //&#x6BCF;&#x4E2A;region&#x8C03;&#x7528; ioctl KVM_SET_USER_MEMORY_REGION

            //MMIO_MEM_START&#x5728;x86&#x4E0A;&#x662F;(4G-768M), &#x5728;aarch64&#x4E0A;&#x662F;1G
            //IRQ_BASE&#x5230;IRQ_MAX&#x5728;x86&#x4E0A;&#x662F;5&#x5230;23, &#x5728;aarch64&#x4E0A;&#x662F;32&#x5230;128
            //&#x8FD9;&#x91CC;&#x8BF4;&#x7684;&#x662F;virtio&#x8BBE;&#x5907;&#x7528;&#x7684;irq&#x53F7;&#x8303;&#x56F4;
            //mmio_device_manager&#x5305;&#x62EC;mmio_base, irq, &#x548C;bus
            let mmio_device_manager = MMIODeviceManager::new(arch::MMIO_MEM_START, (arch::IRQ_BASE, arch::IRQ_MAX));
                //IrqManager&#x662F;&#x7BA1;&#x7406;(first..last)irq&#x8303;&#x56F4;&#x7684;&#x7B80;&#x5355;&#x7ED3;&#x6784;&#x4F53;
                IrqManager::new()
                //device&#x7684;bus&#x662F;&#x4E2A;BtreeMap&#x7EC4;&#x7EC7;&#x7684;&#x6309;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x5212;&#x5206;&#x7684;&#x8BBE;&#x5907;&#x7684;&#x96C6;&#x5408;
                devices::Bus::new()

            //&#x521B;&#x5EFA;&#x4E2D;&#x65AD;&#x63A7;&#x5236;&#x5668;
            setup_interrupt_controller(&amp;mut  vm)?;
                //x86&#x4E0A;&#x662F;ioctl KVM_CREATE_IRQCHIP
                //aarch64&#x4E0A;&#x662F;GICv2::create(vm, vcpu_count)
                vm.setup_irqchip()
            //&#x65B0;&#x5EFA;&#x4E2A;eventfd
            let vcpus_exit_evt = EventFd::new(libc::EFD_NONBLOCK)
            vcpus = create_vcpus(&amp;vm, vcpu_count, &amp;vcpus_exit_evt)
                //for&#x91CC;&#x521B;&#x5EFA;n&#x4E2A;vCPU, ioctl KVM_CREATE_VCPU
                let vcpu = Vcpu::new()
                vcpu.kvm_vcpu.init(vm.fd())
            set_stdout_nonblocking();
            // servial device&#x662F;pio&#x8BBE;&#x5907;, &#x5728;x86&#x4E0A;&#x6709;, aarch64&#x4E0A;&#x6CA1;&#x6709;
            let serial_device = setup_serial_device(event_manager, stdin, stdout)
                //&#x7531;Serial device&#x5199;1&#x4EA7;&#x751F;event
                let interrupt_evt = EventFdTrigger::new(EventFd::new(EFD_NONBLOCK))
                //&#x8868;&#x793A;in buffer ready
                let kick_stdin_read_evt = EventFdTrigger::new(EventFd::new(EFD_NONBLOCK))
                //SerialWrapper&#x662F;event&#x548C;Servial&#x7684;&#x6865;&#x6881;
                let serial = SerialWrapper {
                    serial: Serial::with_events(
                        interrupt_evt,
                        SerialEventsWrapper {
                            metrics: METRICS.uart.clone(),
                            buffer_ready_event_fd: Some(kick_stdin_read_evt),
                        },
                        out,
                    ),
                    input: Some(input),
                }
                //&#x52A0;&#x5165;event manager, &#x6700;&#x540E;&#x7684;event loop&#x91CC;&#x9762;&#x4F1A;&#x76D1;&#x542C;stdin&#x548C;kick_stdin_read_evt fd
                event_manager.add_subscriber(serial.clone());

            //&#x53EA;&#x6709;x86&#x6709;pio device, &#x628A;&#x4E0A;&#x9762;&#x7684;serial_device&#x52A0;&#x5165;&#x5230;pio_device_manager
            let pio_device_manager = create_pio_dev_manager_with_legacy_devices(&amp;vm, serial_device, reset_evt)

            let vmm = Vmm {
                events_observer: Some(Box::new(SerialStdin::get())),
                instance_info: instance_info.clone(),
                shutdown_exit_code: None,
                vm,
                guest_memory,
                uffd,
                vcpus_handles: Vec::new(),
                vcpus_exit_evt,
                mmio_device_manager,
                #[cfg(target_arch = &quot;x86_64&quot;)]
                pio_device_manager,
            };
            //&#x6700;&#x540E;&#x8FD4;&#x56DE;vmm, vcpus
            Ok((vmm, vcpus))

        //&#x8FD9;&#x4E2A;&#x662F;&#x7ED9;&#x6D4B;&#x8BD5;&#x7528;&#x7684;, kernel&#x542F;&#x52A8;&#x5B8C;&#x6210;&#x540E;, test&#x7248;&#x672C;&#x7684;init&#x4F1A;&#x76F4;&#x63A5;&#x5199;/dev/mem&#x67D0;&#x4E2A;&#x5730;&#x5740;&#x9B54;&#x672F;&#x5B57;(123)
        attach_boot_timer_device(&amp;mu vmm, request_ts)?;
            let boot_timer = devices::pseudo::BootTimer::new(request_ts);
            //&#x5728;mmio&#x91CC;&#x9762;&#x5206;&#x914D;&#x5730;&#x5740;&#x7A7A;&#x95F4;, &#x6240;&#x8C13;&#x7684;&#x6CE8;&#x518C;&#x5C31;&#x662F;&#x6309;&#x5730;&#x5740;&#x7A7A;&#x95F4;assign&#x8BBE;&#x5907;, &#x8BBE;&#x5907;&#x6709;&#x8BFB;&#x5199;&#x51FD;&#x6570;
            vmm.mmio_device_manager.register_mmio_boot_timer(boot_timer)
        //&#x76EE;&#x524D;balloon&#x8BBE;&#x5907;&#x6CA1;&#x4F7F;&#x80FD;
        attach_balloon_device(&amp;mut  vmm, &amp;mut  boot_cmdline, balloon, event_manager)?;
            attach_virtio_device(event_manager, vmm, id, balloon.clone(), cmdline)
                event_manager.add_subscriber(device.clone());
                let device = MmioTransport::new(vmm.guest_memory().clone(), device);
                //&#x5206;&#x914D;mmio&#x5730;&#x5740;&#x8303;&#x56F4;, &#x6CE8;&#x518C;&#x5230;mmio manager; &#x5E76;&#x4FEE;&#x6539;cmdline
                vmm.mmio_device_manager.register_mmio_virtio_for_boot(vmm.vm.fd(), id, device, cmdline)

        //&#x53EF;&#x80FD;&#x6709;&#x591A;&#x4E2A;virtio&#x5757;&#x8BBE;&#x5907;
        attach_block_devices(
            &amp;mut vmm,
            &amp;mut boot_cmdline,
            vm_resources.block.list.iter(),
            event_manager,
        )?;
            for &#x6BCF;&#x4E2A; block
                //&#x5982;&#x679C;&#x662F;root device, &#x5C31;&#x589E;&#x52A0;cmdline &quot;root=/dev/vda&quot;&#x6216;&quot;root=PARTUUID=partuuid&quot;
                //&#x89C1;&#x4E0B;&#x9762;&#x7684;&#x51FD;&#x6570;&#x5206;&#x6790;
                attach_virtio_device(event_manager, vmm, id, block.clone(), cmdline)?;

        //&#x53EF;&#x80FD;&#x6709;&#x591A;&#x4E2A;virtio net&#x8BBE;&#x5907;
        attach_net_devices(
            &amp;mut vmm,
            &amp;mut boot_cmdline,
            vm_resources.net_builder.iter(),
            event_manager,
        )?;

        //&#x5BF9;&#x5E94;virtio socket device
        //guest&#x53EF;&#x4EE5;&#x901A;&#x8FC7;AF_VSOCK&#x901A;&#x8FC7;vsock device&#x548C;host&#x7684;AF_UNIX socket&#x901A;&#x4FE1;
        attach_unixsock_vsock_device(&amp;mut vmm, &amp;mut boot_cmdline, unix_vsock, event_manager)?;
        configure_system_for_boot(
            &amp;vmm,
            vcpus.as_mut(),
            vcpu_config,
            entry_addr,
            &amp;initrd,
            boot_cmdline,
        )?;

        //&#x542F;&#x52A8;vcpu&#x5230;pause&#x72B6;&#x6001;
        // Move vcpus to their own threads and start their state machine in the &apos;Paused&apos; state.
        vmm.start_vcpus(
            vcpus,
            seccomp_filters
                .get(&quot;vcpu&quot;)
                .ok_or_else(|| MissingSeccompFilters(&quot;vcpu&quot;.to_string()))?
                .clone(),
        )
            //&#x7ED9;&#x6BCF;&#x4E2A;vcpu&#x8D77;&#x4E2A;thread
            thread::Builder::new().spawn(move || {
                //Runs the vCPU in KVM context in a loop. Handles KVM_EXITs then goes back in.
                //run&#x7684;&#x903B;&#x8F91;&#x662F;&#x6267;&#x884C;StateMachine&#x5FAA;&#x73AF;
                //state machine&#x4ECE;paused&#x5F00;&#x59CB;
                self.run(filter);
                    //&#x72B6;&#x6001;&#x673A;&#x5FAA;&#x73AF;
                    while let Some(state_fn) = state_machine.function {
                        // Run the current state handler, and get the next one.
                            state_machine = state_fn(machine);
                    }
            })

        //&#x4F7F;&#x80FD;seccomp
        seccompiler::apply_filter()

        // The vcpus start off in the `Paused` state, let them run.
        vmm.resume_vm().map_err(Internal)?;
            self.mmio_device_manager.kick_devices();
            //&#x5BF9;&#x6BCF;&#x4E2A;vCPU send event

        let vmm = Arc::new(Mutex::new(vmm));
        event_manager.add_subscriber(vmm.clone());
</code></pre>
<p>VmResources&#x5B9A;&#x4E49;&#x5982;&#x4E0B;:
&#x4E00;&#x4E2A;VMM&#x5C31;&#x7531;block vsock balloon net&#x7B49;builder&#x6784;&#x6210;</p>
<pre><code class="lang-rust">#[derive(Default)]
pub struct VmResources {
    /// The vCpu and memory configuration for this microVM.
    vm_config: VmConfig,
    /// The boot configuration for this microVM.
    boot_config: Option&lt;BootConfig&gt;,
    /// The block devices.
    pub block: BlockBuilder,
    /// The vsock device.
    pub vsock: VsockBuilder,
    /// The balloon device.
    pub balloon: BalloonBuilder,
    /// The network devices builder.
    pub net_builder: NetBuilder,
    /// The optional Mmds data store.
    // This is initialised on demand (if ever used), so that we don&apos;t allocate it unless it&apos;s
    // actually used.
    pub mmds: Option&lt;Arc&lt;Mutex&lt;Mmds&gt;&gt;&gt;,
    /// Data store limit for the mmds.
    pub mmds_size_limit: usize,
    /// Whether or not to load boot timer device.
    pub boot_timer: bool,
}
</code></pre>
<h1 id="event-manager"><a name="event-manager" class="anchor-navigation-ex-anchor" href="#event-manager"><i class="fa fa-link" aria-hidden="true"></i></a>2. event manager</h1>
<p><code>https://github.com/rust-vmm/event-manager</code>
&#x4F7F;&#x7528;&#x4E86;epoll&#x673A;&#x5236;&#x7684;&#x4E8B;&#x4EF6;&#x9A71;&#x52A8;&#x5E93;<br><img src="img/rust_firecracker_&#x4EE3;&#x7801;_20220825225125.png" alt="">  </p>
<p>&#x57FA;&#x672C;&#x4E0A;&#x662F;&#x4E2A;epoll&#x7684;event loop, event subscriber&#x6CE8;&#x518C;&#x7684;&#x65F6;&#x5019;&#x6389;&#x54DF;init, &#x5728;loop&#x91CC;&#x6709;&#x5BF9;&#x5E94;&#x7684;event&#x5C31;&#x8C03;&#x7528;process.</p>
<h1 id="aarch64-&#x7269;&#x7406;&#x5185;&#x5B58;layout"><a name="aarch64-&#x7269;&#x7406;&#x5185;&#x5B58;layout" class="anchor-navigation-ex-anchor" href="#aarch64-&#x7269;&#x7406;&#x5185;&#x5B58;layout"><i class="fa fa-link" aria-hidden="true"></i></a>3. aarch64 &#x7269;&#x7406;&#x5185;&#x5B58;layout</h1>
<pre><code class="lang-rust">//      ==== Address map in use in ARM development systems today ====
//
//              - 32-bit -              - 36-bit -          - 40-bit -
//1024GB    +                   +                      +-------------------+     &lt;- 40-bit
//          |                                           | DRAM              |
//          ~                   ~                       ~                   ~
//          |                                           |                   |
//          |                                           |                   |
//          |                                           |                   |
//          |                                           |                   |
//544GB     +                   +                       +-------------------+
//          |                                           | Hole or DRAM      |
//          |                                           |                   |
//512GB     +                   +                       +-------------------+
//          |                                           |       Mapped      |
//          |                                           |       I/O         |
//          ~                   ~                       ~                   ~
//          |                                           |                   |
//256GB     +                   +                       +-------------------+
//          |                                           |       Reserved    |
//          ~                   ~                       ~                   ~
//          |                                           |                   |
//64GB      +                   +-----------------------+-------------------+   &lt;- 36-bit
//          |                   |                   DRAM                    |
//          ~                   ~                   ~                       ~
//          |                   |                                           |
//          |                   |                                           |
//34GB      +                   +-----------------------+-------------------+
//          |                   |                  Hole or DRAM             |
//32GB      +                   +-----------------------+-------------------+
//          |                   |                   Mapped I/O              |
//          ~                   ~                       ~                   ~
//          |                   |                                           |
//16GB      +                   +-----------------------+-------------------+
//          |                   |                   Reserved                |
//          ~                   ~                       ~                   ~
//4GB       +-------------------+-----------------------+-------------------+   &lt;- 32-bit
//          |           2GB of DRAM                                         |
//          |                                                               |
//2GB       +-------------------+-----------------------+-------------------+
//          |                           Mapped I/O                          |
//1GB       +-------------------+-----------------------+-------------------+
//          |                          ROM &amp; RAM &amp; I/O                      |
//0GB       +-------------------+-----------------------+-------------------+   0
//              - 32-bit -              - 36-bit -              - 40-bit -
//
// Taken from (http://infocenter.arm.com/help/topic/com.arm.doc.den0001c/DEN0001C_principles_of_arm_memory_maps.pdf).

/// Start of RAM on 64 bit ARM.
pub const DRAM_MEM_START: u64 = 0x8000_0000; // 2 GB.
/// The maximum RAM size.
pub const DRAM_MEM_MAX_SIZE: u64 = 0x00FF_8000_0000; // 1024 - 2 = 1022G.

/// Kernel command line maximum size.
/// As per `arch/arm64/include/uapi/asm/setup.h`.
pub const CMDLINE_MAX_SIZE: usize = 2048;

/// Maximum size of the device tree blob as specified in https://www.kernel.org/doc/Documentation/arm64/booting.txt.
pub const FDT_MAX_SIZE: usize = 0x20_0000;

// As per virt/kvm/arm/vgic/vgic-kvm-device.c we need
// the number of interrupts our GIC will support to be:
// * bigger than 32
// * less than 1023 and
// * a multiple of 32.
/// The highest usable SPI on aarch64.
pub const IRQ_MAX: u32 = 128;

/// First usable interrupt on aarch64.
pub const IRQ_BASE: u32 = 32;

/// Below this address will reside the GIC, above this address will reside the MMIO devices.
pub const MAPPED_IO_START: u64 = 1 &lt;&lt; 30; // 1 GB
</code></pre>
<h1 id="devicesbus"><a name="devicesbus" class="anchor-navigation-ex-anchor" href="#devicesbus"><i class="fa fa-link" aria-hidden="true"></i></a>4. devices::Bus</h1>
<p>&#x4E00;&#x4E2A;device&#x90FD;&#x5BF9;&#x5E94;&#x4E00;&#x6BB5;&#x5730;&#x5740;&#x7A7A;&#x95F4;, &#x4E00;&#x4E2A;bus&#x5305;&#x62EC;&#x591A;&#x4E2A;device, &#x6309;BtreeMap&#x7EC4;&#x7EC7;, key&#x662F;device&#x7684;&#x5730;&#x5740;&#x8303;&#x56F4;, value&#x662F;BusDevice</p>
<pre><code class="lang-rust">/// A device container for routing reads and writes over some address space.
///
/// This doesn&apos;t have any restrictions on what kind of device or address space this applies to. The
/// only restriction is that no two devices can overlap in this address space.
#[derive(Clone, Default)]
pub struct Bus {
    //bus&#x4E0B;&#x9762;&#x662F;BtreeMap&#x7BA1;&#x7406;&#x7684;device
    devices: BTreeMap&lt;BusRange, Arc&lt;Mutex&lt;dyn BusDevice&gt;&gt;&gt;,
}
</code></pre>
<p>Bus&#x6709;get_device, insert, read, write&#x65B9;&#x6CD5;.
read&#x548C;write&#x7684;&#x57FA;&#x672C;&#x903B;&#x8F91;&#x662F;&#x901A;&#x8FC7;&#x5730;&#x5740;&#x6765;&#x5224;&#x65AD;&#x662F;&#x54EA;&#x4E2A;device, &#x7136;&#x540E;lock&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;, &#x7136;&#x540E;read/write
&#x6BD4;&#x5982;:</p>
<pre><code class="lang-rust">    /// Reads data from the device that owns the range containing `addr` and puts it into `data`.
    ///
    /// Returns true on success, otherwise `data` is untouched.
    pub fn read(&amp;self, addr: u64, data: &amp;mut [u8]) -&gt; bool {
        //self.get_device(addr)&#x8FD4;&#x56DE;(offset,dev), offset&#x5C31;&#x662F;&quot;&#x8BBE;&#x5907;&#x5185;&quot;&#x504F;&#x79FB;&#x5730;&#x5740;
        if let Some((offset, dev)) = self.get_device(addr) {
            // OK to unwrap as lock() failing is a serious error condition and should panic.
            dev.lock()
                .expect(&quot;Failed to acquire device lock&quot;)
                .read(offset, data);
            true
        } else {
            false
        }
    }
</code></pre>
<h1 id="&#x5E95;&#x5C42;serial"><a name="&#x5E95;&#x5C42;serial" class="anchor-navigation-ex-anchor" href="#&#x5E95;&#x5C42;serial"><i class="fa fa-link" aria-hidden="true"></i></a>5. &#x5E95;&#x5C42;serial</h1>
<p><code>vm-superio-0.5.0/src/serial.rs</code>
serial&#x662F;&#x4E2A;&#x6CDB;&#x578B;&#x7684;&#x7ED3;&#x6784;&#x4F53;:</p>
<blockquote>
<p>The serial console emulation is done by emulating a serial COM port.
Each serial COM port (COM1-4) has an associated Port I/O address base and 12 registers mapped into 8 consecutive Port I/O locations (with the first one being the base). This structure emulates the registers that make sense for UART 16550 (and below) and helps in the interaction between the driver and device by using a <a href="https://docs.rs/vm_superio/0.5.0/vm_superio/trait.Trigger.html" target="_blank"><code>Trigger</code></a> object for notifications. It also writes the guest&apos;s output to an <code>out</code> Write object.</p>
</blockquote>
<p>serial&#x6A21;&#x62DF;&#x4E86;UART&#x7684;16550&#x7684;12&#x4E2A;&#x5BC4;&#x5B58;&#x5668;</p>
<h2 id="&#x7528;&#x6CD5;"><a name="&#x7528;&#x6CD5;" class="anchor-navigation-ex-anchor" href="#&#x7528;&#x6CD5;"><i class="fa fa-link" aria-hidden="true"></i></a>5.1. &#x7528;&#x6CD5;</h2>
<pre><code class="lang-rust">use std::io::{sink, Error, Result};
use std::ops::Deref;
use vm_superio::Trigger;
use vm_superio::Serial;
use vmm_sys_util::eventfd::EventFd;

struct EventFdTrigger(EventFd);
impl Trigger for EventFdTrigger {
    type E = Error;

    fn trigger(&amp;self) -&gt; Result&lt;()&gt; {
        self.write(1)
    }
}
impl Deref for EventFdTrigger {
    type Target = EventFd;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
impl EventFdTrigger {
    pub fn new(flag: i32) -&gt; Self {
        EventFdTrigger(EventFd::new(flag).unwrap())
    }
    pub fn try_clone(&amp;self) -&gt; Self {
        EventFdTrigger((**self).try_clone().unwrap())
    }
}

let intr_evt = EventFdTrigger::new(libc::EFD_NONBLOCK);
let mut serial = Serial::new(intr_evt.try_clone(), Vec::new());
// std::io::Sink can be used if user is not interested in guest&apos;s output.
let serial_with_sink = Serial::new(intr_evt, sink());

// Write 0x01 to THR register.
serial.write(0, 0x01).unwrap();
// Read from RBR register.
let value = serial.read(0);

// Send more bytes to the guest in one shot.
let input = &amp;[b&apos;a&apos;, b&apos;b&apos;, b&apos;c&apos;];
// Before enqueuing bytes we first check if there is enough free space
// in the FIFO.
if serial.fifo_capacity() &gt;= input.len() {
    serial.enqueue_raw_bytes(input).unwrap();
}
</code></pre>
<h2 id="serial&#x7ED3;&#x6784;&#x4F53;"><a name="serial&#x7ED3;&#x6784;&#x4F53;" class="anchor-navigation-ex-anchor" href="#serial&#x7ED3;&#x6784;&#x4F53;"><i class="fa fa-link" aria-hidden="true"></i></a>5.2. Serial&#x7ED3;&#x6784;&#x4F53;</h2>
<p>&#x8FD9;&#x662F;&#x4E2A;&#x6CDB;&#x578B;, &#x9700;&#x8981;&#x7528;&#x4E09;&#x4E2A;trait: Trigger, SerialEvents, Write&#x6765;&#x5B9E;&#x4F8B;&#x5316;.</p>
<pre><code class="lang-rust">pub struct Serial&lt;T: Trigger, EV: SerialEvents, W: Write&gt; {
    // Some UART registers.
    baud_divisor_low: u8,
    baud_divisor_high: u8,
    interrupt_enable: u8,
    interrupt_identification: u8,
    line_control: u8,
    line_status: u8,
    modem_control: u8,
    modem_status: u8,
    scratch: u8,
    // This is the buffer that is used for achieving the Receiver register
    // functionality in FIFO mode. Reading from RBR will return the oldest
    // unread byte from the RX FIFO.
    in_buffer: VecDeque&lt;u8&gt;,

    // Used for notifying the driver about some in/out events.
    interrupt_evt: T,
    events: EV,
    out: W,
}
</code></pre>
<h2 id="&#x4E09;&#x4E2A;trait"><a name="&#x4E09;&#x4E2A;trait" class="anchor-navigation-ex-anchor" href="#&#x4E09;&#x4E2A;trait"><i class="fa fa-link" aria-hidden="true"></i></a>5.3. &#x4E09;&#x4E2A;Trait</h2>
<pre><code class="lang-rust">pub trait SerialEvents {
    /// The driver reads data from the input buffer.
    fn buffer_read(&amp;self);
    /// The driver successfully wrote one byte to serial output.
    fn out_byte(&amp;self);
    /// An error occurred while writing a byte to serial output resulting in a lost byte.
    fn tx_lost_byte(&amp;self);
    /// This event can be used by the consumer to re-enable events coming from
    /// the serial input.
    fn in_buffer_empty(&amp;self);
}

//&#x4E00;&#x822C;&#x90FD;&#x662F;EventFD, &#x7528;&#x4E8E;trigger&#x901A;&#x77E5;guest driver?
pub trait Trigger {
    /// Underlying type for the potential error conditions returned by `Self::trigger`.
    type E;

    /// Trigger an event.
    fn trigger(&amp;self) -&gt; Result&lt;(), Self::E&gt;;
}

//Write&#x5C31;&#x662F;io&#x54EA;&#x4E2A;Write
</code></pre>
<h2 id="&#x81EA;&#x5B9A;&#x4E49;error"><a name="&#x81EA;&#x5B9A;&#x4E49;error" class="anchor-navigation-ex-anchor" href="#&#x81EA;&#x5B9A;&#x4E49;error"><i class="fa fa-link" aria-hidden="true"></i></a>5.4. &#x81EA;&#x5B9A;&#x4E49;Error</h2>
<pre><code class="lang-rust">/// Errors encountered while handling serial console operations.
#[derive(Debug)]
pub enum Error&lt;E&gt; {
    /// Failed to trigger interrupt.
    Trigger(E),
    /// Couldn&apos;t write/flush to the given destination.
    IOError(io::Error),
    /// No space left in FIFO.
    FullFifo,
}
</code></pre>
<h2 id="&#x7528;noevents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;serial"><a name="&#x7528;noevents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;serial" class="anchor-navigation-ex-anchor" href="#&#x7528;noevents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;serial"><i class="fa fa-link" aria-hidden="true"></i></a>5.5. &#x7528;NoEvents&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x7684;Serial</h2>
<p>NoEvents&#x7ED3;&#x6784;&#x4F53;&#x5C31;&#x662F;&#x5B9E;&#x73B0;&#x4E86;&#x4E00;&#x4E2A;&#x5565;&#x4E5F;&#x4E0D;&#x5E72;&#x7684;SerialEvents</p>
<pre><code class="lang-rust">pub struct NoEvents;

impl SerialEvents for NoEvents {
    fn buffer_read(&amp;self) {}
    fn out_byte(&amp;self) {}
    fn tx_lost_byte(&amp;self) {}
    fn in_buffer_empty(&amp;self) {}
}
</code></pre>
<p>&#x4E00;&#x4E2A;&#x66F4;&#x5177;&#x4F53;&#x7684;&#x5B9E;&#x4F8B;&#x5316;:</p>
<pre><code class="lang-rust">impl&lt;T: Trigger, W: Write&gt; Serial&lt;T, NoEvents, W&gt; {
    /// Creates a new `Serial` instance which writes the guest&apos;s output to
    /// `out` and uses `trigger` object to notify the driver about new
    /// events.
    ///
    /// # Arguments
    /// * `trigger` - The Trigger object that will be used to notify the driver
    ///               about events.
    /// * `out` - An object for writing guest&apos;s output to. In case the output
    ///           is not of interest,
    ///           [std::io::Sink](https://doc.rust-lang.org/std/io/struct.Sink.html)
    ///           can be used here.
    ///
    /// # Example
    ///
    /// You can see an example of how to use this function in the
    /// [`Example` section from `Serial`](struct.Serial.html#example).
    pub fn new(trigger: T, out: W) -&gt; Serial&lt;T, NoEvents, W&gt; {
        Self::with_events(trigger, NoEvents, out)
    }
}
</code></pre>
<p>&#x540C;&#x6837;&#x7684;<code>Serial&lt;T: Trigger, EV: SerialEvents, W: Write&gt;</code>&#x662F;&#x8303;&#x56F4;&#x66F4;&#x5927;&#x7684;&#x6CDB;&#x578B;:</p>
<pre><code class="lang-rust">impl&lt;T: Trigger, EV: SerialEvents, W: Write&gt; Serial&lt;T, EV, W&gt; {
    /// Creates a new `Serial` instance which writes the guest&apos;s output to
    /// `out`, uses `trigger` object to notify the driver about new
    /// events, and invokes the `serial_evts` implementation of `SerialEvents`
    /// during operation.
    ///
    /// # Arguments
    /// * `trigger` - The `Trigger` object that will be used to notify the driver
    ///               about events.
    /// * `serial_evts` - The `SerialEvents` implementation used to track the occurrence
    ///                   of significant events in the serial operation logic.
    /// * `out` - An object for writing guest&apos;s output to. In case the output
    ///           is not of interest,
    ///           [std::io::Sink](https://doc.rust-lang.org/std/io/struct.Sink.html)
    ///           can be used here.
    pub fn with_events(trigger: T, serial_evts: EV, out: W) -&gt; Self {
        //&#x7528;&#x4E86;&#x5F88;&#x591A;const&#x5B9A;&#x4E49;&#x4E2A;u8&#x7684;&#x5E38;&#x91CF;, &#x6BD4;&#x5982;DEFAULT_BAUD_DIVISOR_LOW&#x662F;0x0C
        Serial {
            baud_divisor_low: DEFAULT_BAUD_DIVISOR_LOW,
            baud_divisor_high: DEFAULT_BAUD_DIVISOR_HIGH,
            interrupt_enable: DEFAULT_INTERRUPT_ENABLE,
            interrupt_identification: DEFAULT_INTERRUPT_IDENTIFICATION,
            line_control: DEFAULT_LINE_CONTROL,
            line_status: DEFAULT_LINE_STATUS,
            modem_control: DEFAULT_MODEM_CONTROL,
            modem_status: DEFAULT_MODEM_STATUS,
            scratch: DEFAULT_SCRATCH,
            in_buffer: VecDeque::new(),
            interrupt_evt: trigger,
            events: serial_evts,
            out,
        }
    }

    /// Provides a reference to the interrupt event object.
    pub fn interrupt_evt(&amp;self) -&gt; &amp;T {
        &amp;self.interrupt_evt
    }

    /// Provides a reference to the serial events object.
    pub fn events(&amp;self) -&gt; &amp;EV {
        &amp;self.events
    }

    //&#x5177;&#x4F53;&#x64CD;&#x4F5C;, &#x79C1;&#x6709;&#x65B9;&#x6CD5;, &#x57FA;&#x672C;&#x4E0A;&#x662F;&#x5BF9;&#x7ED3;&#x6784;&#x4F53;&#x7684;&#x5404;field&#x8FDB;&#x884C;&#x64CD;&#x4F5C;
    fn is_dlab_set(&amp;self) -&gt; bool {
        (self.line_control &amp; LCR_DLAB_BIT) != 0
    }

    //&#x8FD8;&#x6709;&#x5F88;&#x591A;, &#x7701;&#x7565;

    //&#x8BFB;&#x5199;&#x51FD;&#x6570;, &#x8C01;&#x6765;&#x8BFB;&#x5199;? driver

    //write&#x4E0D;&#x662F;io Write&#x7684;&#x683C;&#x5F0F;, offset&#x662F;&#x9884;&#x5B9A;&#x4E49;&#x7684;&#x5E38;&#x91CF;&#x8868;&#x4E2D;&#x7684;&#x5E38;&#x91CF;

    /// Handles a write request from the driver at `offset` offset from the
    /// base Port I/O address.
    ///
    /// # Arguments
    /// * `offset` - The offset that will be added to the base PIO address
    ///              for writing to a specific register.
    /// * `value` - The byte that should be written.
    ///
    /// # Example
    ///
    /// You can see an example of how to use this function in the
    /// [`Example` section from `Serial`](struct.Serial.html#example).
    pub fn write(&amp;mut self, offset: u8, value: u8) -&gt; Result&lt;(), Error&lt;T::E&gt;&gt; {
        match offset {
            DLAB_LOW_OFFSET if self.is_dlab_set() =&gt; self.baud_divisor_low = value,
            DLAB_HIGH_OFFSET if self.is_dlab_set() =&gt; self.baud_divisor_high = value,
            //&#x5173;&#x952E;&#x8DEF;&#x5F84;, &#x6BCF;&#x6B21;&#x5199;&#x5165;&#x4E00;&#x4E2A;&#x5B57;&#x8282;; &#x5199;&#x5230;stdout
            DATA_OFFSET =&gt; {
                let res = self
                        .out //&#x91CD;&#x70B9;&#x662F;&#x8FD9;&#x91CC;, &#x8FD9;&#x4E2A;out&#x4E00;&#x822C;&#x662F;stdout, guest driver&#x7684;write, &#x901A;&#x8FC7;&#x8FD9;&#x91CC;&#x7684;Serial Device(Self), &#x5199;&#x5230;stdout
                        .write_all(&amp;[value])
                        .map_err(Error::IOError)
                        .and_then(|_| self.out.flush().map_err(Error::IOError))
                        .map(|_| self.events.out_byte())
                        .map_err(|err| {
                            self.events.tx_lost_byte();
                            err
                        });
                    // Because we cannot block the driver, the THRE interrupt is sent
                    // irrespective of whether we are able to write the byte or not
                    self.thr_empty_interrupt().map_err(Error::Trigger)?;
                    return res;
            }
            _ =&gt; {}
        }
        Ok(())
    }

    //&#x8BFB;&#x7684;&#x903B;&#x8F91;&#x662F;&#x4ECE;self.in_buffer pop&#x51FA;&#x4E00;&#x4E2A;&#x5B57;&#x8282;, &#x8FD4;&#x56DE;&#x7ED9;&#x8C03;&#x7528;&#x8005;.

    /// Handles a read request from the driver at `offset` offset from the
    /// base Port I/O address.
    ///
    /// Returns the read value.
    ///
    /// # Arguments
    /// * `offset` - The offset that will be added to the base PIO address
    ///              for reading from a specific register.
    ///
    /// # Example
    ///
    /// You can see an example of how to use this function in the
    /// [`Example` section from `Serial`](struct.Serial.html#example).
    pub fn read(&amp;mut self, offset: u8) -&gt; u8 {
        match offset {
            DLAB_LOW_OFFSET if self.is_dlab_set() =&gt; self.baud_divisor_low,
            DLAB_HIGH_OFFSET if self.is_dlab_set() =&gt; self.baud_divisor_high,
            DATA_OFFSET =&gt; {
                // Here we emulate the reset method for when RDA interrupt
                // was raised (i.e. read the receive buffer and clear the
                // interrupt identification register and RDA bit when no
                // more data is available).
                self.del_interrupt(IIR_RDA_BIT);
                let byte = self.in_buffer.pop_front().unwrap_or_default();
                if self.in_buffer.is_empty() {
                    self.clear_lsr_rda_bit();
                    self.events.in_buffer_empty();
                }
                self.events.buffer_read();
                byte
            }
            LCR_OFFSET =&gt; self.line_control,
            MCR_OFFSET =&gt; self.modem_control,
            LSR_OFFSET =&gt; self.line_status,
            _ =&gt; 0,
        }
    }

    /// Returns how much space is still available in the FIFO.
    ///
    /// # Example
    ///
    /// You can see an example of how to use this function in the
    /// [`Example` section from `Serial`](struct.Serial.html#example).
    #[inline]
    pub fn fifo_capacity(&amp;self) -&gt; usize {
        FIFO_SIZE - self.in_buffer.len()
    }

    /// Helps in sending more bytes to the guest in one shot, by storing
    /// `input` bytes in UART buffer and letting the driver know there is
    /// some pending data to be read by setting RDA bit and its corresponding
    /// interrupt when not already triggered.
    ///
    /// # Arguments
    /// * `input` - The data to be sent to the guest.
    ///
    /// # Returns
    ///
    /// The function returns the number of bytes it was able to write to the fifo,
    /// or `FullFifo` error when the fifo is full. Users can use
    /// [`fifo_capacity`](#method.fifo_capacity) before calling this function
    /// to check the available space.
    ///
    /// # Example
    ///
    /// You can see an example of how to use this function in the
    /// [`Example` section from `Serial`](struct.Serial.html#example).
    pub fn enqueue_raw_bytes(&amp;mut self, input: &amp;[u8]) -&gt; Result&lt;usize, Error&lt;T::E&gt;&gt; {
        let mut write_count = 0;
        if !self.is_in_loop_mode() {
            if self.fifo_capacity() == 0 {
                return Err(Error::FullFifo);
            }
            write_count = std::cmp::min(self.fifo_capacity(), input.len());
            if write_count &gt; 0 {
                self.in_buffer.extend(&amp;input[0..write_count]);
                self.set_lsr_rda_bit();
                //&#x5C31;&#x662F;&#x7ED9;Self.interrupt_evt&#x8FD9;&#x4E2A;eventfd&#x5199;1
                self.received_data_interrupt().map_err(Error::Trigger)?;
            }
        }
        Ok(write_count)
    }
}
</code></pre>
<h2 id="driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;"><a name="driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;" class="anchor-navigation-ex-anchor" href="#driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;"><i class="fa fa-link" aria-hidden="true"></i></a>5.6. driver&#x5728;&#x54EA;&#x91CC;&#x8BFB;&#x5199;?</h2>
<p>&#x5F85;&#x7EED;</p>
<h1 id="serialwrapper"><a name="serialwrapper" class="anchor-navigation-ex-anchor" href="#serialwrapper"><i class="fa fa-link" aria-hidden="true"></i></a>6. SerialWrapper</h1>
<p>SerialWrapper&#x5305;&#x62EC;&#x4E86;&#x5E95;&#x5C42;Serial&#x8BBE;&#x5907;&#x548C;input
SerialWrapper: <code>firecracker/src/devices/src/legacy/serial.rs</code>
&#x5E95;&#x5C42;Serial: <code>vm-superio-0.5.0/src/serial.rs</code></p>
<pre><code class="lang-rust">pub struct SerialWrapper&lt;T: Trigger, EV: SerialEvents, W: Write&gt; {
    pub serial: Serial&lt;T, EV, W&gt;,
    pub input: Option&lt;Box&lt;dyn ReadableFd + Send&gt;&gt;,
}
</code></pre>
<p>&#x8FD9;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x662F;Serial device&#x548C;event loop&#x4E4B;&#x95F4;&#x7684;&#x6865;&#x6881;.
&#x4E4B;&#x95F4;&#x7528;eventfd&#x6765;&#x901A;&#x77E5;</p>
<pre><code>Host                VMM                        Guest
stdin/stdout        Serial&#x8BBE;&#x5907; read/write      driver
</code></pre><p>&#x5177;&#x4F53;&#x6765;&#x8BB2;, guest driver&#x901A;&#x8FC7;BusDevice&#x5411;Serial&#x8BBE;&#x5907;&#x53D1;&#x51FA;&#x8BFB;&#x5199;&#x8BF7;&#x6C42;, VMM&#x8C03;&#x7528;Serial&#x8BBE;&#x5907;&#x7684;read/write&#x51FD;&#x6570;&#x6765;&#x5B8C;&#x6210;&#x54CD;&#x5E94;&#x5E76;&#x5728;&#x67D0;&#x4E9B;&#x60C5;&#x51B5;&#x4E0B;&#x89E6;&#x53D1;&#x4E2D;&#x65AD;&#x901A;&#x77E5;(&#x53EF;&#x80FD;&#x662F;&#x7ED9;PioManager), &#x6BD4;&#x5982;&#x5728;&#x7ED9;in_buffer&#x8BFB;&#x5230;data&#x540E;&#x4EA7;&#x751F;received_data_interrupt. Serial&#x7ED3;&#x6784;&#x4F53;&#x6765;&#x7EF4;&#x62A4;UART16550&#x7684;&#x786C;&#x4EF6;&#x7684;&#x5BC4;&#x5B58;&#x5668;level&#x7684;&#x884C;&#x4E3A;. </p>
<h2 id="&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;"><a name="&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;" class="anchor-navigation-ex-anchor" href="#&#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;"><i class="fa fa-link" aria-hidden="true"></i></a>6.1. &#x4ECE;stdin&#x8BFB;&#x8F93;&#x5165;&#x53D1;&#x7ED9;guest&#x6D41;&#x7A0B;</h2>
<p>SerialWrapper&#x7684;<code>&lt;EventFdTrigger, SerialEventsWrapper, W&gt;</code>&#x7684;&#x5B9E;&#x4F8B;&#x5B9E;&#x73B0;&#x4E86;recv_bytes</p>
<pre><code class="lang-rust">impl&lt;W: Write&gt; SerialWrapper&lt;EventFdTrigger, SerialEventsWrapper, W&gt; {
    fn recv_bytes(&amp;mut self) -&gt; io::Result&lt;usize&gt; {
        let avail_cap = self.serial.fifo_capacity();

        if let Some(input) = self.input.as_mut() {
            let mut out = vec![0u8; avail_cap]; //&#x6307;&#x5B9A;cap&#x7684;vec
            //&#x4ECE;stdin&#x8BFB;
            let count = input.read(&amp;mut out)?; //&#x770B;&#x6765;&amp;mut Vec&lt;u8&gt;&#x80FD;&#x5F53;&#x4F5C;&amp;mut [u8]
            if count &gt; 0 {
                self.serial
                    //&#x8FD9;&#x4E2A;&#x6709;&#x70B9;&#x8BB2;&#x7A76;&#x4E86;, raw_input&#x5E76;&#x4E0D;&#x662F;&#x5E95;&#x5C42;Serial&#x7684;&#x65B9;&#x6CD5;, &#x800C;&#x662F;&#x672C;&#x6587;&#x4EF6;&#x5B9A;&#x4E49;&#x7684;trait
                    //&#x5E95;&#x5C42;&#x8C03;&#x7528;&#x7684;&#x662F;Servial&#x8BBE;&#x5907;&#x7684;enqueue_raw_bytes&#x65B9;&#x6CD5;, &#x5F80;&#x5E95;&#x5C42;Servial&#x7684;in_buffer&#x586B;&#x6570;&#x636E;
                    .raw_input(&amp;out[..count])
                    .map_err(|_| io::Error::from_raw_os_error(libc::ENOBUFS))?;
            }

            return Ok(count);
        }

        Err(io::Error::from_raw_os_error(libc::ENOTTY))
    }
}
</code></pre>
<p>&#x8FD9;&#x4E2A;recv_bytes&#x88AB;MutEventSubscriber trait&#x8C03;&#x7528;, SerialWrapper&#x4E5F;&#x5B9E;&#x73B0;&#x4E86;MutEventSubscriber
&#x91CC;&#x9762;&#x7684;process&#x5C31;&#x8C03;&#x7528;&#x4E86;recv_bytes
&#x5177;&#x4F53;&#x6CA1;&#x600E;&#x4E48;&#x770B;&#x61C2;</p>
<pre><code class="lang-rust">impl&lt;W: std::io::Write&gt; MutEventSubscriber
    for SerialWrapper&lt;EventFdTrigger, SerialEventsWrapper, W&gt;
{
    //process&#x4F1A;&#x5728;&#x53D1;&#x751F;event&#x7684;&#x65F6;&#x5019;&#x88AB;&#x8C03;&#x7528;, &#x4F20;&#x5165;event&#x548C;ops&#x7528;&#x6765;&#x8868;&#x793A;event&#x7C7B;&#x578B;&#x548C;&#x7EF4;&#x62A4;event
    //&#x53EF;&#x80FD;&#x6709;&#x591A;&#x4E2A;fd&#x7684;&#x6E90;&#x5934;, &#x4F46;&#x90FD;&#x5171;&#x7528;&#x8FD9;&#x4E00;&#x4E2A;process&#x51FD;&#x6570;.
    /// Handle events on the serial input fd.
    fn process(&amp;mut self, event: Events, ops: &amp;mut EventOps) {
        #[inline]
        fn unregister_source&lt;T: AsRawFd&gt;(ops: &amp;mut EventOps, source: &amp;T) {
            match ops.remove(Events::new(source, EventSet::IN)) {
                Ok(_) =&gt; (),
                Err(_) =&gt; error!(&quot;Could not unregister source fd: {}&quot;, source.as_raw_fd()),
            }
        }

        let input_fd = self.serial_input_fd();
        let buffer_ready_fd = self.buffer_ready_evt_fd();
        if input_fd &lt; 0 || buffer_ready_fd &lt; 0 {
            error!(&quot;Serial does not have a configured input source.&quot;);
            return;
        }

        if buffer_ready_fd == event.fd() {
            match self.consume_buffer_ready_event() {
                Ok(_) =&gt; (),
                Err(err) =&gt; {
                    error!(&quot;Detach serial device input source due to error in consuming the buffer ready event: {:?}&quot;, err);
                    unregister_source(ops, &amp;input_fd);
                    unregister_source(ops, &amp;buffer_ready_fd);
                    return;
                }
            }
        }

        // We expect to receive: `EventSet::IN`, `EventSet::HANG_UP` or
        // `EventSet::ERROR`. To process all these events we just have to
        // read from the serial input.
        match self.recv_bytes() {
            Ok(count) =&gt; {
                // Handle EOF if the event came from the input source.
                if input_fd == event.fd() &amp;&amp; count == 0 {
                    unregister_source(ops, &amp;input_fd);
                    unregister_source(ops, &amp;buffer_ready_fd);
                    warn!(&quot;Detached the serial input due to peer close/error.&quot;);
                }
            }
            Err(e) =&gt; {
                match e.raw_os_error() {
                    Some(errno) if errno == libc::ENOBUFS =&gt; {
                        unregister_source(ops, &amp;input_fd);
                    }
                    //&#x8FD9;&#x91CC;&#x662F;none-block read&#x6CA1;&#x4E1C;&#x897F;&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x8FD4;&#x56DE;EAGAIN&#x6216;&#x8005;EWOULDBLOCK, &#x90FD;&#x5DEE;&#x4E0D;&#x591A;
                    Some(errno) if errno == libc::EWOULDBLOCK =&gt; {
                        self.handle_ewouldblock(ops);
                    }
                    Some(errno) if errno == libc::ENOTTY =&gt; {
                        error!(&quot;The serial device does not have the input source attached.&quot;);
                        unregister_source(ops, &amp;input_fd);
                        unregister_source(ops, &amp;buffer_ready_fd);
                    }
                    Some(_) | None =&gt; {
                        // Unknown error, detach the serial input source.
                        unregister_source(ops, &amp;input_fd);
                        unregister_source(ops, &amp;buffer_ready_fd);
                        warn!(&quot;Detached the serial input due to peer close/error.&quot;);
                    }
                }
            }
        }
    }

    /// Initial registration of pollable objects.
    /// If serial input is present, register the serial input FD as readable.
    fn init(&amp;mut self, ops: &amp;mut EventOps) {
        //input&#x5C31;&#x662F;stdin, buffer_ready_event_fd&#x5C31;&#x662F;&#x524D;&#x9762;&#x7684;kick_stdin_read_evt&#x8FD9;&#x4E2A;eventfd
        if self.input.is_some() &amp;&amp; self.serial.events().buffer_ready_event_fd.is_some() {
            let serial_fd = self.serial_input_fd();
            let buf_ready_evt = self.buffer_ready_evt_fd();
            if serial_fd != -1 {
                //&#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x628A;stdin&#x52A0;&#x5230;epoll
                if let Err(e) = ops.add(Events::new(&amp;serial_fd, EventSet::IN)) {
                    warn!(&quot;Failed to register serial input fd: {}&quot;, e);
                }
            }
            //&#x8FD9;&#x4E2A;&#x5B9E;&#x9645;&#x4E0A;&#x662F;kick_stdin_read_evt&#x8FD9;&#x4E2A;eventfd
            if let Err(e) = ops.add(Events::new(&amp;buf_ready_evt, EventSet::IN)) {
                warn!(&quot;Failed to register serial buffer ready event: {}&quot;, e);
            }
        }
    }
}
</code></pre>
<h2 id="&#x5B9E;&#x73B0;&#x4E86;busdevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait"><a name="&#x5B9E;&#x73B0;&#x4E86;busdevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait" class="anchor-navigation-ex-anchor" href="#&#x5B9E;&#x73B0;&#x4E86;busdevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait"><i class="fa fa-link" aria-hidden="true"></i></a>6.2. &#x5B9E;&#x73B0;&#x4E86;BusDevice&#x7684;&#x6309;&#x5730;&#x5740;&#x8BFB;&#x5199;&#x7684;trait</h2>
<p>&#x6309;&#x603B;&#x7EBF;&#x5730;&#x5740;&#x8BFB;&#x5199;, &#x6700;&#x7EC8;&#x8F6C;&#x5316;&#x4E3A;&#x8BBE;&#x5907;&#x5185;&#x504F;&#x79FB;&#x5730;&#x5740;&#x8BFB;&#x5199;</p>
<pre><code class="lang-rust">impl&lt;W: Write + Send&gt; BusDevice
    for SerialWrapper&lt;EventFdTrigger, SerialEventsWrapper, W&gt;
{
    //&#x8BFB;&#x662F;&#x4ECE;&#x5185;&#x90E8;in_buffer&#x8BFB;
    fn read(&amp;mut self, offset: u64, data: &amp;mut [u8]) {
        if data.len() != 1 {
            self.serial.events().metrics.missed_read_count.inc();
            return;
        }
        data[0] = self.serial.read(offset as u8);
    }

    //&#x5199;&#x662F;&#x5199;&#x5230;stdout
    fn write(&amp;mut self, offset: u64, data: &amp;[u8]) {
        if data.len() != 1 {
            self.serial.events().metrics.missed_write_count.inc();
            return;
        }
        if let Err(e) = self.serial.write(offset as u8, data[0]) {
            // Counter incremented for any handle_write() error.
            error!(&quot;Failed the write to serial: {:?}&quot;, e);
            self.serial.events().metrics.error_count.inc();
        }
    }
}
</code></pre>
<h1 id="attachvirtiodevice"><a name="attachvirtiodevice" class="anchor-navigation-ex-anchor" href="#attachvirtiodevice"><i class="fa fa-link" aria-hidden="true"></i></a>7. attach_virtio_device</h1>
<pre><code class="lang-rust">/// Attaches a VirtioDevice device to the device manager and event manager.
fn attach_virtio_device&lt;T: VirtioDevice + MutEventSubscriber&gt;(
    event_manager: &amp;mut EventManager,
    vmm: &amp;mut Vmm,
    id: String,
    device: Arc&lt;Mutex&lt;T&gt;&gt;,
    cmdline: &amp;mut LoaderKernelCmdline,
) -&gt; std::result::Result&lt;(), StartMicrovmError&gt; {
    use self::StartMicrovmError::*;

    //&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;&#x8BA2;&#x9605;
    event_manager.add_subscriber(device.clone());

    let device = MmioTransport::new(vmm.guest_memory().clone(), device);
    vmm.mmio_device_manager
        .register_mmio_virtio_for_boot(vmm.vm.fd(), id, device, cmdline)
            //&#x5206;&#x914D;mmio&#x7684;addr len&#x548C;irq&#x8D44;&#x6E90;, &#x7B56;&#x7565;&#x662F;&#x4F9D;&#x6B21;&#x987A;&#x5E8F;&#x5206;&#x914D;
            let mmio_slot = self.allocate_new_slot(1)?;
            self.register_mmio_virtio(vm, device_id, mmio_device, &amp;mmio_slot)?;
                let locked_device = mmio_device.locked_device();
                identifier = (DeviceType::Virtio(locked_device.device_type()), device_id);
                //&#x5BF9;&#x6BCF;&#x4E2A;queue
                for (i, queue_evt) in locked_device.queue_events().iter().enumerate()
                    //NOTIFY_REG_OFFSET&#x662F;0x50, &#x52A0;&#x4E0A;slot.addr&#x8FD9;&#x4E2A;mmio device&#x7684;base&#x5730;&#x5740;
                    //&#x6CE8;&#x610F;, &#x5E76;&#x4E0D;&#x662F;&#x6240;&#x6709;&#x7684;mmio&#x8BBE;&#x5907;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x8BBF;&#x95EE;&#x90FD;&#x4F1A;&#x89E6;&#x53D1;event, &#x8FD9;&#x4E2A;io_addr&#x53EA;&#x662F;&#x7279;&#x5B9A;&#x5730;&#x5740;, &#x7528;&#x6765;notify device&#x7684;.
                    let io_addr = IoEventAddress::Mmio(slot.addr + u64::from(devices::virtio::NOTIFY_REG_OFFSET));
                    //&#x8FD9;&#x4E2A;queue_evt&#x662F;&#x6BCF;&#x4E2A;queue&#x7684;eventfd, &#x5199;io_addr&#x5C31;&#x4F1A;&#x89E6;&#x53D1;event, &#x8BF4;&#x660E;guest driver&#x8981;&#x901A;&#x77E5;device&#x6765;&#x5E72;&#x6D3B;&#x4E86;
                    //&#x8C03;&#x7528;&#x4E86;kvm&#x7684;ioctl
                    vm.register_ioevent(queue_evt, &amp;io_addr, i as u32) //&#x5199;&#x8FD9;&#x6307;&#x5B9A;&#x5730;&#x5740;&#x7684;&#x65F6;&#x5019;&#x53D1;event&#x5230;queue_evt
                vm.register_irqfd() //&#x6CE8;&#x518C;&#x4E2D;&#x65AD;&#x6CE8;&#x5165;guest&#x7684;eventfd&#x548C;irq&#x53F7;, &#x8C03;&#x7528;kvm ioctl KVM_IRQFD; &#x610F;&#x601D;&#x662F;&#x53EA;&#x8981;&#x8FD9;&#x4E2A;eventfd&#x88AB;&#x5199;&#x5165;, &#x5185;&#x6838;&#x7684;kvm&#x6A21;&#x5757;&#x5C31;&#x4F1A;&#x7ED9;guest&#x53D1;&#x6307;&#x5B9A;&#x7684;irq&#x53F7;&#x4E2D;&#x65AD;.
                register_mmio_device()
}
</code></pre>
<h2 id="vmregisterioeventqueueevt-ioaddr-i--as--u32"><a name="vmregisterioeventqueueevt-ioaddr-i--as--u32" class="anchor-navigation-ex-anchor" href="#vmregisterioeventqueueevt-ioaddr-i--as--u32"><i class="fa fa-link" aria-hidden="true"></i></a>7.1. vm.register_ioevent(queue_evt, &amp;io_addr, i  as  u32)</h2>
<p>&#x4E09;&#x4E2A;&#x53C2;&#x6570;&#x5982;&#x4E0B;:</p>
<blockquote>
<p><code>fd</code> - <code>EventFd</code> which will be signaled. When signaling, the usual <code>vmexit</code> to userspace is prevented.<br><code>addr</code> - Address being written to.<br><code>datamatch</code> - Limits signaling <code>fd</code> to only the cases where the value being written is equal to this parameter. The size of <code>datamatch</code> is important and it must match the expected size of the guest&apos;s write.</p>
</blockquote>
<p>guest&#x9A71;&#x52A8;&#x9700;&#x8981;&#x67D0;&#x79CD;&#x65B9;&#x6CD5;&#x6765;&#x901A;&#x77E5;device, kvm&#x7684;ioeventfd&#x5C31;&#x662F;&#x5E72;&#x8FD9;&#x4E2A;&#x7528;&#x7684;. &#x7528;eventfd&#x7684;&#x597D;&#x5904;&#x662F;&#x8FD9;&#x4E2A;guest driver&#x5230;device&#x7684;&#x901A;&#x77E5;&#x4E0D;&#x9700;&#x8981;vmexit.</p>
<blockquote>
<p>Registers an event to be signaled whenever a certain address is written to. When signaling, the usual <code>vmexit</code> to userspace is prevented.</p>
</blockquote>
<p>&#x5BF9;&#x5E94;KVM&#x7684;<code>KVM_IOEVENTFD</code>  </p>
<blockquote>
<p>This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address within the guest. A guest write in the registered address will signal the provided event instead of triggering an exit.</p>
<p>If datamatch flag is set, the event will be signaled only if the written value to the registered address is equal to datamatch in struct kvm_ioeventfd.</p>
</blockquote>
<p>&#x6CE8;&#x610F;: &#x8FD9;&#x4E2A;&#x5BF9;&#x6BCF;&#x4E2A;queue&#x90FD;&#x8C03;&#x7528;&#x4E86;<code>vm.register_ioevent(queue_evt, &amp;io_addr, i as u32)</code>, &#x4F5C;&#x7528;&#x662F;&#x7ED9;<code>io_addr</code>&#x5730;&#x5740;&#x7ED1;&#x5B9A;&#x4E00;&#x4E2A;<code>queue_evt</code>, &#x5F53;driver&#x5199;<code>i</code>&#x5230;&#x8FD9;&#x4E2A;<code>io_aadr</code>&#x5730;&#x5740;&#x7684;&#x65F6;&#x5019;, signal&#x7ED9;<code>queue_evt</code>.
&#x4F46;&#x95EE;&#x9898;&#x662F;, &#x5982;&#x679C;&#x662F;&#x591A;&#x4E2A;queue, &#x591A;&#x4E2A;<code>queue_evt</code>&#x90FD;&quot;&#x7ED1;&#x5B9A;&quot;&#x5230;&#x540C;&#x4E00;&#x4E2A;<code>io_addr</code>.<br>&#x6211;&#x731C;&#x6D4B;&#x8FD9;&#x4E2A;API&#x662F;&#x652F;&#x6301;&#x591A;&#x4E2A;&#x4E00;&#x4E2A;&#x5730;&#x5740;&#x5BF9;&#x5E94;&#x591A;&#x4E2A;eventfd&#x7684;, &#x53EF;&#x80FD;&#x7531;datamatch&#x7684;&#x503C;&#x6765;&#x533A;&#x5206;&#x8FD9;&#x4E2A;signal&#x53D1;&#x9001;&#x5230;&#x54EA;&#x4E2A;eventfd</p>
<h2 id="vmregisterirqfd"><a name="vmregisterirqfd" class="anchor-navigation-ex-anchor" href="#vmregisterirqfd"><i class="fa fa-link" aria-hidden="true"></i></a>7.2. vm.register_irqfd</h2>
<p><code>vm.register_irqfd(locked_device.interrupt_evt(), slot.irqs[0])</code>
&#x8C03;&#x7528;kvm&#x7684;ioctl&#x7684;<code>KVM_IRQFD</code>(&#x89C1;&#x4E0B;&#x9762;)
IRQFD&#x662F;device&#x5199;eventfd, &#x901A;&#x8FC7;kvm&#x89E6;&#x53D1;guest&#x4E2D;&#x65AD;&#x7684;&#x673A;&#x5236;.</p>
<h2 id="kvm&#x7684;irq&#x76F8;&#x5173;api"><a name="kvm&#x7684;irq&#x76F8;&#x5173;api" class="anchor-navigation-ex-anchor" href="#kvm&#x7684;irq&#x76F8;&#x5173;api"><i class="fa fa-link" aria-hidden="true"></i></a>7.3. kvm&#x7684;irq&#x76F8;&#x5173;API</h2>
<p><a href="https://www.kernel.org/doc/html/latest/virt/kvm/api.html" target="_blank">https://www.kernel.org/doc/html/latest/virt/kvm/api.html</a></p>
<h3 id="kvmcreateirqchip"><a name="kvmcreateirqchip" class="anchor-navigation-ex-anchor" href="#kvmcreateirqchip"><i class="fa fa-link" aria-hidden="true"></i></a>7.3.1. KVM_CREATE_IRQCHIP</h3>
<p>Creates an interrupt controller model in the kernel. On x86, creates a virtual ioapic, a virtual PIC (two PICs, nested), and sets up future vcpus to have a local APIC. IRQ routing for GSIs 0-15 is set to both PIC and IOAPIC; GSI 16-23 only go to the IOAPIC. On arm64, a GICv2 is created. Any other GIC versions require the usage of KVM_CREATE_DEVICE, which also supports creating a GICv2. Using KVM_CREATE_DEVICE is preferred over KVM_CREATE_IRQCHIP for GICv2. On s390, a dummy irq routing table is created.</p>
<h3 id="kvmsetgsirouting"><a name="kvmsetgsirouting" class="anchor-navigation-ex-anchor" href="#kvmsetgsirouting"><i class="fa fa-link" aria-hidden="true"></i></a>7.3.2. KVM_SET_GSI_ROUTING</h3>
<p>Sets the GSI routing table entries, overwriting any previously set entries.</p>
<h3 id="kvmirqfd"><a name="kvmirqfd" class="anchor-navigation-ex-anchor" href="#kvmirqfd"><i class="fa fa-link" aria-hidden="true"></i></a>7.3.3. KVM_IRQFD</h3>
<p>Allows setting an eventfd to directly trigger a guest interrupt. kvm_irqfd.fd specifies the file descriptor to use as the eventfd and kvm_irqfd.gsi specifies the irqchip pin toggled by this event. When an event is triggered on the eventfd, an interrupt is injected into the guest using the specified gsi pin. The irqfd is removed using the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both kvm_irqfd.fd and kvm_irqfd.gsi.</p>
<p>With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify mechanism allowing emulation of level-triggered, irqfd-based interrupts. When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an additional eventfd in the kvm_irqfd.resamplefd field. When operating in resample mode, posting of an interrupt through kvm_irq.fd asserts the specified gsi in the irqchip. When the irqchip is resampled, such as from an EOI, the gsi is de-asserted and the user is notified via kvm_irqfd.resamplefd. It is the user&#x2019;s responsibility to re-queue the interrupt if the device making use of it still requires service. Note that closing the resamplefd is not sufficient to disable the irqfd. The KVM_IRQFD_FLAG_RESAMPLE is only necessary on assignment and need not be specified with KVM_IRQFD_FLAG_DEASSIGN.</p>
<p>On arm64, gsi routing being supported, the following can happen:</p>
<ul>
<li>in case no routing entry is associated to this gsi, injection fails</li>
<li>in case the gsi is associated to an irqchip routing entry, irqchip.pin + 32 corresponds to the injected SPI ID.</li>
<li>in case the gsi is associated to an MSI routing entry, the MSI message and device ID are translated into an LPI (support restricted to GICv3 ITS in-kernel emulation).</li>
</ul>
<h3 id="kvmcreatedevice"><a name="kvmcreatedevice" class="anchor-navigation-ex-anchor" href="#kvmcreatedevice"><i class="fa fa-link" aria-hidden="true"></i></a>7.3.4. KVM_CREATE_DEVICE</h3>
<p>Creates an emulated device in the kernel. The file descriptor returned in fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR.</p>
<p>If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the device type is supported (not necessarily whether it can be created in the current vm).</p>
<p>Individual devices should not define flags. Attributes should be used for specifying any behavior that is not implied by the device type number.</p>
<h4 id="&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x53EF;&#x4EE5;&#x88AB;create"><a name="&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x53EF;&#x4EE5;&#x88AB;create" class="anchor-navigation-ex-anchor" href="#&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x53EF;&#x4EE5;&#x88AB;create"><i class="fa fa-link" aria-hidden="true"></i></a>&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x53EF;&#x4EE5;&#x88AB;create</h4>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/index.html" target="_blank">Devices</a><ul>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/arm-vgic-its.html" target="_blank">ARM Virtual Interrupt Translation Service (ITS)</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/arm-vgic.html" target="_blank">ARM Virtual Generic Interrupt Controller v2 (VGIC)</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/arm-vgic-v3.html" target="_blank">ARM Virtual Generic Interrupt Controller v3 and later (VGICv3)</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/mpic.html" target="_blank">MPIC interrupt controller</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/s390_flic.html" target="_blank">FLIC (floating interrupt controller)</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/vcpu.html" target="_blank">Generic vcpu interface</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/vfio.html" target="_blank">VFIO virtual device</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/vm.html" target="_blank">Generic vm interface</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/xics.html" target="_blank">XICS interrupt controller</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/virt/kvm/devices/xive.html" target="_blank">POWER9 eXternal Interrupt Virtualization Engine (XIVE Gen1)</a></li>
</ul>
</li>
</ul>
<h3 id="arm-gic-v3"><a name="arm-gic-v3" class="anchor-navigation-ex-anchor" href="#arm-gic-v3"><i class="fa fa-link" aria-hidden="true"></i></a>7.3.5. ARM gic v3</h3>
<p>Only one VGIC instance may be instantiated through this API. The created VGIC will act as the VM interrupt controller, requiring emulated user-space devices to inject interrupts to the VGIC instead of directly to CPUs. It is not possible to create both a GICv3 and GICv2 on the same VM.</p>
<p>Creating a guest GICv3 device requires a host GICv3 as well.</p>
<h4 id="kvmdevarmvgicgrpaddr"><a name="kvmdevarmvgicgrpaddr" class="anchor-navigation-ex-anchor" href="#kvmdevarmvgicgrpaddr"><i class="fa fa-link" aria-hidden="true"></i></a>KVM_DEV_ARM_VGIC_GRP_ADDR</h4>
<p>&#x5B9A;&#x4E49;&#x4E86;vgic&#x5BC4;&#x5B58;&#x5668;&#x5728;guest&#x7269;&#x7406;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x57FA;&#x5730;&#x5740;</p>
<ul>
<li><p>KVM_VGIC_V3_ADDR_TYPE_DIST (rw, 64-bit)
Base address in the guest physical address space of the GICv3 distributor register mappings. Only valid for KVM_DEV_TYPE_ARM_VGIC_V3. This address needs to be 64K aligned and the region covers 64 KByte.</p>
</li>
<li><p>KVM_VGIC_V3_ADDR_TYPE_REDIST (rw, 64-bit)
Base address in the guest physical address space of the GICv3 redistributor register mappings. There are two 64K pages for each VCPU and all of the redistributor pages are contiguous. Only valid for KVM_DEV_TYPE_ARM_VGIC_V3. This address needs to be 64K aligned.</p>
</li>
</ul>
<h2 id="mmiotransport"><a name="mmiotransport" class="anchor-navigation-ex-anchor" href="#mmiotransport"><i class="fa fa-link" aria-hidden="true"></i></a>7.4. MmioTransport</h2>
<p>mplements the MMIO transport for virtio devices.</p>
<p>This requires 3 points of installation to work with a VM:</p>
<ol>
<li>Mmio reads and writes must be sent to this device at what is referred to here as MMIO base.</li>
<li><code>Mmio::queue_evts</code> must be installed at <code>virtio::NOTIFY_REG_OFFSET</code> offset from the MMIO base. Each event in the array must be signaled if the index is written at that offset.</li>
<li><code>Mmio::interrupt_evt</code> must signal an interrupt that the guest driver is listening to when it is written to.</li>
</ol>
<p>Typically one page (4096 bytes) of MMIO address space is sufficient to handle this transport and inner virtio device.</p>
<p>&#x5BF9;&#x5E94;&#x7684;&#x7ED3;&#x6784;&#x4F53;:</p>
<pre><code class="lang-rust">pub struct MmioTransport {
    device: Arc&lt;Mutex&lt;dyn VirtioDevice&gt;&gt;,
    // The register where feature bits are stored.
    pub(crate) features_select: u32,
    // The register where features page is selected.
    pub(crate) acked_features_select: u32,
    pub(crate) queue_select: u32,
    pub(crate) device_status: u32,
    pub(crate) config_generation: u32,
    mem: GuestMemoryMmap,
    pub(crate) interrupt_status: Arc&lt;AtomicUsize&gt;,
}
</code></pre>
<h3 id="impl-mmiotransport"><a name="impl-mmiotransport" class="anchor-navigation-ex-anchor" href="#impl-mmiotransport"><i class="fa fa-link" aria-hidden="true"></i></a>7.4.1. impl MmioTransport</h3>
<pre><code class="lang-rust">impl MmioTransport {
    /// Constructs a new MMIO transport for the given virtio device.
    pub fn new(mem: GuestMemoryMmap, device: Arc&lt;Mutex&lt;dyn VirtioDevice&gt;&gt;) -&gt; MmioTransport {
        //&#x8FD9;&#x91CC;&#x5C0F;&#x77E5;&#x8BC6;&#x70B9;: device.lock()&#x8FD4;&#x56DE;&#x7684;&#x662F;mutextGuard, &#x5B83;&#x4F1A;&#x5728;&#x751F;&#x547D;&#x5468;&#x671F;&#x7ED3;&#x675F;&#x540E;&#x81EA;&#x52A8;&#x8C03;&#x7528;unlock. 
        //&#x4E0D;&#x7528;&#x62C5;&#x5FC3;&#x4E00;&#x76F4;&#x4F1A;lock, &#x56E0;&#x4E3A;device.lock()&#x7684;&#x58F0;&#x660E;&#x5468;&#x671F;&#x53EA;&#x6709;&#x4E0B;&#x9762;&#x4E00;&#x884C;
        //&#x8FD9;&#x884C;&#x7ED3;&#x675F;&#x4E86;&#x5176;&#x5B9E;&#x5C31;&#x5DF2;&#x7ECF;unlock&#x4E86;.
        let interrupt_status = device.lock().expect(&quot;Poisoned lock&quot;).interrupt_status();

        //new&#x8FD9;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;
        MmioTransport {
            device,
            features_select: 0,
            acked_features_select: 0,
            queue_select: 0,
            device_status: device_status::INIT,
            config_generation: 0,
            mem,
            interrupt_status,
        }
    }

    pub fn locked_device(&amp;self) -&gt; MutexGuard&lt;dyn VirtioDevice + static&gt; {
        self.device.lock().expect(&quot;Poisoned lock&quot;)
    }
    // Gets the encapsulated VirtioDevice.
    pub fn device(&amp;self) -&gt; Arc&lt;Mutex&lt;dyn VirtioDevice&gt;&gt; {
        self.device.clone()
    }
    fn check_device_status(&amp;self, set: u32, clr: u32) -&gt; bool {
        self.device_status &amp; (set | clr) == set
    }
    fn are_queues_valid(&amp;self) -&gt; bool {
        self.locked_device()
            .queues()
            .iter()
            .all(|q| q.is_valid(&amp;self.mem))
    }
    //&#x6CE8;&#x610F;&#x5230;&#x6CDB;&#x578B;U, &#x5E76;&#x6CA1;&#x6709;&#x7EA6;&#x675F;;
    //&#x8FD9;&#x91CC;&#x7684;&#x610F;&#x601D;&#x662F;&#x5165;&#x53C2;d&#x7684;&#x7C7B;&#x578B;&#x662F;U, &#x8868;&#x793A;&#x9ED8;&#x8BA4;&#x503C;.
    fn with_queue&lt;U, F&gt;(&amp;self, d: U, f: F) -&gt; U
    where
        F: FnOnce(&amp;Queue) -&gt; U,
    {
        match self
            .locked_device()
            .queues()
            .get(self.queue_select as usize)
        {
            Some(queue) =&gt; f(queue),
            None =&gt; d,
        }
    }
    fn with_queue_mut&lt;F: FnOnce(&amp;mut Queue)&gt;(&amp;mut self, f: F) -&gt; bool {
        if let Some(queue) = self
            .locked_device()
            .queues_mut()
            .get_mut(self.queue_select as usize)
        {
            f(queue);
            true
        } else {
            false
        }
    }
    fn update_queue_field&lt;F: FnOnce(&amp;mut Queue)&gt;(&amp;mut self, f: F) {
        if self.check_device_status(
            device_status::FEATURES_OK,
            device_status::DRIVER_OK | device_status::FAILED,
        ) {
            self.with_queue_mut(f);
        } else {
            warn!(
                &quot;update virtio queue in invalid state 0x{:x}&quot;,
                self.device_status
            );
        }
    }
    fn reset(&amp;mut self) {
        &#x91CD;&#x7F6E;&#x7ED3;&#x6784;&#x4F53;&quot;&#x5BC4;&#x5B58;&#x5668;&quot;
    }
    //&#x6839;&#x636E;VirtIO Spec 1.0, section 2.1.1 and 3.1.1
    //&#x5728;device&#x7684;write&#x91CC;&#x9762;&#x8C03;&#x7528;, &#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x7ED9;guest&#x7684;driver&#x7528;&#x7684;
    fn set_device_status(&amp;mut self, status: u32) {
    }
}
</code></pre>
<h3 id="&#x5B9E;&#x73B0;busdevice"><a name="&#x5B9E;&#x73B0;busdevice" class="anchor-navigation-ex-anchor" href="#&#x5B9E;&#x73B0;busdevice"><i class="fa fa-link" aria-hidden="true"></i></a>7.4.2. &#x5B9E;&#x73B0;BusDevice</h3>
<p>&#x6839;&#x636E;virtIO&#x89C4;&#x8303;MMIO transport&#x65B9;&#x5F0F;:<br><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/csd01/virtio-v1.2-csd01.html#x1-1650002" target="_blank">https://docs.oasis-open.org/virtio/virtio/v1.2/csd01/virtio-v1.2-csd01.html#x1-1650002</a></p>
<pre><code class="lang-rust">impl BusDevice for MmioTransport {
    fn read(&amp;mut self, offset: u64, data: &amp;mut [u8]) {
        match offset {
            0x00..=0xff if data.len() == 4 =&gt; {
                let v = match offset {
                    0x0 =&gt; MMIO_MAGIC_VALUE,
                    0x04 =&gt; MMIO_VERSION,
                    0x08 =&gt; self.locked_device().device_type(),
                    0x0c =&gt; VENDOR_ID, // vendor id
                    0x10 =&gt; { //32bit&#x7684;feature flag
                        let mut features = self
                            .locked_device()
                            .avail_features_by_page(self.features_select);
                        if self.features_select == 1 {
                            features |= 0x1; // enable support of VirtIO Version 1
                        }
                        features
                    }
                    //&#x5BF9;&#x5DF2;&#x7ECF;&#x9009;&#x4E2D;&#x7684;queue(QueueSel), &#x8BFB;&#x51FA;queue&#x5185;&#x5143;&#x7D20;&#x4E2A;&#x6570;; Reading from the register returns the maximum size (number of elements) of the queue the device is ready to process or zero (0x0) if the queue is not available.
                    0x34 =&gt; self.with_queue(0, |q| u32::from(q.get_max_size())),
                    //&#x5BF9;&#x5DF2;&#x7ECF;&#x9009;&#x4E2D;&#x7684;queue, &#x5199;1&#x8868;&#x793A;ready. &#x8BFB;&#x662F;&#x8BFB;&#x4E0A;&#x4E00;&#x6B21;&#x7684;&#x503C;
                    0x44 =&gt; self.with_queue(0, |q| q.ready as u32),
                    //&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#x5BC4;&#x5B58;&#x5668;, &#x8981;&#x4E48;&#x662F;Used Buffer Notification(bit 0), &#x8981;&#x4E48;&#x662F;Configuration Change Notification(bit 1)
                    0x60 =&gt; self.interrupt_status.load(Ordering::SeqCst) as u32,
                    //&#x8BBE;&#x5907;&#x72B6;&#x6001;&#x5BC4;&#x5B58;&#x5668;.
                    0x70 =&gt; self.device_status,
                    //&#x914D;&#x7F6E;&#x7A7A;&#x95F4;&#x539F;&#x5B50;&#x6027;&#x5BC4;&#x5B58;&#x5668;, &#x4E24;&#x6B21;&#x8BFB;&#x7684;&#x4E00;&#x6837;&#x5C31;&#x662F;&#x539F;&#x5B50;&#x7684;?
                    0xfc =&gt; self.config_generation,
                    _ =&gt; {
                        warn!(&quot;unknown virtio mmio register read: 0x{:x}&quot;, offset);
                        return;
                    }
                };
                byte_order::write_le_u32(data, v); //&#x6CE8;&#x610F;&#x8FD9;&#x91CC;, &#x4F7F;&#x7528;byte_order&#x7684;&#x5C0F;&#x7AEF;&#x5199;
            }
            0x100..=0xfff =&gt; self.locked_device().read_config(offset - 0x100, data),
            _ =&gt; {
                warn!(
                    &quot;invalid virtio mmio read: 0x{:x}:0x{:x}&quot;,
                    offset,
                    data.len()
                );
            }
        };
    }

    fn write(&amp;mut self, offset: u64, data: &amp;[u8]) {
        fn hi(v: &amp;mut GuestAddress, x: u32) {
            *v = (*v &amp; 0xffff_ffff) | (u64::from(x) &lt;&lt; 32)
        }

        fn lo(v: &amp;mut GuestAddress, x: u32) {
            *v = (*v &amp; !0xffff_ffff) | u64::from(x)
        }

        match offset {
            0x00..=0xff if data.len() == 4 =&gt; {
                let v = byte_order::read_le_u32(data); //&#x6309;&#x5C0F;&#x7AEF;&#x65B9;&#x5F0F;&#x7406;&#x89E3;data
                match offset {
                    //Device (host) features word selection. &#x5199;&#x8FD9;&#x4E2A;&#x5BC4;&#x5B58;&#x5668;&#x9009;&#x62E9;feature flag
                    0x14 =&gt; self.features_select = v,
                    //Flags representing device features understood and activated by the driver
                    0x20 =&gt; {
                        if self.check_device_status(
                            device_status::DRIVER,
                            device_status::FEATURES_OK | device_status::FAILED,
                        ) {
                            self.locked_device()
                                .ack_features_by_page(self.acked_features_select, v);
                        } else {
                            warn!(
                                &quot;ack virtio features in invalid state 0x{:x}&quot;,
                                self.device_status
                            );
                        }
                    }
                    //Activated (guest) features word selection
                    0x24 =&gt; self.acked_features_select = v,
                    //&#x8FD9;&#x4E2A;&#x5C31;&#x662F;QueueSel, &#x4E5F;&#x53EB;Virtual queue index, &#x4ECE;0&#x5F00;&#x59CB;
                    0x30 =&gt; self.queue_select = v,
                    //Virtual queue size
                    0x38 =&gt; self.update_queue_field(|q| q.size = v as u16),
                    //queue read
                    //Writing one (0x1) to this register notifies the device that it can execute requests from this virtual queue.
                    0x44 =&gt; self.update_queue_field(|q| q.ready = v == 1),
                    //&#x4E2D;&#x65AD;&#x5E94;&#x7B54;
                    0x64 =&gt; {
                        if self.check_device_status(device_status::DRIVER_OK, 0) {
                            self.interrupt_status
                                .fetch_and(!(v as usize), Ordering::SeqCst);
                        }
                    }
                    //Device status: Writing non-zero values to this register sets the status flags, indicating the driver progress
                    0x70 =&gt; self.set_device_status(v),
                    //Virtual queue&#x2019;s Descriptor Area 64 bit long physical address
                    0x80 =&gt; self.update_queue_field(|q| lo(&amp;mut q.desc_table, v)),
                    0x84 =&gt; self.update_queue_field(|q| hi(&amp;mut q.desc_table, v)),
                    //Virtual queue&#x2019;s Driver Area 64 bit long physical address
                    0x90 =&gt; self.update_queue_field(|q| lo(&amp;mut q.avail_ring, v)),
                    0x94 =&gt; self.update_queue_field(|q| hi(&amp;mut q.avail_ring, v)),
                    //Virtual queue&#x2019;s Device Area 64 bit long physical address
                    0xa0 =&gt; self.update_queue_field(|q| lo(&amp;mut q.used_ring, v)),
                    0xa4 =&gt; self.update_queue_field(|q| hi(&amp;mut q.used_ring, v)),
                    _ =&gt; {
                        warn!(&quot;unknown virtio mmio register write: 0x{:x}&quot;, offset);
                    }
                }
            }
            0x100..=0xfff =&gt; {
                if self.check_device_status(device_status::DRIVER, device_status::FAILED) {
                    self.locked_device().write_config(offset - 0x100, data)
                } else {
                    warn!(&quot;can not write to device config data area before driver is ready&quot;);
                }
            }
            _ =&gt; {
                warn!(
                    &quot;invalid virtio mmio write: 0x{:x}:0x{:x}&quot;,
                    offset,
                    data.len()
                );
            }
        }
    }
}
</code></pre>
<h2 id="device"><a name="device" class="anchor-navigation-ex-anchor" href="#device"><i class="fa fa-link" aria-hidden="true"></i></a>7.5. device</h2>
<h3 id="device&#x7684;&#x72B6;&#x6001;&#x6709;"><a name="device&#x7684;&#x72B6;&#x6001;&#x6709;" class="anchor-navigation-ex-anchor" href="#device&#x7684;&#x72B6;&#x6001;&#x6709;"><i class="fa fa-link" aria-hidden="true"></i></a>7.5.1. device&#x7684;&#x72B6;&#x6001;&#x6709;</h3>
<pre><code class="lang-rust">/// Enum that indicates if a VirtioDevice is inactive or has been activated
/// and memory attached to it.
pub enum DeviceState {
    Inactive,
    Activated(GuestMemoryMmap),
}
</code></pre>
<p>&#x8FD9;&#x4E2A;enum&#x4E5F;&#x6709;&#x65B9;&#x6CD5;, &#x5176;&#x4E2D;<code>mem()</code>&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;GuestmemoryMmap</p>
<pre><code class="lang-rust">impl DeviceState {
    /// Checks if the device is activated.
    pub fn is_activated(&amp;self) -&gt; bool {
        match self {
            DeviceState::Inactive =&gt; false,
            DeviceState::Activated(_) =&gt; true,
        }
    }

    /// Gets the memory attached to the device if it is activated.
    pub fn mem(&amp;self) -&gt; Option&lt;&amp;GuestMemoryMmap&gt; {
        match self {
            DeviceState::Activated(ref mem) =&gt; Some(mem),
            DeviceState::Inactive =&gt; None,
        }
    }
}
</code></pre>
<h3 id="irqtrigger"><a name="irqtrigger" class="anchor-navigation-ex-anchor" href="#irqtrigger"><i class="fa fa-link" aria-hidden="true"></i></a>7.5.2. IrqTrigger</h3>
<p>IrqTrigger&#x5305;&#x542B;&#x4E00;&#x4E2A;eventFd&#x53EB;<code>irq_evt</code>, <code>trigger_irq</code>&#x65B9;&#x6CD5;&#x5C31;&#x662F;&#x5199;&#x8FD9;&#x4E2A;eventFd.</p>
<pre><code class="lang-rust">/// Helper struct that is responsible for triggering guest IRQs
pub struct IrqTrigger {
    pub(crate) irq_status: Arc&lt;AtomicUsize&gt;,
    pub(crate) irq_evt: EventFd,
}

impl IrqTrigger {
    pub fn new() -&gt; std::io::Result&lt;Self&gt; {
        Ok(Self {
            irq_status: Arc::new(AtomicUsize::new(0)),
            irq_evt: EventFd::new(libc::EFD_NONBLOCK)?,
        })
    }

    pub fn trigger_irq(&amp;self, irq_type: IrqType) -&gt; std::result::Result&lt;(), std::io::Error&gt; {
        let irq = match irq_type {
            IrqType::Config =&gt; VIRTIO_MMIO_INT_CONFIG,
            IrqType::Vring =&gt; VIRTIO_MMIO_INT_VRING,
        };
        //irq&#x72B6;&#x6001;
        self.irq_status.fetch_or(irq as usize, Ordering::SeqCst);
        //eventfd&#x5199;1
        self.irq_evt.write(1).map_err(|e| {
            error!(&quot;Failed to send irq to the guest: {:?}&quot;, e);
            e
        })?;

        Ok(())
    }
}
</code></pre>
<h3 id="virtiodevice-trait"><a name="virtiodevice-trait" class="anchor-navigation-ex-anchor" href="#virtiodevice-trait"><i class="fa fa-link" aria-hidden="true"></i></a>7.5.3. VirtioDevice trait</h3>
<pre><code class="lang-rust">/// Trait for virtio devices to be driven by a virtio transport.
///
/// The lifecycle of a virtio device is to be moved to a virtio transport, which will then query the
/// device. The virtio devices needs to create queues, events and event fds for interrupts and expose
/// them to the transport via get_queues/get_queue_events/get_interrupt/get_interrupt_status fns.
pub trait VirtioDevice: AsAny + Send {
    /// Get the available features offered by device.
    fn avail_features(&amp;self) -&gt; u64;

    /// Get acknowledged features of the driver.
    fn acked_features(&amp;self) -&gt; u64;

    /// Set acknowledged features of the driver.
    /// This function must maintain the following invariant:
    /// - self.avail_features() &amp; self.acked_features() = self.get_acked_features()
    fn set_acked_features(&amp;mut self, acked_features: u64);

    fn has_feature(&amp;self, feature: u64) -&gt; bool {
        (self.acked_features() &amp; 1 &lt;&lt; feature) != 0
    }

    /// The virtio device type.
    fn device_type(&amp;self) -&gt; u32;

    /// Returns the device queues.
    fn queues(&amp;self) -&gt; &amp;[Queue];

    /// Returns a mutable reference to the device queues.
    fn queues_mut(&amp;mut self) -&gt; &amp;mut [Queue];

    /// Returns the device queues event fds.
    fn queue_events(&amp;self) -&gt; &amp;[EventFd];

    /// Returns the device interrupt eventfd.
    fn interrupt_evt(&amp;self) -&gt; &amp;EventFd;

    /// Returns the current device interrupt status.
    fn interrupt_status(&amp;self) -&gt; Arc&lt;AtomicUsize&gt;;

    /// The set of feature bits shifted by `page * 32`.
    fn avail_features_by_page(&amp;self, page: u32) -&gt; u32 {
        let avail_features = self.avail_features();
        match page {
            // Get the lower 32-bits of the features bitfield.
            0 =&gt; avail_features as u32,
            // Get the upper 32-bits of the features bitfield.
            1 =&gt; (avail_features &gt;&gt; 32) as u32,
            _ =&gt; {
                warn!(&quot;Received request for unknown features page.&quot;);
                0u32
            }
        }
    }

    /// Acknowledges that this set of features should be enabled.
    fn ack_features_by_page(&amp;mut self, page: u32, value: u32) {
        let mut v = match page {
            0 =&gt; u64::from(value),
            1 =&gt; u64::from(value) &lt;&lt; 32,
            _ =&gt; {
                warn!(&quot;Cannot acknowledge unknown features page: {}&quot;, page);
                0u64
            }
        };

        // Check if the guest is ACK&apos;ing a feature that we didn&apos;t claim to have.
        let avail_features = self.avail_features();
        let unrequested_features = v &amp; !avail_features;
        if unrequested_features != 0 {
            warn!(&quot;Received acknowledge request for unknown feature: {:x}&quot;, v);
            // Don&apos;t count these features as acked.
            v &amp;= !unrequested_features;
        }
        self.set_acked_features(self.acked_features() | v);
    }

    /// Reads this device configuration space at `offset`.
    fn read_config(&amp;self, offset: u64, data: &amp;mut [u8]);

    /// Writes to this device configuration space at `offset`.
    fn write_config(&amp;mut self, offset: u64, data: &amp;[u8]);

    /// Performs the formal activation for a device, which can be verified also with `is_activated`.
    fn activate(&amp;mut self, mem: GuestMemoryMmap) -&gt; ActivateResult;

    /// Checks if the resources of this device are activated.
    fn is_activated(&amp;self) -&gt; bool;

    /// Optionally deactivates this device and returns ownership of the guest memory map, interrupt
    /// event, and queue events.
    fn reset(&amp;mut self) -&gt; Option&lt;(EventFd, Vec&lt;EventFd&gt;)&gt; {
        None
    }
}
</code></pre>
<h2 id="virtio&#x8BBE;&#x5907;&#x6846;&#x56FE;"><a name="virtio&#x8BBE;&#x5907;&#x6846;&#x56FE;" class="anchor-navigation-ex-anchor" href="#virtio&#x8BBE;&#x5907;&#x6846;&#x56FE;"><i class="fa fa-link" aria-hidden="true"></i></a>7.6. VirtIO&#x8BBE;&#x5907;&#x6846;&#x56FE;</h2>
<p><img src="img/rust_firecracker_mmio_virtio.svg" alt="">  </p>
<h2 id="virtio-net"><a name="virtio-net" class="anchor-navigation-ex-anchor" href="#virtio-net"><i class="fa fa-link" aria-hidden="true"></i></a>7.7. virtIO net</h2>
<p>virtIO net&#x7684;&#x5B9A;&#x4E49;&#x5F88;&#x590D;&#x6742;</p>
<pre><code class="lang-rust">pub struct Net {
    pub(crate) id: String,

    pub tap: Tap, //&#x5BF9;&#x63A5;&#x7684;tap&#x8BBE;&#x5907;

    pub(crate) avail_features: u64,
    pub(crate) acked_features: u64,

    pub(crate) queues: Vec&lt;Queue&gt;,
    pub(crate) queue_evts: Vec&lt;EventFd&gt;,

    pub(crate) rx_rate_limiter: RateLimiter,
    pub(crate) tx_rate_limiter: RateLimiter,

    pub(crate) rx_deferred_frame: bool,
    rx_deferred_irqs: bool,

    rx_bytes_read: usize,
    rx_frame_buf: [u8; MAX_BUFFER_SIZE],

    tx_iovec: Vec&lt;(GuestAddress, usize)&gt;,
    tx_frame_buf: [u8; MAX_BUFFER_SIZE],

    pub(crate) irq_trigger: IrqTrigger, //&#x4E2D;&#x65AD;&#x89E6;&#x53D1;, &#x91CC;&#x9762;&#x662F;eventfd

    pub(crate) config_space: ConfigSpace,
    pub(crate) guest_mac: Option&lt;MacAddr&gt;,

    pub(crate) device_state: DeviceState,
    pub(crate) activate_evt: EventFd,

    pub mmds_ns: Option&lt;MmdsNetworkStack&gt;,

    #[cfg(test)]
    pub(crate) mocks: Mocks,
}
</code></pre>
<p>Net&#x5B9E;&#x73B0;&#x4E86;&#x5F88;&#x591A;&#x65B9;&#x6CD5;, &#x6BD4;&#x5982;&#x4EA4;&#x6362;tap&#x8BBE;&#x5907;&#x548C;queue&#x7684;&#x6570;&#x636E;:</p>
<pre><code class="lang-rust">impl Net {
    new_with_tap()
    id()
    guest_mac()
    iface_name()
    mmds_ns()
    signal_used_queue() {self.irq_trigger.trigger_irq()}
    signal_rx_used_queue()
    do_write_frame_to_guest(
    write_frame_to_guest()
    read_from_mmds_or_tap()
    //&#x5904;&#x7406;&#x4ECE;tap&#x8BBE;&#x5907;&#x6765;&#x7684;&#x6570;&#x636E;, &#x7136;&#x540E;&#x7ED9;guest&#x53D1;irq: 
    //self.signal_used_queue() -&gt; self.irq_trigger.trigger_irq(IrqType::Vring) &#x8FD8;&#x662F;&#x5199;eventfd
    process_rx() 
    handle_deferred_frame()
    resume_rx()
    process_tx()
    read_tap()
    process_rx_queue_event()
    process_tap_rx_event()
    process_tx_queue_event()
    process_virtio_queues()
}
</code></pre>
<h3 id="net&#x5B9E;&#x73B0;&#x4E86;virtiodevice"><a name="net&#x5B9E;&#x73B0;&#x4E86;virtiodevice" class="anchor-navigation-ex-anchor" href="#net&#x5B9E;&#x73B0;&#x4E86;virtiodevice"><i class="fa fa-link" aria-hidden="true"></i></a>7.7.1. Net&#x5B9E;&#x73B0;&#x4E86;VirtioDevice</h3>
<p>&#x76F8;&#x5BF9;&#x6BD4;&#x8F83;&#x8584;&#x7684;&#x4E00;&#x5C42;, &#x5B9E;&#x73B0;&#x4E86;&#x4E0B;&#x9762;&#x7684;&#x65B9;&#x6CD5;:<br><img src="img/rust_firecracker_&#x4EE3;&#x7801;_20220825230957.png" alt="">  </p>
<h3 id="net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;muteventsubscriber"><a name="net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;muteventsubscriber" class="anchor-navigation-ex-anchor" href="#net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;muteventsubscriber"><i class="fa fa-link" aria-hidden="true"></i></a>7.7.2. Net&#x8FD8;&#x5B9E;&#x73B0;&#x4E86;MutEventSubscriber</h3>
<pre><code class="lang-rust">impl MutEventSubscriber for Net {
    fn process(&amp;mut self, event: Events, ops: &amp;mut EventOps) {
        let source = event.fd();
        let event_set = event.event_set();

        // TODO: also check for errors. Pending high level discussions on how we want
        // to handle errors in devices.
        let supported_events = EventSet::IN;
        if !supported_events.contains(event_set) {
            warn!(
                &quot;Received unknown event: {:?} from source: {:?}&quot;,
                event_set, source
            );
            return;
        }

        if self.is_activated() {
            let virtq_rx_ev_fd = self.queue_evts[RX_INDEX].as_raw_fd();
            let virtq_tx_ev_fd = self.queue_evts[TX_INDEX].as_raw_fd();
            let rx_rate_limiter_fd = self.rx_rate_limiter.as_raw_fd();
            let tx_rate_limiter_fd = self.tx_rate_limiter.as_raw_fd();
            let tap_fd = self.tap.as_raw_fd();
            let activate_fd = self.activate_evt.as_raw_fd();

            // Looks better than C style if/else if/else.
            match source {
                _ if source == virtq_rx_ev_fd =&gt; self.process_rx_queue_event(),
                _ if source == tap_fd =&gt; self.process_tap_rx_event(), //tap&#x8BBE;&#x5907;&#x6765;&#x6570;&#x636E;&#x4E86;
                _ if source == virtq_tx_ev_fd =&gt; self.process_tx_queue_event(),
                _ if source == rx_rate_limiter_fd =&gt; self.process_rx_rate_limiter_event(),
                _ if source == tx_rate_limiter_fd =&gt; self.process_tx_rate_limiter_event(),
                _ if activate_fd == source =&gt; self.process_activate_event(ops),
                _ =&gt; {
                    warn!(&quot;Net: Spurious event received: {:?}&quot;, source);
                    METRICS.net.event_fails.inc();
                }
            }
        } else {
            warn!(
                &quot;Net: The device is not yet activated. Spurious event received: {:?}&quot;,
                source
            );
        }
    }

    fn init(&amp;mut self, ops: &amp;mut EventOps) {
        // This function can be called during different points in the device lifetime:
        //  - shortly after device creation,
        //  - on device activation (is-activated already true at this point),
        //  - on device restore from snapshot.
        if self.is_activated() {
            self.register_runtime_events(ops);
        } else {
            self.register_activate_event(ops);
        }
    }
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="rust_vmm_简介.html" class="navigation navigation-prev " aria-label="Previous page: rust-vmm简介">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="rust_firecracker_使用.html" class="navigation navigation-next " aria-label="Next page: firecracker使用">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"firecracker代码","level":"1.13.2.2","depth":3,"next":{"title":"firecracker使用","level":"1.13.2.3","depth":3,"path":"notes/rust_firecracker_使用.md","ref":"notes/rust_firecracker_使用.md","articles":[]},"previous":{"title":"rust-vmm简介","level":"1.13.2.1","depth":3,"path":"notes/rust_vmm_简介.md","ref":"notes/rust_vmm_简介.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","-lunr","-search","search-plus","-highlight","theme-code","expandable-chapters-small","github","disqus","splitter","wide-page","hide-navigation-buttons","anchor-navigation-ex","sequence"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"disqus":{"useIdentifier":false,"shortName":"bai-yingjie-notes"},"sequence":{"theme":"simple"},"github":{"url":"https://github.com/Bai-Yingjie/Bai-Yingjie.github.io"},"splitter":{},"wide-page":{},"theme-code":{"showLevel":false,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"}},"fontsettings":{"theme":"white","family":"sans","size":2},"hide-navigation-buttons":{},"anchor-navigation-ex":{"mode":"float","pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"isRewritePageTitle":true,"showLevel":true,"tocLevel1Icon":"fa fa-hand-o-right","tocLevel2Icon":"fa fa-hand-o-right","tocLevel3Icon":"fa fa-hand-o-right","showGoTop":true,"isShowTocTitleIcon":true,"printLog":false,"multipleH1":true,"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false}},"expandable-chapters-small":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"search-plus":{}},"theme":"default","author":"Bai Yingjie","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"My Notes","language":"zh-hans","gitbook":"*"},"file":{"path":"notes/rust_firecracker_代码.md","mtime":"2022-10-11T15:10:43.010Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-10-11T15:11:40.551Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>


        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

        
    </body>
</html>

