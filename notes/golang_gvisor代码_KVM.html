
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>gvisor KVM模式代码 · My Notes</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Bai Yingjie">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-hide-navigation-buttons/index.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="golang_gvisor调试.html" />
    
    
    <link rel="prev" href="as_title.html" />
    

    </head>
    <body>
        


<div class="book">
    <div class="book-summary">
        
            <div class="theme-code-header">
                <a href="" class="link">
                    <h1 class="title">My Notes</h1>
                </a>
            </div>
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    开源
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="my_opensource.html">
            
                <a href="my_opensource.html">
            
                    
                    我的开源项目
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="my_upstream.html">
            
                <a href="my_upstream.html">
            
                    
                    我的upstream commit
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    系统分析和性能
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="system_analysis_bcc和ebpf.html">
            
                <a href="system_analysis_bcc和ebpf.html">
            
                    
                    bcc和ebpf(starting)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="performance_ovs进程调查.html">
            
                <a href="performance_ovs进程调查.html">
            
                    
                    OVS进程调查
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="performance_ping流程和函数调用解析.html">
            
                <a href="performance_ping流程和函数调用解析.html">
            
                    
                    ping流程和函数调用解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="CentOS_系统性能优化配置.html">
            
                <a href="CentOS_系统性能优化配置.html">
            
                    
                    CentOS 性能优化系统配置
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    ARM server
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="arm_server_杂记.html">
            
                <a href="arm_server_杂记.html">
            
                    
                    Arm server 杂记
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    嵌入式系统开发调试
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="embedded_debugging.html">
            
                <a href="embedded_debugging.html">
            
                    
                    嵌入式调试杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="uboot_杂记.html">
            
                <a href="uboot_杂记.html">
            
                    
                    uboot杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="buildroot_杂记.html">
            
                <a href="buildroot_杂记.html">
            
                    
                    buildroot杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="toolchain_升级gcc问题解决.html">
            
                <a href="toolchain_升级gcc问题解决.html">
            
                    
                    升级GCC7.3问题解决
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Linux工程实践
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="linux_日常使用.html">
            
                <a href="linux_日常使用.html">
            
                    
                    日常linux使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="git_日常使用.html">
            
                <a href="git_日常使用.html">
            
                    
                    日常git使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="向kernel提交补丁.html">
            
                <a href="向kernel提交补丁.html">
            
                    
                    向kernel提交补丁
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="linux_ssh_relay.html">
            
                <a href="linux_ssh_relay.html">
            
                    
                    ssh relay
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="gitlab_ci.html">
            
                <a href="gitlab_ci.html">
            
                    
                    gitlab CI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="docker_操作记录.html">
            
                <a href="docker_操作记录.html">
            
                    
                    docker操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="centos_操作记录.html">
            
                <a href="centos_操作记录.html">
            
                    
                    centos操作记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Golang
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    入门
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1.1" data-path="golang_语法基础.html">
            
                <a href="golang_语法基础.html">
            
                    
                    Golang 语法基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.1.2" data-path="golang_json性能.html">
            
                <a href="golang_json性能.html">
            
                    
                    Golang json性能比较
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="golang_原理.html">
            
                <a href="golang_原理.html">
            
                    
                    Golang 原理相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.2.1" data-path="golang_interface原理.html">
            
                <a href="golang_interface原理.html">
            
                    
                    Golang interface原理(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2.2" data-path="golang_内存分配.html">
            
                <a href="golang_内存分配.html">
            
                    
                    Golang 内存分配(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="golang_标准库.html">
            
                <a href="golang_标准库.html">
            
                    
                    Golang 标准库
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="golang_我的反射代码.html">
            
                <a href="golang_我的反射代码.html">
            
                    
                    Golang 我的反射代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="golang_问答.html">
            
                <a href="golang_问答.html">
            
                    
                    Golang 问答
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="golang_高效go.html">
            
                <a href="golang_高效go.html">
            
                    
                    Golang 高效go
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="golang_进阶.html">
            
                <a href="golang_进阶.html">
            
                    
                    Golang 进阶
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Golang 杂记
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.8.1" data-path="golang_杂记1.html">
            
                <a href="golang_杂记1.html">
            
                    
                    Golang 杂记1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.2" data-path="golang_杂记2.html">
            
                <a href="golang_杂记2.html">
            
                    
                    Golang 杂记2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.3" data-path="golang_杂记3.html">
            
                <a href="golang_杂记3.html">
            
                    
                    Golang 杂记3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.4" data-path="golang_lib选型.html">
            
                <a href="golang_lib选型.html">
            
                    
                    Golang lib选型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.5" data-path="golang_mod_proxy.html">
            
                <a href="golang_mod_proxy.html">
            
                    
                    go mod和go proxy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.6" data-path="golang_汇编_arm64.html">
            
                <a href="golang_汇编_arm64.html">
            
                    
                    Golang 汇编语法和arm64小知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8.7" data-path="golang_cgo_swig.html">
            
                <a href="golang_cgo_swig.html">
            
                    
                    go调用c可以用swig
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.9" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Golang 环境和工具链生成
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.9.1" data-path="golang_toolchain_ppc.html">
            
                <a href="golang_toolchain_ppc.html">
            
                    
                    go tools增加ppc32支持.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.2" data-path="golang_toolchain_compile_gccgo.html">
            
                <a href="golang_toolchain_compile_gccgo.html">
            
                    
                    编译gccgo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3" data-path="golang_go_on_mips.html">
            
                <a href="golang_go_on_mips.html">
            
                    
                    go on mips boards(not so updated)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.9.3.1" data-path="golang_go_on_mips_part1.html">
            
                <a href="golang_go_on_mips_part1.html">
            
                    
                    part 1: cross compile go
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.2" data-path="golang_go_on_mips_part2.html">
            
                <a href="golang_go_on_mips_part2.html">
            
                    
                    part 2: build native go compiler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.3" data-path="golang_go_on_mips_part3.html">
            
                <a href="golang_go_on_mips_part3.html">
            
                    
                    part 3: gccgo experiments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.4" data-path="golang_go_on_mips_part4.html">
            
                <a href="golang_go_on_mips_part4.html">
            
                    
                    part 4: Golang json performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9.3.5" data-path="golang_gentoo_on_mips_board_and_build_go.html">
            
                <a href="golang_gentoo_on_mips_board_and_build_go.html">
            
                    
                    Gentoo on mips board and build go
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.10" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    微服务
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.10.1" data-path="golang_micro.html">
            
                <a href="golang_micro.html">
            
                    
                    go-micro和micro
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.10.2" data-path="golang_微服务概念.html">
            
                <a href="golang_微服务概念.html">
            
                    
                    微服务概念
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.11" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    解释器和编解码
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.11.1" data-path="golang_yeagi.html">
            
                <a href="golang_yeagi.html">
            
                    
                    解释器yeagi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.2" data-path="golang_tengo.html">
            
                <a href="golang_tengo.html">
            
                    
                    解释器tengo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.3" data-path="golang_govaluate.html">
            
                <a href="golang_govaluate.html">
            
                    
                    解释器govaluate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.4" data-path="golang_encoding_gotiny.html">
            
                <a href="golang_encoding_gotiny.html">
            
                    
                    gotiny编解码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11.5" data-path="golang_abs.html">
            
                <a href="golang_abs.html">
            
                    
                    解释器abs
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.12" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    调试和性能
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.12.1" data-path="golang_调试记录.html">
            
                <a href="golang_调试记录.html">
            
                    
                    Golang 调试记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.12.2" data-path="golang_topid性能优化.html">
            
                <a href="golang_topid性能优化.html">
            
                    
                    Golang topid性能优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.12.3" data-path="golang_gshell性能调试.html">
            
                <a href="golang_gshell性能调试.html">
            
                    
                    Golang gshell性能调试
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.13" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    网络和消息中间件
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.13.1" data-path="golang_zmq.html">
            
                <a href="golang_zmq.html">
            
                    
                    消息中间件基本概念和zero mq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.13.2" data-path="golang_mango.html">
            
                <a href="golang_mango.html">
            
                    
                    消息中间件mango
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.13.3" data-path="golang_libp2p.html">
            
                <a href="golang_libp2p.html">
            
                    
                    Golang p2p网络
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Rust
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="rust_入门_brief.html">
            
                <a href="rust_入门_brief.html">
            
                    
                    Rust 入门系列
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1.1" data-path="rust_books.html">
            
                <a href="rust_books.html">
            
                    
                    Rust reference books
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.2" data-path="rust_入门1.html">
            
                <a href="rust_入门1.html">
            
                    
                    Rust 安装和基础语法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.3" data-path="rust_入门2.html">
            
                <a href="rust_入门2.html">
            
                    
                    Rust 泛型和内存所有权
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.4" data-path="rust_入门3.html">
            
                <a href="rust_入门3.html">
            
                    
                    Rust 闭包 容器 迭代器 生成器 线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.5" data-path="rust_工程构建.html">
            
                <a href="rust_工程构建.html">
            
                    
                    Rust 工程构建
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="rust_coding_brief.html">
            
                <a href="rust_coding_brief.html">
            
                    
                    Rust 代码积累
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.2.1" data-path="rust_序列化.html">
            
                <a href="rust_序列化.html">
            
                    
                    Rust 序列化原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.2" data-path="rust_知识点积累.html">
            
                <a href="rust_知识点积累.html">
            
                    
                    Rust 知识点更新
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.3" data-path="rust_adaptiveservice.html">
            
                <a href="rust_adaptiveservice.html">
            
                    
                    rust版本的adaptiveservice探索
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.4" data-path="rust_常用设施.html">
            
                <a href="rust_常用设施.html">
            
                    
                    Rust 常用设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.5" data-path="rust_代码小段.html">
            
                <a href="rust_代码小段.html">
            
                    
                    Rust 代码小段
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="others.html">
            
                <a href="others.html">
            
                    
                    其他
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.3.1" data-path="rust_mdbook_使用.html">
            
                <a href="rust_mdbook_使用.html">
            
                    
                    Rust 使用mdbook
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    C开发
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="c_automake_autoconf.html">
            
                <a href="c_automake_autoconf.html">
            
                    
                    automake autoconf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="makefile_原理和实践.html">
            
                <a href="makefile_原理和实践.html">
            
                    
                    makefile
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="c_编程杂记高级篇.html">
            
                <a href="c_编程杂记高级篇.html">
            
                    
                    C编程杂记高级篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="c_编程杂记基础篇.html">
            
                <a href="c_编程杂记基础篇.html">
            
                    
                    C编程杂记基础篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="c_networking_socket高阶用法.html">
            
                <a href="c_networking_socket高阶用法.html">
            
                    
                    网络编程: Advanced Socket Topics(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="c_protobuf介绍.html">
            
                <a href="c_protobuf介绍.html">
            
                    
                    序列化: protobuf介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="c_进程间通信_共享文件和共享内存.html">
            
                <a href="c_进程间通信_共享文件和共享内存.html">
            
                    
                    进程间通信: 共享文件和共享内存(网摘)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="c_pthread_condition和mutex.html">
            
                <a href="c_pthread_condition和mutex.html">
            
                    
                    并发 任务 事件 和锁.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="kernel_user_space_howto.html">
            
                <a href="kernel_user_space_howto.html">
            
                    
                    kernel space和user space交互(网摘, linux2.6)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    脚本
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="shell_变量.html">
            
                <a href="shell_变量.html">
            
                    
                    shell变量
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="shell_基础篇.html">
            
                <a href="shell_基础篇.html">
            
                    
                    shell命令和脚本记录-基础篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="shell_高级篇.html">
            
                <a href="shell_高级篇.html">
            
                    
                    shell命令和脚本记录-高级篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="shell_脚本片段.html">
            
                <a href="shell_脚本片段.html">
            
                    
                    shell脚本片段
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="python_记录.html">
            
                <a href="python_记录.html">
            
                    
                    python记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="lua_记录.html">
            
                <a href="lua_记录.html">
            
                    
                    lua记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="shell_rds脚本阅读.html">
            
                <a href="shell_rds脚本阅读.html">
            
                    
                    RDS脚本阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="Project_Euler.html">
            
                <a href="Project_Euler.html">
            
                    
                    Project Euler
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    cloud和容器相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="cloud_杂记.html">
            
                <a href="cloud_杂记.html">
            
                    
                    云杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="container_当代容器读书笔记.html">
            
                <a href="container_当代容器读书笔记.html">
            
                    
                    当代容器读书笔记
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Operating System
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="system_libc_part1.html">
            
                <a href="system_libc_part1.html">
            
                    
                    libc概览1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="system_libc_part2.html">
            
                <a href="system_libc_part2.html">
            
                    
                    libc概览2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="system_libc_part3.html">
            
                <a href="system_libc_part3.html">
            
                    
                    libc概览3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="system_原理杂记.html">
            
                <a href="system_原理杂记.html">
            
                    
                    系统原理杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="system_alpine.html">
            
                <a href="system_alpine.html">
            
                    
                    Alpine Linux
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="system_进程间通信.html">
            
                <a href="system_进程间通信.html">
            
                    
                    进程间通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="system_特殊功能fd.html">
            
                <a href="system_特殊功能fd.html">
            
                    
                    eventfd timerfd signalfd和fd共享
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    CPU和device虚拟化
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    gvisor
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.13.1.1" data-path="golang_gvisor代码_KVM.html">
            
                <a href="golang_gvisor代码_KVM.html">
            
                    
                    gvisor KVM模式代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.1.2" data-path="golang_gvisor调试.html">
            
                <a href="golang_gvisor调试.html">
            
                    
                    gvisor调试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.1.3" data-path="golang_gvisor_ptrace.html">
            
                <a href="golang_gvisor_ptrace.html">
            
                    
                    gvisor ptrace模式介绍(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="rust_vmm_brief.html">
            
                <a href="rust_vmm_brief.html">
            
                    
                    rust VMM(virtual machine monitor)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.2.1" data-path="rust_vmm_简介.html">
            
                <a href="rust_vmm_简介.html">
            
                    
                    rust-vmm简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.2" data-path="rust_firecracker_代码.html">
            
                <a href="rust_firecracker_代码.html">
            
                    
                    firecracker代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.3" data-path="rust_firecracker_使用.html">
            
                <a href="rust_firecracker_使用.html">
            
                    
                    firecracker使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.4" data-path="rust_cloud-hypervisor_代码.html">
            
                <a href="rust_cloud-hypervisor_代码.html">
            
                    
                    cloud hypervisor代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.5" data-path="rust_cloud-hypervisor_使用.html">
            
                <a href="rust_cloud-hypervisor_使用.html">
            
                    
                    cloud hypervisor使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2.6" data-path="rust_cloud-hypervisor_问题与解决.html">
            
                <a href="rust_cloud-hypervisor_问题与解决.html">
            
                    
                    cloud hypervisor问题与解决
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="virtualization_virtio规范阅读笔记.html">
            
                <a href="virtualization_virtio规范阅读笔记.html">
            
                    
                    virtio规范阅读笔记.md
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" data-path="qemu_ovs_虚拟化环境.html">
            
                <a href="qemu_ovs_虚拟化环境.html">
            
                    
                    qemu OVS 虚拟化环境准备
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" data-path="qemu使用.html">
            
                <a href="qemu使用.html">
            
                    
                    Qemu使用(old)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    计算机网络相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="networking_杂记1.html">
            
                <a href="networking_杂记1.html">
            
                    
                    networking杂记1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    Qemu OVS和DPDK
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.2.1" data-path="OVS_DPDK_编译运行.html">
            
                <a href="OVS_DPDK_编译运行.html">
            
                    
                    OVS-DPDK编译运行
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.2" data-path="OVS_架构和代码.html">
            
                <a href="OVS_架构和代码.html">
            
                    
                    OVS架构和代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.3" data-path="OVS_DPDK_performance_HXT_ARM_server.html">
            
                <a href="OVS_DPDK_performance_HXT_ARM_server.html">
            
                    
                    OVS-DPDK for ARM server 性能测试环境
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.4" data-path="DPDK_Mellanox.html">
            
                <a href="DPDK_Mellanox.html">
            
                    
                    DPDK Mellanox
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.5" data-path="OVS_phy-vm-phy.html">
            
                <a href="OVS_phy-vm-phy.html">
            
                    
                    OVS PHY-VM-PHY
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.6" data-path="networking_网络虚拟化用例记录.html">
            
                <a href="networking_网络虚拟化用例记录.html">
            
                    
                    网络虚拟化用例记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2.7" data-path="networking_网络虚拟化操作记录.html">
            
                <a href="networking_网络虚拟化操作记录.html">
            
                    
                    网络虚拟化操作记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    虚拟化网络
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.3.1" data-path="networking_tc_filter_连接veth和tap.html">
            
                <a href="networking_tc_filter_连接veth和tap.html">
            
                    
                    Connecting a veth device to tap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.2" data-path="networking_multicast_vxlan_flannel.html">
            
                <a href="networking_multicast_vxlan_flannel.html">
            
                    
                    multicast vxlan和flannel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.3" data-path="networking_virtio网络介绍.html">
            
                <a href="networking_virtio网络介绍.html">
            
                    
                    virtio网络介绍(网摘): vhost-net virtio-net vhost-user SRIOV
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.4" data-path="networking_virtualization_杂记.html">
            
                <a href="networking_virtualization_杂记.html">
            
                    
                    虚拟化网络杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3.5" data-path="networking_linux虚拟网络接口.html">
            
                <a href="networking_linux虚拟网络接口.html">
            
                    
                    linux虚拟网络接口(网摘)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    内核 设备和驱动相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="driver_驱动中使用工作队列轮询.html">
            
                <a href="driver_驱动中使用工作队列轮询.html">
            
                    
                    驱动中使用工作队列轮询
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="device_driver_杂记.html">
            
                <a href="device_driver_杂记.html">
            
                    
                    驱动调试杂记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="device_driver_原理相关.html">
            
                <a href="device_driver_原理相关.html">
            
                    
                    kernel和驱动原理相关
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="device_localbus_16bit读写.html">
            
                <a href="device_localbus_16bit读写.html">
            
                    
                    CPLD做8bit到16bit转换
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    nand
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.5.1" data-path="device_driver_octeon_nand.html">
            
                <a href="device_driver_octeon_nand.html">
            
                    
                    octeon nand flash驱动
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5.2" data-path="device_driver_nand概率写失败问题分析.html">
            
                <a href="device_driver_nand概率写失败问题分析.html">
            
                    
                    Nand flash概率写失败问题分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15.6" data-path="octeon_remote_pci.html">
            
                <a href="octeon_remote_pci.html">
            
                    
                    octeon remote-pci.c阅读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.7" data-path="Device_VFIO_notes.html">
            
                <a href="Device_VFIO_notes.html">
            
                    
                    VFIO简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    智能网卡和DPDK
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.8.1" data-path="smartNIC_智能网卡对比.html">
            
                <a href="smartNIC_智能网卡对比.html">
            
                    
                    智能网卡对比
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.2" data-path="octeon_pci_NIC.html">
            
                <a href="octeon_pci_NIC.html">
            
                    
                    octeon PCI NIC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    octeon liquidIO
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.8.3.1" data-path="smartNIC_liquidIO_代码阅读app篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读app篇.html">
            
                    
                    PCI-NIC 代码阅读 --app篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.2" data-path="smartNIC_liquidIO_代码阅读api篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读api篇.html">
            
                    
                    PCI-NIC 代码阅读 --api篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.3" data-path="smartNIC_liquidIO_代码阅读driver篇之结构体.html">
            
                <a href="smartNIC_liquidIO_代码阅读driver篇之结构体.html">
            
                    
                    PCI-NIC 代码阅读 --driver篇之结构体
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.4" data-path="smartNIC_liquidIO_代码阅读driver篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读driver篇.html">
            
                    
                    PCI-NIC 代码阅读 --driver篇
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8.3.5" data-path="smartNIC_liquidIO_代码阅读真NIC篇.html">
            
                <a href="smartNIC_liquidIO_代码阅读真NIC篇.html">
            
                    
                    PCI-NIC 代码阅读 --真NIC篇
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15.8.4" data-path="networking_dpdk使用_2014.html">
            
                <a href="networking_dpdk使用_2014.html">
            
                    
                    DPDK使用(2014)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15.9" data-path="device_nvme要点介绍.html">
            
                <a href="device_nvme要点介绍.html">
            
                    
                    nvme要点介绍
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    CPU Arch相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    ARM64
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1.1" data-path="CPU_ARM64_thunder_overview.html">
            
                <a href="CPU_ARM64_thunder_overview.html">
            
                    
                    thunder 概览
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.2" data-path="CPU_ARM64_thunder_开发板操作记录.html">
            
                <a href="CPU_ARM64_thunder_开发板操作记录.html">
            
                    
                    thunder 开发板操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.3" data-path="CPU_ARM64_thunder_bdk.html">
            
                <a href="CPU_ARM64_thunder_bdk.html">
            
                    
                    thunder BDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.4" data-path="CPU_ARM64_thunder_efi_rtc.html">
            
                <a href="CPU_ARM64_thunder_efi_rtc.html">
            
                    
                    thunder RTC时间和efi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.5" data-path="CPU_ARM64_thunder_uefi_fdt.html">
            
                <a href="CPU_ARM64_thunder_uefi_fdt.html">
            
                    
                    thunder uefi和fdt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.6" data-path="CPU_ARM64_thunder_atf.html">
            
                <a href="CPU_ARM64_thunder_atf.html">
            
                    
                    thunder atf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.1.7" data-path="CPU_ARM64_thunder_kernel_boot.html">
            
                <a href="CPU_ARM64_thunder_kernel_boot.html">
            
                    
                    thunder kernel启动打印流程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    PPC
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.2.1" data-path="CPU_PPC启动多核Linux_流程和内存映射.html">
            
                <a href="CPU_PPC启动多核Linux_流程和内存映射.html">
            
                    
                    PPC启动多核linux: 流程和内存映射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2.2" data-path="CPU_PPC_kernel升级记录.html">
            
                <a href="CPU_PPC_kernel升级记录.html">
            
                    
                    PPC kernel升级记录
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16.3" data-path="as_title.html">
            
                <a href="as_title.html">
            
                    
                    MIPS
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.3.1" data-path="CPU_MIPS_octeon地址空间和寄存器访问.html">
            
                <a href="CPU_MIPS_octeon地址空间和寄存器访问.html">
            
                    
                    octeon 地址空间和寄存器访问
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.2" data-path="CPU_MIPS_octeon操作记录.html">
            
                <a href="CPU_MIPS_octeon操作记录.html">
            
                    
                    octeon 操作记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.3" data-path="CPU_MIPS_octeon_包处理性能.html">
            
                <a href="CPU_MIPS_octeon_包处理性能.html">
            
                    
                    octeon 系列处理器包处理性能
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.4" data-path="CPU_MIPS_octeon_ddr调试记录.html">
            
                <a href="CPU_MIPS_octeon_ddr调试记录.html">
            
                    
                    octeon DDR调试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.5" data-path="CPU_MIPS_octeon_BDK.html">
            
                <a href="CPU_MIPS_octeon_BDK.html">
            
                    
                    octeon CN78xx BDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.6" data-path="kernel_增加ECC中断.html">
            
                <a href="kernel_增加ECC中断.html">
            
                    
                    octeon 增加ECC中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.7" data-path="CPU_MIPS_octeon_hw-ddr2代码走读.html">
            
                <a href="CPU_MIPS_octeon_hw-ddr2代码走读.html">
            
                    
                    octeon hw-ddr2代码走读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.8" data-path="CPU_MIPS_octeon_reboot调试和ddr中断.html">
            
                <a href="CPU_MIPS_octeon_reboot调试和ddr中断.html">
            
                    
                    octeon reboot调试和DDR中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.9" data-path="CPU_MIPS_octeon中断.html">
            
                <a href="CPU_MIPS_octeon中断.html">
            
                    
                    octeon 中断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.10" data-path="CPU_MIPS_octeon原子操作.html">
            
                <a href="CPU_MIPS_octeon原子操作.html">
            
                    
                    octeon 原子操作
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3.11" data-path="CPU_MIPS_octeon网口代码分析.html">
            
                <a href="CPU_MIPS_octeon网口代码分析.html">
            
                    
                    octeon 网口代码分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="" target="_blank" class="gitbook-link">
            Author: Bai Yingjie
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >gvisor KVM模式代码</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;"><b>1. </b>gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;:</a></li><ul><li><span class="title-icon "></span><a href="#host-mode&#x548C;guest-mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;"><b>1.1. </b>host mode&#x548C;guest mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;</a></li><li><span class="title-icon "></span><a href="#go-&#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;"><b>1.2. </b>go &#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;</a></li><ul><li><span class="title-icon "></span><a href="#arm64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;"><b>1.2.1. </b>ARM64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;</a></li><li><span class="title-icon "></span><a href="#arm64&#x5F02;&#x5E38;&#x5904;&#x7406;"><b>1.2.2. </b>ARM64&#x5F02;&#x5E38;&#x5904;&#x7406;</a></li><li><span class="title-icon "></span><a href="#arm64&#x5BC4;&#x5B58;&#x5668;"><b>1.2.3. </b>ARM64&#x5BC4;&#x5B58;&#x5668;</a></li></ul></ul><li><span class="title-icon "></span><a href="#gvisor&#x4ECB;&#x7ECD;"><b>2. </b>gvisor&#x4ECB;&#x7ECD;</a></li><ul><li><span class="title-icon "></span><a href="#&#x539F;&#x7406;&#x7B80;&#x4ECB;"><b>2.1. </b>&#x539F;&#x7406;&#x7B80;&#x4ECB;</a></li></ul><li><span class="title-icon "></span><a href="#&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;"><b>3. </b>&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;</a></li><li><span class="title-icon "></span><a href="#&#x4EE3;&#x7801;&#x7ED3;&#x6784;"><b>4. </b>&#x4EE3;&#x7801;&#x7ED3;&#x6784;</a></li><ul><li><span class="title-icon "></span><a href="#abi"><b>4.1. </b>abi</a></li><li><span class="title-icon "></span><a href="#sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;"><b>4.2. </b>sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;</a></li><ul><li><span class="title-icon "></span><a href="#&#x4F20;&#x7EDF;mm"><b>4.2.1. </b>&#x4F20;&#x7EDF;mm</a></li><li><span class="title-icon "></span><a href="#&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page-fault"><b>4.2.2. </b>&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page fault</a></li><li><span class="title-icon "></span><a href="#sentry&#x7684;mm"><b>4.2.3. </b>sentry&#x7684;mm</a></li><li><span class="title-icon "></span><a href="#&#x6027;&#x80FD;&#x5BF9;&#x6BD4;"><b>4.2.4. </b>&#x6027;&#x80FD;&#x5BF9;&#x6BD4;</a></li></ul><li><span class="title-icon "></span><a href="#netstask"><b>4.3. </b>netstask</a></li><li><span class="title-icon "></span><a href="#pkgabilinux"><b>4.4. </b>pkg/abi/linux</a></li><ul><li><span class="title-icon "></span><a href="#pkgabilinuxseccompgo"><b>4.4.1. </b>pkg/abi/linux/seccomp.go</a></li></ul><li><span class="title-icon "></span><a href="#pkghostarchhostarchgo"><b>4.5. </b>pkg/hostarch/hostarch.go</a></li><li><span class="title-icon "></span><a href="#pkgseccompseccompgo"><b>4.6. </b>pkg/seccomp/seccomp.go</a></li><li><span class="title-icon "></span><a href="#pkgsentryarcharchgo"><b>4.7. </b>pkg/sentry/arch/arch.go</a></li><li><span class="title-icon "></span><a href="#kernel"><b>4.8. </b>kernel</a></li><ul><li><span class="title-icon "></span><a href="#task&#x7684;&#x72B6;&#x6001;&#x673A;"><b>4.8.1. </b>task&#x7684;&#x72B6;&#x6001;&#x673A;</a></li></ul><li><span class="title-icon "></span><a href="#runsc-boot&#x6D41;&#x7A0B;"><b>4.9. </b>runsc boot&#x6D41;&#x7A0B;</a></li><li><span class="title-icon "></span><a href="#platform"><b>4.10. </b>platform</a></li><li><span class="title-icon "></span><a href="#&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;switch"><b>4.11. </b>&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;Switch()</a></li><li><span class="title-icon "></span><a href="#ptrace"><b>4.12. </b>ptrace</a></li><ul><li><span class="title-icon "></span><a href="#threadsetregs"><b>4.12.1. </b>thread.setRegs</a></li><li><span class="title-icon "></span><a href="#&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;"><b>4.12.2. </b>&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;</a></li><li><span class="title-icon "></span><a href="#ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;"><b>4.12.3. </b>ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;</a></li><li><span class="title-icon "></span><a href="#ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;"><b>4.12.4. </b>ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;?</a></li></ul><li><span class="title-icon "></span><a href="#kvm"><b>4.13. </b>kvm</a></li><ul><li><span class="title-icon "></span><a href="#golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;"><b>4.13.1. </b>golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;</a></li><li><span class="title-icon "></span><a href="#arm64-exception-level"><b>4.13.2. </b>arm64 exception level</a></li><li><span class="title-icon "></span><a href="#arm64&#x5185;&#x5B58;&#x57FA;&#x7840;"><b>4.13.3. </b>arm64&#x5185;&#x5B58;&#x57FA;&#x7840;</a></li><li><span class="title-icon "></span><a href="#kvm&#x57FA;&#x7840;"><b>4.13.4. </b>KVM&#x57FA;&#x7840;</a></li><li><span class="title-icon "></span><a href="#pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;"><b>4.13.5. </b>pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;</a></li><li><span class="title-icon "></span><a href="#kvm&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;vm"><b>4.13.6. </b>KVM&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;VM</a></li><li><span class="title-icon "></span><a href="#arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;"><b>4.13.7. </b>arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;</a></li><li><span class="title-icon "></span><a href="#kvmcreatevcpu"><b>4.13.8. </b>KVM_CREATE_VCPU</a></li><li><span class="title-icon "></span><a href="#kvmarmvcpuinit"><b>4.13.9. </b>KVM_ARM_VCPU_INIT</a></li><li><span class="title-icon "></span><a href="#kvm&#x7684;context&#x5B9E;&#x73B0;"><b>4.13.10. </b>KVM&#x7684;context&#x5B9E;&#x73B0;</a></li></ul></ul></ul></div><a href="#gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><ul>
<li><a href="#gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;">gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;:</a><ul>
<li><a href="#host-mode&#x548C;guest-mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;">host mode&#x548C;guest mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;</a></li>
<li><a href="#go-&#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;">go &#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;</a><ul>
<li><a href="#arm64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;">ARM64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;</a></li>
<li><a href="#arm64&#x5F02;&#x5E38;&#x5904;&#x7406;">ARM64&#x5F02;&#x5E38;&#x5904;&#x7406;</a></li>
<li><a href="#arm64&#x5BC4;&#x5B58;&#x5668;">ARM64&#x5BC4;&#x5B58;&#x5668;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#gvisor&#x4ECB;&#x7ECD;">gvisor&#x4ECB;&#x7ECD;</a><ul>
<li><a href="#&#x539F;&#x7406;&#x7B80;&#x4ECB;">&#x539F;&#x7406;&#x7B80;&#x4ECB;</a></li>
</ul>
</li>
<li><a href="#&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;">&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;</a></li>
<li><a href="#&#x4EE3;&#x7801;&#x7ED3;&#x6784;">&#x4EE3;&#x7801;&#x7ED3;&#x6784;</a><ul>
<li><a href="#abi">abi</a></li>
<li><a href="#sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;">sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;</a><ul>
<li><a href="#&#x4F20;&#x7EDF;mm">&#x4F20;&#x7EDF;mm</a><ul>
<li><a href="#shared-map">shared map</a></li>
<li><a href="#private-map">private map</a></li>
<li><a href="#&#x533F;&#x540D;&#x6620;&#x5C04;">&#x533F;&#x540D;&#x6620;&#x5C04;</a></li>
</ul>
</li>
<li><a href="#&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page-fault">&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page fault</a><ul>
<li><a href="#signal&#x65B9;&#x5F0F;">signal&#x65B9;&#x5F0F;</a></li>
<li><a href="#userfaultfd&#x65B9;&#x5F0F;&#x7528;&#x6237;&#x6001;page&#x7BA1;&#x7406;">userfaultfd&#x65B9;&#x5F0F;&#x7528;&#x6237;&#x6001;page&#x7BA1;&#x7406;</a></li>
</ul>
</li>
<li><a href="#sentry&#x7684;mm">sentry&#x7684;mm</a></li>
<li><a href="#&#x6027;&#x80FD;&#x5BF9;&#x6BD4;">&#x6027;&#x80FD;&#x5BF9;&#x6BD4;</a></li>
</ul>
</li>
<li><a href="#netstask">netstask</a></li>
<li><a href="#pkgabilinux">pkg/abi/linux</a><ul>
<li><a href="#pkgabilinuxseccompgo">pkg/abi/linux/seccomp.go</a></li>
</ul>
</li>
<li><a href="#pkghostarchhostarchgo">pkg/hostarch/hostarch.go</a></li>
<li><a href="#pkgseccompseccompgo">pkg/seccomp/seccomp.go</a></li>
<li><a href="#pkgsentryarcharchgo">pkg/sentry/arch/arch.go</a></li>
<li><a href="#kernel">kernel</a><ul>
<li><a href="#task&#x7684;&#x72B6;&#x6001;&#x673A;">task&#x7684;&#x72B6;&#x6001;&#x673A;</a></li>
</ul>
</li>
<li><a href="#runsc-boot&#x6D41;&#x7A0B;">runsc boot&#x6D41;&#x7A0B;</a></li>
<li><a href="#platform">platform</a></li>
<li><a href="#&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;switch">&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;Switch()</a></li>
<li><a href="#ptrace">ptrace</a><ul>
<li><a href="#threadsetregs">thread.setRegs</a></li>
<li><a href="#&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;">&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;</a></li>
<li><a href="#ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;">ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;</a></li>
<li><a href="#ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;">ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;?</a></li>
</ul>
</li>
<li><a href="#kvm">kvm</a><ul>
<li><a href="#golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;">golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;</a></li>
<li><a href="#arm64-exception-level">arm64 exception level</a></li>
<li><a href="#arm64&#x5185;&#x5B58;&#x57FA;&#x7840;">arm64&#x5185;&#x5B58;&#x57FA;&#x7840;</a><ul>
<li><a href="#vm&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;">VM&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;</a></li>
</ul>
</li>
<li><a href="#kvm&#x57FA;&#x7840;">KVM&#x57FA;&#x7840;</a><ul>
<li><a href="#gvisor&#x5BF9;cpu&#x548C;ring0kernel&#x7684;&#x62BD;&#x8C61;">gvisor&#x5BF9;CPU&#x548C;ring0.kernel&#x7684;&#x62BD;&#x8C61;</a></li>
<li><a href="#machine&#x548C;vcpu&#x7684;&#x5B9A;&#x4E49;">machine&#x548C;vCPU&#x7684;&#x5B9A;&#x4E49;</a></li>
</ul>
</li>
<li><a href="#pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;">pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;</a><ul>
<li><a href="#kvm_set_user_memory_region">KVM_SET_USER_MEMORY_REGION</a></li>
<li><a href="#mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;&#x7528;&#x6237;&#x6001;page-falut&#x5904;&#x7406;&#x8DEF;&#x5F84;">mapPhysical()&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;&#x7528;&#x6237;&#x6001;page falut&#x5904;&#x7406;&#x8DEF;&#x5F84;</a></li>
<li><a href="#mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;seccompmmaphandler">mapPhysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;seccompMmapHandler</a></li>
<li><a href="#mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;newmachine">mapPhysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;newMachine</a></li>
</ul>
</li>
<li><a href="#kvm&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;vm">KVM&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;VM</a><ul>
<li><a href="#newmachine">newMachine</a></li>
</ul>
</li>
<li><a href="#arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;">arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;</a><ul>
<li><a href="#el0&#x540C;&#x6B65;&#x5F02;&#x5E38;">EL0&#x540C;&#x6B65;&#x5F02;&#x5E38;</a></li>
<li><a href="#el0&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x4E4B;svc&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5F02;&#x5E38;">EL0&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x4E4B;SVC&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5F02;&#x5E38;</a></li>
<li><a href="#kernelexittoel1">kernelExitToEl1</a></li>
<li><a href="#&#x987A;&#x4FBF;&#x770B;&#x4E00;&#x4E0B;kernelexittoel0">&#x987A;&#x4FBF;&#x770B;&#x4E00;&#x4E0B;kernelExitToEl0</a></li>
<li><a href="#el1&#x540C;&#x6B65;&#x5F02;&#x5E38;el1_sync">EL1&#x540C;&#x6B65;&#x5F02;&#x5E38;El1_sync</a></li>
<li><a href="#el1&#x5176;&#x4ED6;&#x5F02;&#x5E38;irq-fiq-error&#x90FD;&#x8D70;shutdown&#x6D41;&#x7A0B;-&#x5173;&#x95ED;guest">EL1&#x5176;&#x4ED6;&#x5F02;&#x5E38;(irq, fiq, error)&#x90FD;&#x8D70;shutdown&#x6D41;&#x7A0B;, &#x5173;&#x95ED;guest</a></li>
</ul>
</li>
<li><a href="#kvm_create_vcpu">KVM_CREATE_VCPU</a><ul>
<li><a href="#kerneladdr&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;eface&#x548C;func&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;">kernelAddr&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;eface&#x548C;func&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;</a></li>
</ul>
</li>
<li><a href="#kvm_arm_vcpu_init">KVM_ARM_VCPU_INIT</a><ul>
<li><a href="#&#x5165;&#x53E3;&#x4EE3;&#x7801;">&#x5165;&#x53E3;&#x4EE3;&#x7801;</a></li>
</ul>
</li>
<li><a href="#kvm&#x7684;context&#x5B9E;&#x73B0;">KVM&#x7684;context&#x5B9E;&#x73B0;</a><ul>
<li><a href="#arm64&#x7684;cpuswitchtouser">arm64&#x7684;cpu.SwitchToUser</a></li>
<li><a href="#bluepill&#x6C47;&#x7F16;&#x51FD;&#x6570;">bluepill()&#x6C47;&#x7F16;&#x51FD;&#x6570;</a></li>
<li><a href="#vcpucpuswitchtouser&#x51FD;&#x6570;">vCPU.CPU.SwitchToUser&#x51FD;&#x6570;</a></li>
<li><a href="#&#x8865;&#x5145;-go-linkname&#x7528;&#x6CD5;">&#x8865;&#x5145; go linkname&#x7528;&#x6CD5;</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;"><a name="gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;" class="anchor-navigation-ex-anchor" href="#gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;"><i class="fa fa-link" aria-hidden="true"></i></a>1. gvisor&#x4EE3;&#x7801;&#x6982;&#x89C8;&#x56FE;:</h1>
<p><img src="img/gvisor_code_flow.png" alt="">  </p>
<h2 id="host-mode&#x548C;guest-mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;"><a name="host-mode&#x548C;guest-mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;" class="anchor-navigation-ex-anchor" href="#host-mode&#x548C;guest-mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;"><i class="fa fa-link" aria-hidden="true"></i></a>1.1. host mode&#x548C;guest mode&#x5207;&#x6362;&#x5C0F;&#x7ED3;</h2>
<p>&#x603B;&#x7684;&#x6765;&#x8BF4;, &#x867D;&#x7136;&#x7528;&#x4E86;kvm, &#x4F46;gvisor&#x5DE7;&#x5999;&#x5730;&#x8BBE;&#x8BA1;&#x4E86;&#x4ECE;guest PA&#x5230;host VA&#x7684;&#x6620;&#x5C04;, &#x4ECE;&#x800C;&#x8BA9;guest&#x80FD;&#x8BFB;&#x5199;host&#x4E00;&#x6837;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;, &#x800C;&#x4E14;gvisor&#x4F1A;&#x628A;&#x6240;&#x6709;&#x7684;guest app&#x4E5F;&#x90FD;&#x6620;&#x5C04;&#x5230;&#x8FD9;&#x4E2A;&#x5730;&#x5740;&#x7A7A;&#x95F4;. &#x8FD9;&#x6837;&#x4EA7;&#x751F;&#x7684;&#x73B0;&#x8C61;&#x662F;guest&#x548C;host&#x4EA4;&#x66FF;&#x6267;&#x884C;&#x8FD9;&#x4E2A;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x4E0A;&#x7684;&#x4EE3;&#x7801;.</p>
<ul>
<li>&#x5207;&#x6362;&#x70B9;&#x5728;<code>(*vCPU).SwitchToUser</code>&#x8FD9;&#x4E2A;&#x51FD;&#x6570;, &#x5728;bluepill&#x524D;&#x5728;host&#x6A21;&#x5F0F;&#x6267;&#x884C;, &#x7136;&#x540E; &#x5207;&#x6362;&#x5230;guest&#x6A21;&#x5F0F;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x4EE3;&#x7801;(&#x5305;&#x62EC;EL1&#x7279;&#x6743;&#x4EE3;&#x7801;), &#x5176;&#x4E2D;&#x7684;&#x5173;&#x952E;&#x51FD;&#x6570;&#x662F;kernelExitToEl0, &#x6548;&#x679C;&#x662F;&#x8BA9;geust&#x6267;&#x884C;guest&#x7684;EL0&#x4EE3;&#x7801;, &#x76F4;&#x5230;&#x9047;&#x5230;SVC&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x6307;&#x4EE4;</li>
<li>guest&#x7684;SVC&#x6307;&#x4EE4;&#x5BFC;&#x81F4;guest&#x6A21;&#x5F0F;&#x9000;&#x51FA;, ucontext&#x88AB;&#x8BBE;&#x7F6E;&#x4E3A;guest&#x6267;&#x884C;SVC&#x524D;&#x7684;&#x72B6;&#x6001;, &#x4F46;&#x4EA4;&#x7ED9;host&#x6765;&#x63A5;&#x529B;&#x6267;&#x884C;. &#x63A5;&#x7740;host&#x6765;&#x6267;&#x884C;SVC&#x6307;&#x4EE4;, &#x5728;host&#x6A21;&#x5F0F;&#x4E0B;&#x89E6;&#x53D1;syscall, &#x8BA9;host kernel&#x6765;&#x6267;&#x884C;syscall</li>
</ul>
<h2 id="go-&#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;"><a name="go-&#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;" class="anchor-navigation-ex-anchor" href="#go-&#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;"><i class="fa fa-link" aria-hidden="true"></i></a>1.2. go &#x6C47;&#x7F16;&#x548C;arm64&#x77E5;&#x8BC6;</h2>
<p>&#x4F2A;&#x5BC4;&#x5B58;&#x5668;:</p>
<ul>
<li>SB: Static base pointer &#x5168;&#x5C40;&#x57FA;&#x5730;&#x5740;. &#x6BD4;&#x5982;foo(SB)&#x5C31;&#x662F;foo&#x8FD9;&#x4E2A;symbol&#x7684;&#x5730;&#x5740;</li>
<li>FP: &#x5E27;&#x6307;&#x9488;. &#x7528;&#x6765;&#x4F20;&#x53C2;&#x7684;</li>
<li>SP: &#x6808;&#x6307;&#x9488;. &#x6307;&#x5411;&#x6808;&#x9876;. &#x7528;&#x4E8E;&#x5C40;&#x90E8;&#x53D8;&#x91CF;. &#x6CE8;&#x610F;&#x771F;&#x5BC4;&#x5B58;&#x5668;&#x53EB;RSP</li>
<li>PC: &#x7A0B;&#x5E8F;&#x6307;&#x9488;</li>
</ul>
<p>&#x51FD;&#x6570;&#x683C;&#x5F0F;: TEXT symbol(SB), [flags,] $framesize[-argsize]</p>
<ul>
<li>symbol: &#x51FD;&#x6570;&#x540D;</li>
<li>SB: SB&#x4F2A;&#x5BC4;&#x5B58;&#x5668;</li>
<li>flags: &#x53EF;&#x4EE5;&#x662F;<ul>
<li>NOSPLIT: &#x4E0D;&#x8BA9;&#x7F16;&#x8BD1;&#x5668;&#x63D2;&#x5165;&#x6808;&#x5206;&#x88C2;&#x7684;&#x4EE3;&#x7801;</li>
<li>WRAPPER: &#x4E0D;&#x589E;&#x52A0;&#x51FD;&#x6570;&#x5E27;&#x8BA1;&#x6570;</li>
<li>NEEDCTXT: &#x9700;&#x8981;&#x4E0A;&#x4E0B;&#x6587;&#x53C2;&#x6570;, &#x4E00;&#x822C;&#x7528;&#x4E8E;&#x95ED;&#x5305;</li>
</ul>
</li>
<li>$framesize: &#x5C40;&#x90E8;&#x53D8;&#x91CF;&#x5927;&#x5C0F;, &#x5305;&#x542B;&#x8981;&#x4F20;&#x7ED9;&#x5B50;&#x51FD;&#x6570;&#x7684;&#x53C2;&#x6570;&#x90E8;&#x5206;</li>
<li>-argsize: &#x53C2;&#x6570;+&#x8FD4;&#x56DE;&#x503C;&#x7684;&#x5927;&#x5C0F;, &#x53EF;&#x4EE5;&#x7701;&#x7565;&#x7531;&#x7F16;&#x8BD1;&#x5668;&#x81EA;&#x5DF1;&#x63A8;&#x5BFC;</li>
</ul>
<h3 id="arm64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;"><a name="arm64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;" class="anchor-navigation-ex-anchor" href="#arm64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;"><i class="fa fa-link" aria-hidden="true"></i></a>1.2.1. ARM64&#x9875;&#x8868;&#x548C;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x77E5;&#x8BC6;</h3>
<p>&#x6BCF;&#x4E2A;&#x8FDB;&#x7A0B;&#x90FD;&#x6709;&#x81EA;&#x5DF1;&#x7684;translation table, &#x8FD9;&#x4E2A;table&#x662F;kernel&#x5206;&#x914D;&#x7684;, &#x628A;&#x5176;&#x7269;&#x7406;&#x5730;&#x5740;&#x914D;&#x7F6E;&#x5230;ttbr0&#x5BC4;&#x5B58;&#x5668;.
&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x65F6;&#x5019;, kernel&#x4F1A;&#x4FDD;&#x5B58;/&#x6062;&#x590D;&#x5982;&#x4E0B;&#x4E0A;&#x4E0B;&#x6587;:</p>
<ul>
<li>general-purpose registers X0-X30.</li>
<li>Advanced SIMD and Floating-point registers V0 - V31.</li>
<li>Some status registers.</li>
<li>TTBR0_EL1 and TTBR0.</li>
<li>Thread Process ID (TPIDxxx) Registers.</li>
<li>Address Space ID (ASID).</li>
</ul>
<p>EL0&#x548C;EL1&#x6709;&#x4E24;&#x4E2A;translation table, TTBR0_EL1&#x8D1F;&#x8D23;bottom&#x7A7A;&#x95F4;(&#x7528;&#x6237;&#x7A7A;&#x95F4;), TTBR1_EL1&#x8D1F;&#x8D23;top&#x7A7A;&#x95F4;(kernel&#x7A7A;&#x95F4;).
&#x5927;&#x5BB6;&#x90FD;&#x7528;TTBR1_EL1&#x505A;kernel&#x7A7A;&#x95F4;, &#x6240;&#x4EE5;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x7684;&#x65F6;&#x5019;, TTBR1_EL1&#x4E0D;&#x7528;&#x53D8;, &#x6240;&#x4EE5;kernel&#x7684;&#x6620;&#x5C04;&#x4E0D;&#x7528;&#x53D8;.</p>
<p>ASID&#x914D;&#x7F6E;&#x5728;TTBR0_EL1&#x91CC;
ASID(Address Space ID)&#x5BC4;&#x5B58;&#x5668;&#x7528;&#x6765;&#x6807;&#x8BB0;&#x9875;&#x8868;entry&#x6240;&#x5C5E;&#x7684;task, &#x7531;kernel&#x5206;&#x914D;.<br>&#x5F53;TLB&#x66F4;&#x65B0;&#x7684;&#x65F6;&#x5019;, TLB entry&#x9664;&#x4E86;&#x4FDD;&#x5B58;&#x5730;&#x5740;&#x7FFB;&#x8BD1;&#x4FE1;&#x606F;, &#x8FD8;&#x4F1A;&#x5305;&#x62EC;&#x8FD9;&#x4E2A;ASID.<br>TLB&#x67E5;&#x8BE2;&#x7684;&#x65F6;&#x5019;, &#x53EA;&#x6709;&#x5F53;&#x524D;&#x7684;ASID&#x548C;TLB entry&#x4FDD;&#x5B58;&#x7684;ASID&#x5339;&#x914D;&#x7684;&#x65F6;&#x5019;, &#x624D;&#x7B97;TLB&#x547D;&#x4E2D;. &#x6240;&#x4EE5;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x65F6;&#x5019;&#x4E0D;&#x9700;&#x8981;flush TLB.<br>&#x628A;ASID&#x503C;&#x653E;&#x5728;TTBR0_EL1&#x91CC;&#x7684;&#x597D;&#x5904;&#x662F;, &#x4E00;&#x4E2A;&#x6307;&#x4EE4;&#x5C31;&#x53EF;&#x4EE5;&#x539F;&#x5B50;&#x7684;&#x66F4;&#x6539;ASID&#x548C;&#x9875;&#x8868;.</p>
<ul>
<li>AARCH64&#x652F;&#x6301;&#x865A;&#x62DF;&#x5185;&#x5B58;&#x7684;tag, &#x865A;&#x62DF;&#x5185;&#x5B58;&#x7684;&#x6700;&#x9AD8;8&#x4F4D;&#x662F;tag, &#x5728;&#x5730;&#x5740;&#x7FFB;&#x8BD1;&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x88AB;&#x5FFD;&#x7565;.</li>
<li>PC, LR, SP, ELR&#x91CC;&#x9762;&#x90FD;&#x662F;VA</li>
<li>AArch64&#x6709;48&#x4F4D;VA, &#x7A7A;&#x95F4;&#x6709;256TB, &#x6709;&#x4E24;&#x4E2A;range&#x7A7A;&#x95F4;<br>  <code>0xFFFF_0000_0000_0000</code> &#x5230; <code>0xFFFF_FFFF_FFFF_FFFF</code> &#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;&#x662F;TTBR1, &#x5185;&#x6838;&#x6001;<br>  &#x6216;<br>  <code>0x0000_0000_0000_0000</code> &#x5230; <code>0x0000_FFFF_FFFF_FFFF</code> &#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;&#x662F;TTBR0, &#x7528;&#x6237;&#x6001;</li>
<li>IPA&#x4E5F;&#x662F;48&#x4F4D;</li>
<li>PA&#x4E5F;&#x662F;48&#x4F4D;, &#x5E76;&#x4E14;secure&#x548C;non-secure&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x662F;&#x72EC;&#x7ACB;&#x7684;</li>
<li>TTBR&#x662F;&#x5730;&#x5740;&#x8F6C;&#x6362;&#x8868;&#x7684;&#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;, &#x8FD9;&#x4E2A;&#x8868;&#x7531;&#x786C;&#x4EF6;&#x81EA;&#x52A8;&#x67E5;, &#x5E76;&#x88AB;&#x7F13;&#x5B58;&#x5230;TLB&#x4E2D;;<br>  TTBR&#x91CC;&#x9762;&#x4FDD;&#x5B58;&#x7684;&#x662F;&#x7269;&#x7406;&#x5730;&#x5740;, &#x662F;&#x7ED9;&#x786C;&#x4EF6;MMU waker&#x770B;&#x7684;.<br>  &#x8FD9;&#x4E2A;&#x8868;&#x6700;&#x591A;&#x6709;&#x56DB;&#x7EA7;, &#x5730;&#x5740;&#x6700;&#x591A;48&#x4F4D;, &#x6700;&#x5927;64KB&#x4E00;&#x4E2A;&#x6620;&#x5C04;</li>
</ul>
<h3 id="arm64&#x5F02;&#x5E38;&#x5904;&#x7406;"><a name="arm64&#x5F02;&#x5E38;&#x5904;&#x7406;" class="anchor-navigation-ex-anchor" href="#arm64&#x5F02;&#x5E38;&#x5904;&#x7406;"><i class="fa fa-link" aria-hidden="true"></i></a>1.2.2. ARM64&#x5F02;&#x5E38;&#x5904;&#x7406;</h3>
<p>&#x5F02;&#x5E38;&#x53D1;&#x751F;&#x7684;&#x65F6;&#x5019;, CPU&#x4F1A;&#x81EA;&#x52A8;&#x7684;&#x5B9E;&#x65BD;&#x5982;&#x4E0B;&#x52A8;&#x4F5C;:</p>
<ul>
<li>&#x5C06;PSTATE&#x4FDD;&#x5B58;&#x5230;SPSR_ELn</li>
<li>&#x6BD4;&#x5982;&#x5F02;&#x5E38;&#x53D1;&#x751F;&#x5728;EL0, &#x4E00;&#x822C;&#x4F1A;&#x5728;EL1&#x5904;&#x7406;. &#x90A3;PSTATE&#x4F1A;&#x4FDD;&#x5B58;&#x5728;SPSR_EL1</li>
<li>&#x66F4;&#x65B0;PSTATE&#x4EE5;&#x53CD;&#x6620;&#x65B0;&#x7684;CPU&#x72B6;&#x6001;, &#x6BD4;&#x5982;&#x5DF2;&#x7ECF;&#x8FDB;&#x5165;EL1</li>
<li>&#x786C;&#x4EF6;&#x4F1A;&#x5C06;&#x8FD4;&#x56DE;&#x5730;&#x5740;&#x4FDD;&#x5B58;&#x5728;ELR_Eln.</li>
<li>&#x8FD8;&#x662F;&#x6BD4;&#x5982;&#x5F02;&#x5E38;&#x53D1;&#x751F;&#x5728;EL0, &#x4F46;&#x5728;EL1&#x5904;&#x7406;, &#x90A3;&#x8FD4;&#x56DE;&#x5730;&#x5740;&#x4FDD;&#x5B58;&#x5728;ELR_EL1</li>
</ul>
<p>eret&#x6307;&#x4EE4;&#x7528;&#x6765;&#x4ECE;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x8FD4;&#x56DE;:</p>
<ul>
<li>&#x4ECE;SPSR_ELn&#x6062;&#x590D;&#x5F02;&#x5E38;&#x524D;&#x7684;PSTATE</li>
<li>&#x4ECE;ELR_ELn&#x6062;&#x590D;PC</li>
<li>&#x5F02;&#x5E38;&#x8FD4;&#x56DE;, &#x4ECE;&#x6062;&#x590D;&#x7684;PC&#x548C;PSTATE&#x7EE7;&#x7EED;&#x6267;&#x884C;</li>
</ul>
<p>&#x5728;&#x53D1;&#x751F;&#x5F02;&#x5E38;&#x65F6;, &#x786C;&#x4EF6;&#x4F1A;&#x81EA;&#x52A8;&#x66F4;&#x65B0;ELR, &#x6839;&#x636E;&#x60C5;&#x51B5;, &#x8FD4;&#x56DE;&#x5730;&#x5740;&#x6709;&#x51E0;&#x79CD;&#x53EF;&#x80FD;:</p>
<ul>
<li>&#x6BD4;&#x5982;SVC&#x6307;&#x4EE4;&#x89E6;&#x53D1;&#x7684;&#x540C;&#x6B65;&#x5F02;&#x5E38;, ELR&#x91CC;&#x4FDD;&#x5B58;&#x7684;&#x662F;&#x5176;&#x4E0B;&#x4E00;&#x6761;&#x6307;&#x4EE4;</li>
<li>&#x6BD4;&#x5982;&#x5F02;&#x6B65;&#x5F02;&#x5E38;(&#x5373;&#x5916;&#x90E8;&#x4E2D;&#x65AD;), ELR&#x91CC;&#x4FDD;&#x5B58;&#x7684;&#x662F;&#x4E0B;&#x4E00;&#x4E2A;&#x6CA1;&#x88AB;&#x6267;&#x884C;(&#x6216;&#x5B8C;&#x5168;&#x6267;&#x884C;)&#x7684;&#x6307;&#x4EE4;</li>
<li>ELR&#x53EF;&#x4EE5;&#x5728;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x91CC;&#x9762;&#x88AB;&#x66F4;&#x6539;.</li>
</ul>
<p>&#x6BCF;&#x4E2A;exception level&#x90FD;&#x6709;&#x72EC;&#x7ACB;&#x7684;&#x5F02;&#x5E38;&#x5411;&#x91CF;&#x8868;<br>    VBAR_EL3, VBAR_EL2 and VBAR_EL1<br>&#x5411;&#x91CF;&#x8868;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x914D;&#x5728;VBAR&#x5BC4;&#x5B58;&#x5668;&#x91CC;  </p>
<p>arm64&#x7684;sp&#x5BC4;&#x5B58;&#x5668;&#x6BCF;&#x4E2A;EL&#x90FD;&#x6709;, &#x4F46;&#x4E0D;&#x4E00;&#x5B9A;&#x90FD;&#x7528;:  </p>
<ul>
<li>SPSel&#x9009;&#x62E9;&#x5BC4;&#x5B58;&#x5668;&#x7684;0&#x4F4D;, &#x6765;&#x51B3;&#x5B9A;&#x7528;&#x54EA;&#x4E2A;SP</li>
<li>&#x9ED8;&#x8BA4;&#x6BCF;&#x4E2A;EL&#x4F7F;&#x7528;&#x81EA;&#x5DF1;&#x7684;level&#x5BF9;&#x5E94;&#x7684;SP</li>
</ul>
<h3 id="arm64&#x5BC4;&#x5B58;&#x5668;"><a name="arm64&#x5BC4;&#x5B58;&#x5668;" class="anchor-navigation-ex-anchor" href="#arm64&#x5BC4;&#x5B58;&#x5668;"><i class="fa fa-link" aria-hidden="true"></i></a>1.2.3. ARM64&#x5BC4;&#x5B58;&#x5668;</h3>
<p>In AArch64 state, the following registers are available:</p>
<ul>
<li>Thirty-one 64-bit general-purpose registers X0-X30, the bottom halves of which are accessible as W0-W30.</li>
<li>Four stack pointer registers SP_EL0, SP_EL1, SP_EL2, SP_EL3.</li>
<li>Three exception link registers ELR_EL1, ELR_EL2, ELR_EL3.</li>
<li>Three saved program status registers SPSR_EL1, SPSR_EL2, SPSR_EL3.</li>
<li>One program counter.</li>
</ul>
<p>For the purposes of function calls, the general-purpose registers are divided into four groups:</p>
<ul>
<li>r30(LR): The Link Register</li>
<li>r29(FP): The Frame Pointer</li>
<li>r19...r28: Callee-saved registers</li>
<li>r18: The Platform Register, if needed; otherwise a temporary register.</li>
<li>r17(IP1): The second intra-procedure-call temporary register</li>
<li>r16(IP0): The first intra-procedure-call scratch register</li>
<li>r9...r15: Temporary registers</li>
<li>r8: Indirect result location register</li>
<li>r0...r7: Parameter/result registers</li>
</ul>
<p>XZR&#x662F;zero&#x5BC4;&#x5B58;&#x5668;<br>PC&#x5BC4;&#x5B58;&#x5668;BL&#x6216;ADL&#x6307;&#x4EE4;&#x53EF;&#x4EE5;&#x4FEE;&#x6539;<br>SP&#x5411;&#x4E0B;&#x589E;&#x957F;, &#x5FC5;&#x987B;16&#x5B57;&#x8282;&#x5BF9;&#x9F50;<br>PSR&#x5BC4;&#x5B58;&#x5668;: Process State, &#x53CD;&#x6620;&#x4E00;&#x4E9B;&#x6BD4;&#x8F83;&#x64CD;&#x4F5C;&#x7684;&#x72B6;&#x6001;  </p>
<h1 id="gvisor&#x4ECB;&#x7ECD;"><a name="gvisor&#x4ECB;&#x7ECD;" class="anchor-navigation-ex-anchor" href="#gvisor&#x4ECB;&#x7ECD;"><i class="fa fa-link" aria-hidden="true"></i></a>2. gvisor&#x4ECB;&#x7ECD;</h1>
<p>gvisor&#x662F;&#x4E00;&#x4E2A;&#x7528;&#x6237;&#x6001;&#x64CD;&#x505A;&#x7CFB;&#x7EDF;, &#x81EA;&#x5E26;&#x4E00;&#x4E2A;runsc, &#x53EF;&#x4EE5;&#x548C;conainterd&#x7B49;&#x7F16;&#x6392;&#x5DE5;&#x5177;&#x96C6;&#x6210;.
gvisor&#x4E3B;&#x6253;&#x5B89;&#x5168;&#x7279;&#x6027;.</p>
<p>As outlined in the previous blog post, gVisor&#x2019;s <a href="https://gvisor.dev/blog/2019/11/18/gvisor-security-basics-part-1/#design-principles" target="_blank">secure design principles</a> are:</p>
<ol>
<li>Defense in Depth: each component of the software stack trusts each other component as little as possible.</li>
<li>Least Privilege: each software component has only the permissions it needs to function, and no more.</li>
<li>Attack Surface Reduction: limit the surface area of the host exposed to the sandbox.</li>
<li>Secure by Default: the default choice for a user should be safe.</li>
</ol>
<h2 id="&#x539F;&#x7406;&#x7B80;&#x4ECB;"><a name="&#x539F;&#x7406;&#x7B80;&#x4ECB;" class="anchor-navigation-ex-anchor" href="#&#x539F;&#x7406;&#x7B80;&#x4ECB;"><i class="fa fa-link" aria-hidden="true"></i></a>2.1. &#x539F;&#x7406;&#x7B80;&#x4ECB;</h2>
<p>&#x539F;&#x6587;: <a href="https://www.infoq.com/presentations/gvisor-os-go/" target="_blank">https://www.infoq.com/presentations/gvisor-os-go/</a></p>
<p><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080707.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080723.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080752.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080816.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080835.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080908.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080933.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915080946.png" alt="">  </p>
<h1 id="&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;"><a name="&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;" class="anchor-navigation-ex-anchor" href="#&#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;"><i class="fa fa-link" aria-hidden="true"></i></a>3. &#x7F16;&#x8BD1;&#x548C;&#x8C03;&#x8BD5;</h1>
<p>clone gvisor&#x540E;, &#x5207;&#x6362;&#x5230;go&#x5206;&#x652F;, &#x5728;runsc&#x4E0B;&#x9762;<code>go build</code>&#x7F16;&#x8BD1;&#x51FA;&#x6765;&#x7684;runsc&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x4F7F;&#x7528;.<br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915081041.png" alt=""><br>&#x4FEE;&#x6539;daemon.json&#x5E76;&#x4E14;<code>systemctl reload docker</code>&#x5C31;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;runsc&#x4E86;:</p>
<pre><code>docker run --cpus=2 -m 2g --rm --runtime=runsc -it --name=test centos:7 bash
</code></pre><p>&#x987A;&#x5229;&#x7684;&#x8BDD;&#x5C31;&#x8FDB;&#x5165;container&#x91CC;&#x9762;&#x4E86;</p>
<p>debug&#x7684;log&#x5728;<code>/tmp/runsc</code>, &#x5176;&#x4E2D;&#x6BD4;&#x5982;<code>runsc.log.20220315-022030.789081.boot</code>&#x5C31;&#x662F;&#x4E3B;&#x8FDB;&#x7A0B;&#x7684;log</p>
<p>docker run&#x540E;, &#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;sndbox&#x8FDB;&#x7A0B;<code>runsc-sandbox</code>, &#x5C31;&#x53EF;&#x4EE5;&#x7528;<code>dlv attach pid</code>&#x6765;&#x8C03;&#x8BD5;.</p>
<p>&#x5B98;&#x65B9;github&#x91CC;&#x9762;install&#x63D0;&#x5230;&#x7684;containerd-shim-runsc-v1&#x662F;&#x6CA1;&#x7528;&#x5230;&#x7684;.&#x5B9E;&#x9645;docker&#x4F7F;&#x7528;&#x7684;&#x662F;<code>/usr/bin/containerd-shim-runc-v2</code></p>
<p>&#x5982;&#x679C;&#x5728;arm64&#x7684;raspberry pi&#x4E0A;, &#x9700;&#x8981;&#x4FEE;&#x6539;<code>/boot/firmware/cmdline.txt</code>, &#x589E;&#x52A0;<code>cgroup_enable=memory</code></p>
<pre><code>net.ifnames=0 dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline rootwait fixrtc cgroup_enable=memory
</code></pre><h1 id="&#x4EE3;&#x7801;&#x7ED3;&#x6784;"><a name="&#x4EE3;&#x7801;&#x7ED3;&#x6784;" class="anchor-navigation-ex-anchor" href="#&#x4EE3;&#x7801;&#x7ED3;&#x6784;"><i class="fa fa-link" aria-hidden="true"></i></a>4. &#x4EE3;&#x7801;&#x7ED3;&#x6784;</h1>
<p>gvisor&#x7684;&#x4F9D;&#x8D56;&#x5305;&#x5F88;&#x591A;, &#x6709;containerd&#x548C;docker&#x7B49;&#x5BB9;&#x5668;&#x7684;, &#x6709;k8s&#x7684;, &#x6709;protobuf&#x548C;grpc&#x7684;, &#x6709;&#x62A5;&#x6587;&#x89E3;&#x6790;&#x76F8;&#x5173;&#x7684;gopacket, &#x6709;&#x66F4;&#x52A0;&#x57FA;&#x7840;&#x7684;btree&#x5E93;... &#x5F88;&#x591A;<br>gvisor&#x6709;&#x5F88;&#x591A;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684;&#x57FA;&#x7840;&#x5E93;<a href="https://github.com/google/gvisor/tree/master/pkg" target="_blank">https://github.com/google/gvisor/tree/master/pkg</a><br>&#x53EF;&#x4EE5;&#x8BF4;, gvisor&#x7684;&#x8FD9;&#x4E9B;&#x57FA;&#x7840;&#x5E93;&#x672C;&#x8EAB;, &#x5C31;&#x662F;&#x7CFB;&#x7EDF;&#x7EA7;linux&#x57FA;&#x7840;&#x7684;golang&#x5B9E;&#x73B0;&#x7684;&#x53C2;&#x8003;&#x5E93;.<br>&#x6BD4;&#x5982;eventfd&#x5305;&#x5C31;&#x5305;&#x88C5;&#x4E86;linux&#x7684;enventfd&#x7CFB;&#x7EDF;&#x8C03;&#x7528;.<br>&#x6BD4;&#x5982;&#x5728;&#x6807;&#x51C6;&#x5E93;&#x57FA;&#x7840;&#x4E0A;&#x7684;sync&#x5305;</p>
<h2 id="abi"><a name="abi" class="anchor-navigation-ex-anchor" href="#abi"><i class="fa fa-link" aria-hidden="true"></i></a>4.1. abi</h2>
<p>gvisor&#x63D0;&#x4F9B;&#x4E86;&#x517C;&#x5BB9;linux&#x7684;abi: <a href="https://github.com/google/gvisor/tree/master/pkg/abi/linux" target="_blank">https://github.com/google/gvisor/tree/master/pkg/abi/linux</a><br>&#x5C31;&#x662F;&#x8BF4;gvisor&#x652F;&#x6301;&#x5927;&#x90E8;&#x5206;&#x7684;c&#x7684;abi:
&#x6BD4;&#x5982;aio, bpf, elf, epoll, fcntl, fs, ipc, mm, netlink, netfilter, ptrace, sched, time, uio, socket&#x7B49;&#x7B49;</p>
<h2 id="sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;"><a name="sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;" class="anchor-navigation-ex-anchor" href="#sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;"><i class="fa fa-link" aria-hidden="true"></i></a>4.2. sentry&#x7684;&#x5185;&#x5B58;&#x7BA1;&#x7406;</h2>
<p>sentry&#x662F;gvisor&#x7528;&#x6237;&#x6001;kernel&#x7684;&#x6838;&#x5FC3;.</p>
<h3 id="&#x4F20;&#x7EDF;mm"><a name="&#x4F20;&#x7EDF;mm" class="anchor-navigation-ex-anchor" href="#&#x4F20;&#x7EDF;mm"><i class="fa fa-link" aria-hidden="true"></i></a>4.2.1. &#x4F20;&#x7EDF;mm</h3>
<p>mmap&#x7684;&#x4EFB;&#x52A1;&#x662F;&#x5728;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x91CC;, map&#x4E00;&#x4E2A;&#x6587;&#x4EF6;&#x5230;&#x4E00;&#x4E2A;&#x865A;&#x62DF;&#x5730;&#x5740;&#x8303;&#x56F4;.
&#x5F53;&#x8FD9;&#x4E2A;&#x865A;&#x62DF;&#x5730;&#x5740;&#x88AB;&#x8BBF;&#x95EE;&#x7684;&#x65F6;&#x5019;, &#x6CA1;&#x6709;PTE&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x4EA7;&#x751F;page fault&#x5F02;&#x5E38;, kernel&#x624D;&#x5206;&#x914D;&#x7269;&#x7406;&#x9875;, &#x4ECE;&#x6587;&#x4EF6;copy&#x5B9E;&#x9645;&#x5185;&#x5BB9;&#x5230;&#x8FD9;&#x4E2A;&#x7269;&#x7406;&#x9875;.</p>
<ul>
<li>page&#x662F;&#x6709;cache&#x7684;, &#x4F7F;&#x7528;Least Recently Used (LRU)&#x7B56;&#x7565;&#x6362;&#x51FA;&#x4E0D;&#x7ECF;&#x5E38;&#x4F7F;&#x7528;&#x7684;page. &#x5F53;dirty page&#x8D85;&#x8FC7;&#x4E00;&#x4E2A;ratio, kernel&#x4F1A;flush&#x810F;&#x9875;.</li>
<li>Read-ahead&#x6280;&#x672F;&#x9884;&#x52A0;&#x8F7D;page&#x4ECE;&#x800C;&#x907F;&#x514D;&#x7F3A;&#x9875;&#x5F02;&#x5E38;&#x7684;&#x4EA7;&#x751F;.</li>
<li>madvise&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x53EF;&#x4EE5;&#x544A;&#x77E5;kernel app&#x5BF9;&#x5185;&#x5BB9;&#x8303;&#x56F4;&#x7684;&#x671F;&#x671B;.</li>
</ul>
<h4 id="shared-map"><a name="shared-map" class="anchor-navigation-ex-anchor" href="#shared-map"><i class="fa fa-link" aria-hidden="true"></i></a>shared map</h4>
<p>linux&#x7684;mmap&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x6BD4;&#x5982;:</p>
<pre><code class="lang-go">mmap(
    /* addr = */ 0x400000,
    /* length = */ 0x1000,
    PROT_READ | PROT_WRITE,
    MAP_SHARED,
    /* fd = */ 3,
    /* offset = */ 0);
</code></pre>
<p>&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x4ECE;fd 3&#x5230;<em>virtual memory areas</em> (VMAs)&#x7684;mapping.<br>&#x8FD9;&#x4E2A;mapping&#x4ECE;VA 0x400000&#x5F00;&#x59CB;, &#x957F;&#x5EA6;&#x4E3A;0x1000&#x5B57;&#x8282;, offset&#x662F;0.<br>&#x5047;&#x8BBE;fd 3&#x5BF9;&#x5E94;&#x7684;&#x6587;&#x4EF6;&#x662F;<code>/tmp/foo</code><br>&#x5185;&#x6838;&#x4E2D;&#x8FD9;&#x4E2A;mapping&#x8868;&#x793A;&#x4E3A;:</p>
<pre><code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0
</code></pre><p>&#x521B;&#x5EFA;VMA&#x7684;&#x65F6;&#x5019;&#x5E76;&#x6CA1;&#x6709;&#x5206;&#x914D;PA, &#x56E0;&#x4E3A;&#x8FD9;&#x4E2A;&#x65F6;&#x5019;linux&#x8FD8;&#x6CA1;&#x6709;&#x51C6;&#x5907;&#x7269;&#x7406;&#x5730;&#x5740;&#x6765;&#x4FDD;&#x5B58;<code>/tmp/foo</code>&#x7684;&#x5185;&#x5BB9;. &#x76F4;&#x5230;&#x5E94;&#x7528;&#x8BFB;VA&#x5730;&#x5740;<code>0x400000</code>, &#x4EA7;&#x751F;&#x7F3A;&#x9875;&#x5F02;&#x5E38;, &#x624D;&#x5206;&#x914D;&#x7269;&#x7406;&#x9875;, &#x7136;&#x540E;copy&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#x5230;&#x8FD9;&#x4E2A;&#x7269;&#x7406;&#x9875;. &#x6BD4;&#x5982;kernel&#x9009;&#x62E9;&#x4E86;<code>PA:0x2fb000</code>, &#x6B64;&#x65F6;VMA&#x662F;&#x8FD9;&#x6837;&#x7684;:</p>
<pre><code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0
Filemap:                /tmp/foo:0x0 -&gt; PA:0x2fb000
</code></pre><p>&#x8FD9;&#x91CC;&#x7684;Filemap&#x5BF9;&#x5E94;kernel&#x7684;<code>struct address_space</code></p>
<p>&#x8FD9;&#x4E2A;&#x65F6;&#x5019;kernel&#x4F7F;&#x7528;<em>page table entry</em> (PTE)&#x6765;&#x505A;VA&#x5230;PA&#x7684;&#x8F6C;&#x6362;&#x8868;.</p>
<pre><code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0
Filemap:                /tmp/foo:0x0 -&gt; PA:0x2fb000
PTE:     VA:0x400000 -----------------&gt; PA:0x2fb000
</code></pre><p>&#x6CE8;&#x610F;, VMA&#x548C;Filemap&#x662F;&#x76F8;&#x5BF9;&#x72EC;&#x7ACB;&#x7684;&#x4E1C;&#x897F;, &#x800C;PTE&#x53D7;&#x4E8C;&#x8005;&#x7684;&#x5F71;&#x54CD;, &#x6BD4;&#x5982;:</p>
<ul>
<li>&#x8FD9;&#x4E2A;&#x5E94;&#x7528;&#x8C03;&#x7528;&#x4E86;munmap&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x8FD9;&#x5C31;&#x89E3;&#x9664;&#x4E86;<code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0</code>&#x7684;&#x6620;&#x5C04;, &#x8FDB;&#x800C;&#x89E3;&#x9664;&#x4E86;<code>PTE:     VA:0x400000 -----------------&gt; PA:0x2fb000</code>. &#x4F46;&#x662F;, <code>Filemap:                /tmp/foo:0x0 -&gt; PA:0x2fb000</code>&#x4E0D;&#x4E00;&#x5B9A;&#x5C31;&#x89E3;&#x9664;&#x4E86;, &#x56E0;&#x4E3A;&#x4ECE;&#x6587;&#x4EF6;<code>/tmp/foo:0x0</code>&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;<code>PA:0x2fb000</code>&#x7684;&#x6620;&#x5C04;&#x4EE5;&#x540E;&#x8FD8;&#x80FD;&#x7528;&#x5F97;&#x4E0A;.</li>
<li>&#x8FD9;&#x4E2A;&#x5E94;&#x7528;&#x4E5F;&#x53EF;&#x80FD;&#x8C03;&#x7528;<code>ftruncate</code>&#x6765;invalidate&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x7684;&#x5185;&#x5BB9;. &#x8FD9;&#x5C31;&#x89E3;&#x9664;&#x4E86;<code>Filemap:                /tmp/foo:0x0 -&gt; PA:0x2fb000</code>, &#x8FDB;&#x800C;&#x89E3;&#x9664;&#x4E86;<code>PTE:     VA:0x400000 -----------------&gt; PA:0x2fb000</code>; &#x800C;<code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0</code>&#x5C31;&#x4E0D;&#x9700;&#x8981;&#x6539;&#x53D8;, &#x56E0;&#x4E3A;PTE&#x89E3;&#x9664;&#x4E86;, <code>VA:0x400000</code>&#x9700;&#x8981;&#x53E6;&#x4E00;&#x4E2A;&#x7F3A;&#x9875;&#x5F02;&#x5E38;&#x6765;&#x5206;&#x914D;&#x65B0;&#x7684;&#x7269;&#x7406;&#x9875;, &#x6240;&#x4EE5;VA&#x4ECD;&#x7136;&#x53CD;&#x5E94;&#x4E86;&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#x7684;&#x6539;&#x53D8;.</li>
</ul>
<h4 id="private-map"><a name="private-map" class="anchor-navigation-ex-anchor" href="#private-map"><i class="fa fa-link" aria-hidden="true"></i></a>private map</h4>
<p>&#x5BF9;private map&#x6765;&#x8BF4;, &#x8BFB;&#x548C;&#x5199;&#x90FD;&#x53EF;&#x80FD;&#x4F1A;&#x6709;&#x7F3A;&#x9875;&#x5F02;&#x5E38;.
&#x9996;&#x6B21;&#x8BFB;&#x4EA7;&#x751F;&#x7684;&#x7F3A;&#x9875;&#x5F02;&#x5E38;&#x4F1A;&#x4EA7;&#x751F;&#x4E00;&#x4E2A;&#x53EA;&#x8BFB;&#x7684;&#x7269;&#x7406;&#x9875;:</p>
<pre><code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0 (private)
Filemap:                /tmp/foo:0x0 -&gt; PA:0x2fb000
PTE:     VA:0x400000 -----------------&gt; PA:0x2fb000 (read-only)
</code></pre><p>&#x6B64;&#x65F6;&#x5982;&#x679C;&#x662F;shared map, &#x5199;&#x64CD;&#x505A;&#x4E5F;&#x4F1A;&#x5199;&#x5230;<code>PA:0x2fb000</code>. &#x4F46;private map&#x4F1A;&#x4EA7;&#x751F;&#x53E6;&#x5916;&#x4E00;&#x4E2A;&#x7F3A;&#x9875;&#x5F02;&#x5E38;, kernel&#x53E6;&#x5916;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x7269;&#x7406;&#x9875;(&#x6BD4;&#x5982;0x5ea000), &#x62F7;&#x8D1D;&#x4E4B;&#x524D;&#x7684;&#x7269;&#x7406;&#x9875;&#x5185;&#x5BB9;&#x5230;&#x8FD9;&#x4E2A;&#x65B0;&#x5206;&#x914D;&#x7684;&#x7269;&#x7406;&#x9875;, &#x7136;&#x540E;&#x66F4;&#x65B0;map:</p>
<pre><code>VMA:     VA:0x400000 -&gt; /tmp/foo:0x0 (private)
Filemap:                /tmp/foo:0x0 -&gt; PA:0x2fb000
PTE:     VA:0x400000 -----------------&gt; PA:0x5ea000
</code></pre><h4 id="&#x533F;&#x540D;&#x6620;&#x5C04;"><a name="&#x533F;&#x540D;&#x6620;&#x5C04;" class="anchor-navigation-ex-anchor" href="#&#x533F;&#x540D;&#x6620;&#x5C04;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x533F;&#x540D;&#x6620;&#x5C04;</h4>
<p>flag&#x91CC;&#x9762;&#x5982;&#x679C;&#x6709;<code>MAP_ANONYMOUS</code>&#x5C31;&#x4F7F;&#x7528;&#x533F;&#x540D;&#x6620;&#x5C04;, &#x5C31;&#x662F;&#x4E0D;&#x9700;&#x8981;&#x6587;&#x4EF6;&#x7684;&#x6620;&#x5C04;. &#x533F;&#x540D;&#x4E5F;&#x5206;shared&#x548C;private.</p>
<ul>
<li>shared&#x6A21;&#x5F0F;&#x4E0B;&#x9762;, &#x4F1A;&#x4EA7;&#x751F;&#x4E00;&#x4E2A;&#x4E34;&#x65F6;&#x7684;&#x96F6;&#x5B57;&#x8282;&#x7684;&#x6587;&#x4EF6;, &#x5927;&#x5BB6;&#x90FD;map&#x5230;&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;.</li>
<li>private&#x6A21;&#x5F0F;&#x4E0B;&#x9762;, &#x5C31;&#x6CA1;&#x6709;&#x8FD9;&#x4E2A;&#x4E34;&#x65F6;&#x6587;&#x4EF6;&#x4E86;. &#x800C;&#x662F;&#x4E00;&#x5F00;&#x59CB;&#x90FD;&#x7528;&#x4E00;&#x4E2A;&#x56FA;&#x5B9A;&#x7684;readonly&#x7684;&#x5168;&#x96F6;&#x7684;&#x9875;, &#x76F4;&#x5230;copy on write&#x65B0;&#x5206;&#x914D;&#x4E00;&#x4E2A;&#x53EF;&#x5199;&#x7684;&#x7269;&#x7406;&#x9875;.</li>
</ul>
<h3 id="&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page-fault"><a name="&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page-fault" class="anchor-navigation-ex-anchor" href="#&#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page-fault"><i class="fa fa-link" aria-hidden="true"></i></a>4.2.2. &#x5982;&#x4F55;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page fault</h3>
<h4 id="signal&#x65B9;&#x5F0F;"><a name="signal&#x65B9;&#x5F0F;" class="anchor-navigation-ex-anchor" href="#signal&#x65B9;&#x5F0F;"><i class="fa fa-link" aria-hidden="true"></i></a>signal&#x65B9;&#x5F0F;</h4>
<p>&#x53C2;&#x8003;: <a href="https://lwn.net/Articles/550555/" target="_blank">https://lwn.net/Articles/550555/</a>
&#x4E00;&#x822C;&#x7684;, &#x53EF;&#x4EE5;&#x4F7F;&#x7528;<code>mprotect(PROT_NONE)</code>&#x6765;&#x4EA7;&#x751F;SIGSEGV, &#x7136;&#x540E;&#x5728;SIGSEGV&#x7684;handler&#x91CC;&#x9762;&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page fault.</p>
<pre><code class="lang-c">#include &lt;sys/mman.h&gt;

int mprotect(void *addr, size_t len, int prot);
int pkey_mprotect(void *addr, size_t len, int prot, int pkey);
</code></pre>
<blockquote>
<p>The SIGBUS signal handler&apos;s job is to handle the page fault by mapping a real page to the faulting address. That can be done in current kernels with the mremap() system call. The problem with mremap() is that it works by splitting the virtual memory area (VMA) structure used to describe the memory range within the kernel. Frequent mremap() calls will result in the kernel having to manage a large number of VMAs, which is an expensive proposition. mremap() will also happily overwrite existing memory mappings, making it harder to detect errors (or race conditions) in user-space handlers. For these reasons, mremap() is not an ideal solution to the problem.</p>
</blockquote>
<p>&#x8FD8;&#x53EF;&#x4EE5;&#x9009;<code>madvise(MADV_USERFAULT)</code>, &#x4F3C;&#x4E4E;&#x66F4;&#x597D;</p>
<blockquote>
<p>Perhaps I&apos;m misunderstanding something here, but I don&apos;t understand how <code>MADV_USERFAULT</code> is different/superior from doing an <code>mprotect(PROT_NONE)</code> and then handling the <code>SIGSEGV</code>. Can someone help me out?
For one there is the uglyness of properly handling SIGSEGVs which requires sigaltstack et al. which is far from easy.</p>
<p>For another, if you would go that way you would need to call mmap() for every single page fault which would probably end up being horrendously expensive since you would end up with thousands of different mmap()s setup which is rather expensive. With the patchset, as far as I understand it, there&apos;s just one memory region setup in the kernel and just when it cannot find backing memory it falls back to the userspace page fault handler.</p>
</blockquote>
<h4 id="userfaultfd&#x65B9;&#x5F0F;&#x7528;&#x6237;&#x6001;page&#x7BA1;&#x7406;"><a name="userfaultfd&#x65B9;&#x5F0F;&#x7528;&#x6237;&#x6001;page&#x7BA1;&#x7406;" class="anchor-navigation-ex-anchor" href="#userfaultfd&#x65B9;&#x5F0F;&#x7528;&#x6237;&#x6001;page&#x7BA1;&#x7406;"><i class="fa fa-link" aria-hidden="true"></i></a>userfaultfd&#x65B9;&#x5F0F;&#x7528;&#x6237;&#x6001;page&#x7BA1;&#x7406;</h4>
<p>&#x4E0A;&#x9762;&#x63CF;&#x8FF0;&#x7684;&#x662F;&#x4F7F;&#x7528;SIGSEGV&#x4FE1;&#x53F7;&#x53CA;&#x5176;handler&#x5728;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page fault, &#x7B80;&#x79F0;umap<br>&#x800C;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;: <a href="https://arxiv.org/ftp/arxiv/papers/1910/1910.07566.pdf" target="_blank">https://arxiv.org/ftp/arxiv/papers/1910/1910.07566.pdf</a><br>&#x63D0;&#x5230;&#x4E86;&#x4F7F;&#x7528;userfaultfd&#x7684;umap&#x6280;&#x672F;, &#x5728;&#x7528;&#x6237;app&#x7684;&#x5355;&#x72EC;&#x7EBF;&#x7A0B;&#x91CC;&#x5904;&#x7406;page fault.</p>
<blockquote>
<p>Page faults in the address ranges are delivered asynchronously so that the faulting process is blocked instead of idling, allowing other processes to be scheduled to proceed.</p>
</blockquote>
<p>&#x53C2;&#x8003;: <code>man userfaultfd</code></p>
<pre><code>userfaultfd() creates a new userfaultfd object that can be used for delegation of page-fault handling to a user-space application, and returns a file descriptor that refers to the new object.  The new userfaultfd object is configured using ioctl(2).

Once the userfaultfd object is configured, the application can use read(2) to receive userfaultfd notifications.  The reads from userfaultfd may be blocking  or  non-blocking, depending on the value of flags used for the creation of the userfaultfd or subsequent calls to fcntl(2).
</code></pre><p>&#x53E6;&#x5916;&#x53C2;&#x8003;: <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/userfaultfd.html" target="_blank">https://www.kernel.org/doc/html/latest/admin-guide/mm/userfaultfd.html</a></p>
<blockquote>
<p>The real advantage of userfaults if compared to regular virtual memory management of mremap/mprotect is that the userfaults in all their operations never involve heavyweight structures like vmas (in fact the <code>userfaultfd</code> runtime load never takes the mmap_lock for writing).</p>
<p>Vmas are not suitable for page- (or hugepage) granular fault tracking when dealing with virtual address spaces that could span Terabytes. Too many vmas would be needed for that.</p>
<p>The <code>userfaultfd</code> once opened by invoking the syscall, can also be passed using unix domain sockets to a manager process, so the same manager process could handle the userfaults of a multitude of different processes without them being aware about what is going on (well of course unless they later try to use the <code>userfaultfd</code> themselves on the same region the manager is already tracking, which is a corner case that would currently return <code>-EBUSY</code>).</p>
<p>The userland application should set the feature flags it intends to use when invoking the <code>UFFDIO_API</code> ioctl, to request that those features be enabled if supported.</p>
<p>Once the <code>userfaultfd</code> API has been enabled the <code>UFFDIO_REGISTER</code> ioctl should be invoked (if present in the returned <code>uffdio_api.ioctls</code> bitmask) to register a memory range in the <code>userfaultfd</code> by setting the uffdio_register structure accordingly. The <code>uffdio_register.mode</code> bitmask will specify to the kernel which kind of faults to track for the range. The <code>UFFDIO_REGISTER</code> ioctl will return the <code>uffdio_register.ioctls</code> bitmask of ioctls that are suitable to resolve userfaults on the range registered. Not all ioctls will necessarily be supported for all memory types (e.g. anonymous memory vs. shmem vs. hugetlbfs), or all types of intercepted faults.</p>
<p>Userland can use the <code>uffdio_register.ioctls</code> to manage the virtual address space in the background (to add or potentially also remove memory from the <code>userfaultfd</code> registered range). This means a userfault could be triggering just before userland maps in the background the user-faulted page.</p>
</blockquote>
<p>&#x8FD9;&#x4E2A;page fault&#x5904;&#x7406;&#x7EBF;&#x7A0B;&#x4F7F;&#x7528;UFFDIO_COPY ioctl&#x6765;&#x89E3;&#x51B3;page fault, &#x8FD9;&#x4E2A;ioctl&#x7684;&#x597D;&#x5904;&#x662F;&#x4FDD;&#x8BC1;file&#x5185;&#x5BB9;&#x88AB;&#x5B8C;&#x5168;&#x62F7;&#x8D1D;&#x5230;&#x65B0;&#x5206;&#x914D;&#x7684;&#x7269;&#x7406;&#x5185;&#x5BB9;, &#x624D;&#x4F1A;&#x5524;&#x9192;app&#x8FDB;&#x7A0B;. &#x8FD9;&#x4E2A;&#x7528;&#x6237;&#x6001;&#x5904;&#x7406;page fault&#x7684;&#x8FC7;&#x7A0B;, &#x53EF;&#x4EE5;&#x4F7F;&#x7528;app&#x7684;knowledge, &#x6BD4;&#x5982;&#x53EF;&#x4EE5;&#x8BBE;&#x7F6E;page size, &#x9884;&#x53D6;&#x548C;&#x6362;&#x51FA;&#x7B56;&#x7565;. &#x8FD9;&#x4E9B;&quot;&#x5B9A;&#x5236;&#x5316;&quot;&#x7684;&#x7B56;&#x7565;&#x53EA;&#x5F71;&#x54CD;&#x8FD9;&#x4E2A;app, &#x5176;&#x4ED6;&#x7684;app&#x53EF;&#x4EE5;&#x9009;&#x62E9;&#x4E0D;&#x540C;&#x7684;&#x7B56;&#x7565;. &#x8FD9;&#x4E2A;&#x7075;&#x6D3B;&#x6027;&#x662F;kernel&#x65E0;&#x6CD5;&#x63D0;&#x4F9B;&#x7684;.
&#x540C;&#x65F6;, &#x5199;&#x8FDB;&#x7269;&#x7406;&#x9875;&#x7684;&#x5185;&#x5BB9;&#x4E5F;&#x53EF;&#x4EE5;&#x662F;&#x4ECE;&#x5176;&#x4ED6;&#x975E;&#x6587;&#x4EF6;&#x7684;&#x5730;&#x65B9;&#x6765;, &#x6BD4;&#x5982;&#x8FDC;&#x7A0B;&#x7684;&#x6570;&#x636E;&#x670D;&#x52A1;&#x5668;.</p>
<p><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915081921.png" alt=""><br>&#x603B;&#x7684;&#x6765;&#x8BF4;, Umap&#x5728;&#x7528;&#x6237;&#x6001;&#x5B9E;&#x73B0;&#x4E86;page&#x7684;&#x7BA1;&#x7406;. &#x5728;&#x7528;&#x6237;app&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7A7A;&#x95F4;, umap&#x7BA1;&#x7406;&#x6DF1;&#x84DD;&#x8272;&#x90E8;&#x5206;. &#x4EA7;&#x751F;&#x7684;page faults&#x5165;&#x961F;&#x5217;, &#x7531;filler&#x4EEC;&#x628A;&#x6570;&#x636E;&#x4ECE;&#x4E0D;&#x540C;&#x7684;&#x5B58;&#x50A8;&#x5B9E;&#x4F53;(stroe object)&#x91CC;&#x586B;&#x5145;&#x5230;&#x5185;&#x90E8;buffer, &#x5982;&#x679C;buffer&#x6EE1;&#x4E86;, &#x5C31;&#x89E6;&#x53D1;eviction&#x673A;&#x5236;, &#x7531;evictor&#x628A;&#x810F;&#x9875;&#x5199;&#x56DE;&#x5230;&#x5B58;&#x50A8;&#x5B9E;&#x4F53;&#x91CC;. &#x4E3A;&#x4E86;&#x63D0;&#x9AD8;&#x5E76;&#x53D1;, fillers&#x548C;evictors&#x90FD;&#x662F;IO&#x7EBF;&#x7A0B;&#x6C60;.</p>
<p>umap&#x53EF;&#x4EE5;&#x8BA9;app&#x81EA;&#x5DF1;&#x914D;&#x7F6E;page size, &#x8FD9;&#x4E2A;&#x5BF9;&#x6027;&#x80FD;&#x63D0;&#x9AD8;&#x5E2E;&#x52A9;&#x5F88;&#x5927;. &#x4E5F;&#x53EF;&#x4EE5;&#x8BA9;app&#x914D;&#x7F6E;&#x7075;&#x6D3B;&#x7684;prefetching&#x7B56;&#x7565;.
&#x786C;&#x4EF6;&#x7684;prefetching&#x5F80;&#x5F80;&#x4E0D;&#x591F;&#x7075;&#x6D3B;, &#x56E0;&#x4E3A;&#x73B0;&#x5B9E;&#x7684;&#x9884;&#x53D6;&#x7684;pattern&#x5F88;&#x590D;&#x6742;, &#x5F88;&#x96BE;&#x6709;&#x4E00;&#x4E2A;&#x901A;&#x7528;&#x7684;&#x7B56;&#x7565;. &#x5185;&#x6838;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;prefetch&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;&#x6765;&#x76F4;&#x5230;&#x786C;&#x4EF6;&#x9884;&#x53D6;, &#x4F46;&#x4E00;&#x822C;&#x7684;&#x5B9E;&#x73B0;&#x91CC;&#x7528;&#x6237;&#x6001;&#x6CA1;&#x6709;&#x76F8;&#x5173;&#x7684;api.</p>
<p>umap&#x7684;API&#x7C7B;&#x4F3C;mmap:</p>
<pre><code class="lang-go">int fd = open(fname , O_RDWR);
void* base_addr = umap(NULL, totalbytes, PROT_READ|PROT_WRITE, UMAP_PRIVATE, fd, 0);

//Select two non -contiguous pages to prefetch
std::vector &lt;umap_prefetch_item &gt; pfi;
umap_prefetch_item p0 = { .page_base_addr = &amp;base[5 *psize] };
pfi.push_back(p0);
umap_prefetch_item p1 = { .page_base_addr = &amp;base[15* psize] };
pfi.push_back(p1);
umap_prefetch(num_prefetch_pages , &amp;pfi[0]);

computation();

//release resources
uunmap(base_addr , totalbytes);
</code></pre>
<p>umap&#x7684;&#x6027;&#x80FD;&#x5728;page size&#x4E3A;4K&#x7684;&#x65F6;&#x5019;&#x8FD8;&#x662F;&#x4F4E;&#x4E8E;mmap&#x7684;, &#x4F46;&#x4ECE;64K&#x5F00;&#x59CB;, &#x5DF2;&#x7ECF;&#x5F00;&#x59CB;&#x8D85;&#x8D8A;:<br>&#x8FD9;&#x8BF4;&#x660E;&#x57FA;&#x672C;&#x4E0A;, umap&#x7684;&#x6027;&#x80FD;&#x8D85;&#x8D8A;&#x6765;&#x81EA;&#x4E8E;page size&#x53EF;&#x4EE5;&#x4FEE;&#x6539;, &#x800C;&#x4E0D;&#x662F;&#x6765;&#x81EA;&#x4E8E;&#x5176;&#x672C;&#x8EAB;&#x7684;&#x6846;&#x67B6;. &#x56E0;&#x4E3A;userfaultfd&#x7684;&#x673A;&#x5236;&#x901A;&#x77E5;&#x7528;&#x6237;&#x6001;&#x672C;&#x8EAB;&#x5C31;&#x6709;&#x4E0D;&#x5C0F;&#x7684;overhead.<br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915081955.png" alt="">  </p>
<h3 id="sentry&#x7684;mm"><a name="sentry&#x7684;mm" class="anchor-navigation-ex-anchor" href="#sentry&#x7684;mm"><i class="fa fa-link" aria-hidden="true"></i></a>4.2.3. sentry&#x7684;mm</h3>
<p>&#x53C2;&#x8003;: <a href="https://xhfu.me/files/ad5e3bbbdb2e7f4dbb5dc19c121e89a9/cse291_project_final_report.pdf" target="_blank">https://xhfu.me/files/ad5e3bbbdb2e7f4dbb5dc19c121e89a9/cse291_project_final_report.pdf</a></p>
<p>&#x5BF9;sentry&#x6765;&#x8BF4;, app&#x7684;mmap&#x4F1A;&#x88AB;sentry&#x62E6;&#x622A;&#x5E76;&#x89E3;&#x6790;(&#x4F7F;&#x7528;ptrace&#x6216;kvm), &#x521B;&#x5EFA;sentry&#x7684;VMA&#x5230;&#x8FD9;&#x4E2A;file&#x7684;&#x6620;&#x5C04;, &#x7136;&#x540E;&#x4F7F;&#x7528;pgalloc&#x5305;&#x521B;&#x5EFA;&#x8FD9;&#x4E2A;file&#x5230;&#x4E00;&#x4E2A;host&#x4E34;&#x65F6;&#x6587;&#x4EF6;&#x7684;&#x6620;&#x5C04;:</p>
<ol>
<li>Create sentry VMA: Maps virtual address to offset of file in sentry (instead of host kernel). &lt;= createVMALocked()</li>
</ol>
<p>After triggered by a sentry page fault (VA accessed for 1st time)</p>
<ol>
<li>Create sentry filemap: pgalloc is used to map file and offset in sentry to file and offset on host. &lt;= getPMAsLocked()</li>
<li>Create host VMA: Maps virtual address from 1. to file and offset on host from 2. by calling the host mmap syscall. &lt;= mapASLocked()</li>
</ol>
<p>After triggered by a host page fault (VA acessed for 2nd time)</p>
<ol>
<li>Create host filemap: Maps file and offset on host to physical address.</li>
<li>Create PTE: Maps virtual address from 1. to physical address from 4.</li>
</ol>
<h3 id="&#x6027;&#x80FD;&#x5BF9;&#x6BD4;"><a name="&#x6027;&#x80FD;&#x5BF9;&#x6BD4;" class="anchor-navigation-ex-anchor" href="#&#x6027;&#x80FD;&#x5BF9;&#x6BD4;"><i class="fa fa-link" aria-hidden="true"></i></a>4.2.4. &#x6027;&#x80FD;&#x5BF9;&#x6BD4;</h3>
<p><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915082023.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915082140.png" alt="">  </p>
<h2 id="netstask"><a name="netstask" class="anchor-navigation-ex-anchor" href="#netstask"><i class="fa fa-link" aria-hidden="true"></i></a>4.3. netstask</h2>
<p>netstask&#x662F;gvisor&#x7684;&#x7528;&#x6237;&#x6001;kernel sentry&#x7684;tcp/ip&#x534F;&#x8BAE;&#x6808;.
&#x4EE3;&#x7801;&#x5728;<a href="https://github.com/google/gvisor/tree/master/pkg/sentry/socket/netstack" target="_blank">https://github.com/google/gvisor/tree/master/pkg/sentry/socket/netstack</a></p>
<p>tcp/ip&#x534F;&#x8BAE;&#x6808;&#x7684;&#x6838;&#x5FC3;&#x5B9E;&#x73B0;&#x5728;<a href="https://github.com/google/gvisor/tree/master/pkg/tcpip" target="_blank">https://github.com/google/gvisor/tree/master/pkg/tcpip</a></p>
<p>gvisor&#x652F;&#x6301;NetworkSandbox&#x548C;NetworkHost: &#x524D;&#x8005;&#x662F;&#x9ED8;&#x8BA4;&#x7684;, &#x7528;&#x7684;&#x662F;gvisor&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684;&#x534F;&#x8BAE;&#x6808;; &#x540E;&#x8005;&#x662F;&#x76F4;&#x63A5;&#x4F7F;&#x7528;host&#x7684;syscall.</p>
<pre><code class="lang-go">const (
    // NetworkSandbox uses internal network stack, isolated from the host.
    NetworkSandbox NetworkType = iota

    // NetworkHost redirects network related syscalls to the host network.
    NetworkHost

    // NetworkNone sets up just loopback using netstack.
    NetworkNone
)
</code></pre>
<h2 id="pkgabilinux"><a name="pkgabilinux" class="anchor-navigation-ex-anchor" href="#pkgabilinux"><i class="fa fa-link" aria-hidden="true"></i></a>4.4. pkg/abi/linux</h2>
<p>&#x8FD9;&#x4E2A;&#x5305;&#x63D0;&#x4F9B;&#x4E86;&#x5F88;&#x591A;&#x7CFB;&#x7EDF;&#x7EA7;&#x5B8F;&#x5B9A;&#x4E49;, &#x7ED3;&#x6784;&#x4F53;&#x5B9A;&#x4E49;, &#x6309;&#x529F;&#x80FD;.go&#x6587;&#x4EF6;&#x6765;&#x7EC4;&#x7EC7;&#x7684;, &#x6BD4;&#x8F83;&#x6E05;&#x695A;, &#x76F8;&#x5BF9;&#x5168;&#x9762;, &#x6BD4;&#x5982;
mm.go ip.go fs.go epoll_arm64.go &#x7B49;&#x7B49;, &#x5F88;&#x591A;.</p>
<p>&#x4E0B;&#x9762;&#x662F;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;seccomp.go&#x7684;&#x4E3E;&#x4F8B;:</p>
<h3 id="pkgabilinuxseccompgo"><a name="pkgabilinuxseccompgo" class="anchor-navigation-ex-anchor" href="#pkgabilinuxseccompgo"><i class="fa fa-link" aria-hidden="true"></i></a>4.4.1. pkg/abi/linux/seccomp.go</h3>
<p>&#x770B;&#x8D77;&#x6765;&#x90FD;&#x662F;&#x624B;&#x52A8;&#x6839;&#x636E;&#x7CFB;&#x7EDF;&#x5934;&#x6587;&#x4EF6;&#x6574;&#x7406;&#x7684;, &#x6BD4;&#x5982;:</p>
<pre><code class="lang-go">// Seccomp constants taken from &lt;linux/seccomp.h&gt;.
const (
    SECCOMP_MODE_NONE   = 0
    SECCOMP_MODE_FILTER = 2

    SECCOMP_RET_ACTION_FULL = 0xffff0000
    SECCOMP_RET_ACTION      = 0x7fff0000
    SECCOMP_RET_DATA        = 0x0000ffff

    SECCOMP_SET_MODE_FILTER   = 1
    SECCOMP_FILTER_FLAG_TSYNC = 1
    SECCOMP_GET_ACTION_AVAIL  = 2
)

// BPFAction is an action for a BPF filter.
type BPFAction uint32

// BPFAction definitions.
const (
    SECCOMP_RET_KILL_PROCESS BPFAction = 0x80000000
    SECCOMP_RET_KILL_THREAD  BPFAction = 0x00000000
    SECCOMP_RET_TRAP         BPFAction = 0x00030000
    SECCOMP_RET_ERRNO        BPFAction = 0x00050000
    SECCOMP_RET_TRACE        BPFAction = 0x7ff00000
    SECCOMP_RET_ALLOW        BPFAction = 0x7fff0000
)
</code></pre>
<h2 id="pkghostarchhostarchgo"><a name="pkghostarchhostarchgo" class="anchor-navigation-ex-anchor" href="#pkghostarchhostarchgo"><i class="fa fa-link" aria-hidden="true"></i></a>4.5. pkg/hostarch/hostarch.go</h2>
<p>host&#x53EA;&#x4F9D;&#x8D56;&#x6807;&#x51C6;&#x5E93;<code>&quot;encoding/binary&quot;</code>&#x548C;unix&#x7CFB;&#x7EDF;&#x5E93;<code>&quot;golang.org/x/sys/unix&quot;</code>, &#x5B83;&#x63CF;&#x8FF0;&#x4E86;host&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;<br>host&#x5305;&#x5F88;&#x7B80;&#x5355;, &#x4E3B;&#x8981;&#x662F;pagesize, &#x76EE;&#x524D;&#x53EA;&#x652F;&#x6301;4K&#x7684;&#x9875;.</p>
<pre><code class="lang-go">func init() {
    // Make sure the page size is 4K on arm64 platform.
    if size := unix.Getpagesize(); size != PageSize {
        panic(&quot;Only 4K page size is supported on arm64!&quot;)
    }
}
</code></pre>
<p>&#x8FD8;&#x6709;rwx&#x7684;&#x8BFB;&#x5199;&#x6267;&#x884C;&#x7684;&#x5C5E;&#x6027;&#x5B9A;&#x4E49;.</p>
<h2 id="pkgseccompseccompgo"><a name="pkgseccompseccompgo" class="anchor-navigation-ex-anchor" href="#pkgseccompseccompgo"><i class="fa fa-link" aria-hidden="true"></i></a>4.6. pkg/seccomp/seccomp.go</h2>
<p>seccomp&#x7528;&#x4E8E;&#x4EA7;&#x751F;seccomp filter. &#x770B;&#x8D77;&#x6765;&#x662F;&#x7528;&#x7684;&#x6BD4;&#x8F83;&#x539F;&#x59CB;&#x7684;bpf&#x6C47;&#x7F16;.</p>
<h2 id="pkgsentryarcharchgo"><a name="pkgsentryarcharchgo" class="anchor-navigation-ex-anchor" href="#pkgsentryarcharchgo"><i class="fa fa-link" aria-hidden="true"></i></a>4.7. pkg/sentry/arch/arch.go</h2>
<p>&#x4F9D;&#x8D56;</p>
<pre><code class="lang-go">    &quot;gvisor.dev/gvisor/pkg/abi/linux&quot;
    &quot;gvisor.dev/gvisor/pkg/cpuid&quot;
    &quot;gvisor.dev/gvisor/pkg/hostarch&quot;
    &quot;gvisor.dev/gvisor/pkg/log&quot;
    &quot;gvisor.dev/gvisor/pkg/marshal&quot;
    &quot;gvisor.dev/gvisor/pkg/sentry/arch/fpu&quot;
    &quot;gvisor.dev/gvisor/pkg/sentry/limits&quot;
</code></pre>
<p>arch&#x76EE;&#x524D;&#x652F;&#x6301;amd64&#x548C;arm64, &#x91CC;&#x9762;&#x5B9A;&#x4E49;&#x4E86;&#x4E0A;&#x4E0B;&#x6587;&#x7684;&#x63A5;&#x53E3;, &#x7528;&#x63A5;&#x53E3;&#x6765;&#x62BD;&#x8C61;:</p>
<blockquote>
<p>Context provides architecture-dependent information for a specific thread.</p>
</blockquote>
<p>&#x6BCF;&#x4E2A;&#x7EBF;&#x7A0B;&#x90FD;&#x6709;&#x4E2A;context, &#x91CC;&#x9762;&#x6709;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x76F8;&#x5173;&#x7684;, &#x6808;&#x76F8;&#x5173;&#x7684;, &#x5BC4;&#x5B58;&#x5668;&#x6062;&#x590D;&#x76F8;&#x5173;&#x7684;.
&#x4E3A;&#x4E86;&#x901A;&#x7528;&#x6027;, &#x503C;&#x90FD;&#x7528;<code>uintptr</code>&#x6765;&#x8868;&#x793A;, &#x6BD4;&#x5982;:</p>
<pre><code class="lang-go">type SyscallArgument struct {
    // Prefer to use accessor methods instead of &apos;Value&apos; directly.
    Value uintptr
}

// SyscallArguments represents the set of arguments passed to a syscall.
type SyscallArguments [6]SyscallArgument
</code></pre>
<p>context&#x6709;&#x4E2A;&#x65B9;&#x6CD5;, get&#x548C;set&#x6240;&#x6709;&#x5BC4;&#x5B58;&#x5668;</p>
<pre><code>    // PtraceGetRegs implements ptrace(PTRACE_GETREGS) by writing the
    // general-purpose registers represented by this Context to dst and
    // returning the number of bytes written.
    PtraceGetRegs(dst io.Writer) (int, error)

    // PtraceSetRegs implements ptrace(PTRACE_SETREGS) by reading
    // general-purpose registers from src into this Context and returning the
    // number of bytes read.
    PtraceSetRegs(src io.Reader) (int, error)
</code></pre><p>&#x5BC4;&#x5B58;&#x5668;&#x6709;&#x7EDF;&#x4E00;&#x7684;&#x62BD;&#x8C61;
&#x6BD4;&#x5982;<code>pkg/sentry/arch/arch_aarch64.go</code>&#x4E2D;, &#x5B9A;&#x4E49;&#x7684;&#x5BC4;&#x5B58;&#x5668;:</p>
<pre><code class="lang-go">// State contains the common architecture bits for aarch64 (the build tag of this
// file ensures it&apos;s only built on aarch64).
//
// +stateify savable
type State struct {
    // The system registers.
    Regs Registers

    // Our floating point state.
    fpState fpu.State `state:&quot;wait&quot;`

    // FeatureSet is a pointer to the currently active feature set.
    FeatureSet *cpuid.FeatureSet

    // OrigR0 stores the value of register R0.
    OrigR0 uint64
}
</code></pre>
<p>&#x6CE8;&#x610F;&#x8FD9;&#x91CC;&#x7684;<code>Registers</code>&#x5176;&#x5B9E;&#x7528;&#x7684;&#x662F;<code>linux.PtraceRegs</code></p>
<pre><code class="lang-go">// Registers represents the CPU registers for this architecture.
//
// +stateify savable
type Registers struct {
    linux.PtraceRegs

    // TPIDR_EL0 is the EL0 Read/Write Software Thread ID Register.
    TPIDR_EL0 uint64
}
</code></pre>
<p>&#x8FD9;&#x4E2A;<code>linux.PtraceRegs</code>&#x5728;<code>pkg/abi/linux/ptrace_arm64.go</code>&#x4E2D;&#x5B9A;&#x4E49;, &#x8FD9;&#x662F;&#x4E2A;&#x53EA;&#x5728;arm64&#x4E0A;&#x7F16;&#x8BD1;&#x7684;&#x6587;&#x4EF6;, &#x5C5E;&#x4E8E;linux abi&#x7684;&#x4E00;&#x90E8;&#x5206;.</p>
<pre><code class="lang-go">// PtraceRegs is the set of CPU registers exposed by ptrace. Source:
// syscall.PtraceRegs.
//
// +marshal
// +stateify savable
type PtraceRegs struct {
    Regs   [31]uint64
    Sp     uint64
    Pc     uint64
    Pstate uint64
}
</code></pre>
<p>&#x4E0A;&#x9762;&#x7684;<code>State</code>&#x5B9E;&#x73B0;&#x4E86;&#x90E8;&#x5206;context&#x63A5;&#x53E3;&#x7684;&#x51FD;&#x6570;, &#x88AB;<code>pkg/sentry/arch/arch_arm64.go</code>&#x7684;<code>context64</code>&#x4F7F;&#x7528;:</p>
<pre><code class="lang-go">// context64 represents an ARM64 context.
//
// +stateify savable
type context64 struct {
    State
    sigFPState []fpu.State // fpstate to be restored on sigreturn.
}
</code></pre>
<p>&#x8FD9;&#x4E2A;<code>context64</code>&#x5C31;&#x5B9E;&#x73B0;&#x4E86;&#x5168;&#x90E8;&#x7684;context&#x8981;&#x6C42;&#x7684;&#x63A5;&#x53E3;, &#x8FD9;&#x8981;&#x6C42;&#x6709;&#x5BF9;&#x5E95;&#x5C42;&#x5BC4;&#x5B58;&#x5668;&#x7684;ABI&#x7684;&#x77E5;&#x8BC6;, &#x6BD4;&#x5982;:</p>
<pre><code>// General purpose registers usage on Arm64:
// R0...R7: parameter/result registers.
// R8: indirect result location register.
// R9...R15: temporary rgisters.
// R16: the first intra-procedure-call scratch register.
// R17: the second intra-procedure-call scratch register.
// R18: the platform register.
// R19...R28: callee-saved registers.
// R29: the frame pointer.
// R30: the link register.
</code></pre><h2 id="kernel"><a name="kernel" class="anchor-navigation-ex-anchor" href="#kernel"><i class="fa fa-link" aria-hidden="true"></i></a>4.8. kernel</h2>
<p><code>package kernel</code>&#x91CC;&#x9762;&#x5B9E;&#x73B0;&#x4E86;&#x57FA;&#x7840;&#x7684;&#x5185;&#x6838;&#x7EC4;&#x4EF6;: task &#x8C03;&#x5EA6; signal&#x7B49;&#x7B49;...</p>
<p><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915082340.png" alt="">  </p>
<p>&#x6807;&#x51C6;&#x7684;kernel&#x7684;&#x8C03;&#x5EA6;&#x5BF9;&#x8C61;&#x662F;&#x7EBF;&#x7A0B;, &#x800C;gvisor&#x7684;&#x8C03;&#x5EA6;&#x5BF9;&#x8C61;&#x662F;goroutine
&#x5728;&#x6807;&#x51C6;&#x7684;kernel&#x4E0B;, &#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x5728;&#x5982;&#x4E0B;&#x60C5;&#x51B5;&#x4E0B;&#x88AB;&#x8C03;&#x5EA6;&#x51FA;&#x53BB;:</p>
<ul>
<li>&#x7EBF;&#x7A0B;&#x81EA;&#x5DF1;&#x8BA9;&#x51FA;&#x6267;&#x884C;, &#x6216;&#x88AB;&#x62A2;&#x5360;, &#x7EBF;&#x7A0B;&#x4ECD;&#x7136;runnable, &#x4F46;&#x5DF2;&#x7ECF;&#x4E0D;&#x5728;&#x6267;&#x884C;</li>
<li>&#x7EBF;&#x7A0B;&#x9000;&#x51FA;. sentry&#x91CC;&#x9762;, &#x4ECE;<code>Task.run</code>&#x91CC;&#x9000;&#x51FA;&#x5C31;&#x53EF;&#x4EE5;&#x4E86;</li>
<li>&#x7EBF;&#x7A0B;&#x8FDB;&#x5165;&#x53EF;&#x6253;&#x65AD;&#x7684;sleep, &#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x88AB;&#x81EA;&#x5DF1;&#x5524;&#x9192;&#x6216;&#x6536;&#x5230;&#x4FE1;&#x53F7;. sentry&#x91CC;&#x9762;&#x662F;&#x7528;blocking&#x8FD9;&#x4E2A;&#x6A21;&#x5F0F;, &#x6240;&#x6709;&#x4E8B;&#x4EF6;block&#x5728;go channel&#x7684;select, &#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x88AB;&#x6253;&#x65AD;. &#x5728;<code>task_block.go</code></li>
<li>&#x7EBF;&#x7A0B;&#x8FDB;&#x5165;&#x4E0D;&#x53EF;&#x6253;&#x65AD;&#x7684;&#x7761;&#x7720;, &#x53EA;&#x6709;&#x7528;&#x6237;&#x81EA;&#x5DF1;&#x5B9A;&#x4E49;&#x7684;wakeup&#x6761;&#x4EF6;&#x8FBE;&#x5230;&#x624D;&#x80FD;&#x5524;&#x9192;.</li>
</ul>
<p>&#x5927;&#x4F53;&#x4E0A;, sentry&#x8FD8;&#x662F;&#x7528;&#x4E86;checkpoints&#x6280;&#x672F;&#x5728;&#x5173;&#x952E;&#x70B9;&#x8BBE;&#x7F6E;&#x8C03;&#x5EA6;&#x4EE3;&#x7801;.</p>
<h3 id="task&#x7684;&#x72B6;&#x6001;&#x673A;"><a name="task&#x7684;&#x72B6;&#x6001;&#x673A;" class="anchor-navigation-ex-anchor" href="#task&#x7684;&#x72B6;&#x6001;&#x673A;"><i class="fa fa-link" aria-hidden="true"></i></a>4.8.1. task&#x7684;&#x72B6;&#x6001;&#x673A;</h3>
<p><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915082358.png" alt="">  </p>
<h2 id="runsc-boot&#x6D41;&#x7A0B;"><a name="runsc-boot&#x6D41;&#x7A0B;" class="anchor-navigation-ex-anchor" href="#runsc-boot&#x6D41;&#x7A0B;"><i class="fa fa-link" aria-hidden="true"></i></a>4.9. runsc boot&#x6D41;&#x7A0B;</h2>
<p>&#x6BD4;&#x5982;&#x5982;&#x4E0B;&#x547D;&#x4EE4;:
<code>docker run --cpus=2 -m 2g --rm --runtime=runsc -it --name=test centos:7 bash</code>
&#x4F1A;&#x5BFC;&#x81F4;<code>containerd-shim</code>&#x8C03;&#x7528;<code>runsc boot</code>&#x547D;&#x4EE4;</p>
<pre><code class="lang-sh">runsc --root=/var/run/docker/runtime-runsc/moby --debug=true  --log=/run/containerd/io.containerd.runtime.v1.linux/moby/8142acd62c66b0847eddee55c7c247a05a04e91b0e4a0db2c6942075ceb75f2e/log.json --log-format=json --debug-log=/tmp/runsc/ --platform=kvm --strace=true --log-fd=3 --debug-log-fd=4 boot --bundle=/run/containerd/io.containerd.runtime.v1.linux/moby/8142acd62c66b0847eddee55c7c247a05a04e91b0e4a0db2c6942075ceb75f2e --controller-fd=5 --mounts-fd=6 --spec-fd=7 --start-sync-fd=8 --io-fds=9 --io-fds=10 --io-fds=11 --io-fds=12 --device-fd=13 --pidns=true --setup-root --stdio-fds=14 --stdio-fds=15 --stdio-fds=16 --cpu-num 24 --total-memory76005576704 8142acd62c66b0847eddee55c7c247a05a04e91b0e4a0db2c6942075ceb75f2e]
</code></pre>
<ul>
<li>kernel&#x5C31;&#x662F;<code>runsc boot</code>&#x8FDB;&#x7A0B;, &#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x4E5F;&#x53EB;sandbox&#x8FDB;&#x7A0B;</li>
<li>&#x6BD4;&#x5982;&#x5728;vm&#x91CC;ls&#x6216;&#x8005;ps, &#x7528;&#x6237;&#x7A0B;&#x5E8F;&#x4EE3;&#x7801;&#x6BB5;&#x4F1A;&#x88AB;map&#x5230;<code>runsc boot</code>&#x8FDB;&#x7A0B;&#x7A7A;&#x95F4;, &#x7528;<code>pmap</code>&#x80FD;&#x770B;&#x5230;<ul>
<li>&#x6240;&#x6709;&#x7528;&#x6237;&#x6001;&#x7A0B;&#x5E8F;&#x90FD;&#x662F;&#x7528;goroutine&#x8FD0;&#x884C;&#x7684;</li>
<li>&#x6240;&#x6709;&#x7684;&#x7528;&#x6237;&#x6001;&#x7A0B;&#x5E8F;&#x90FD;&#x662F;&#x5728;<code>runsc boot</code>&#x8FDB;&#x7A0B;&#x7A7A;&#x95F4;&#x7684;, &#x5BF9;host&#x6765;&#x8BF4;&#x90FD;&#x662F;&#x4E00;&#x4E2A;<code>runsc boot</code>&#x8FDB;&#x7A0B;, &#x5982;&#x679C;&#x770B;CPU&#x5360;&#x7528;&#x7387;&#x5C31;&#x4F1A;&#x770B;&#x5230;&#x90FD;&#x662F;<code>runsc boot</code>&#x8FDB;&#x7A0B;&#x5728;&#x5360;&#x7528;CPU.</li>
<li>KVM&#x7684;platform&#x7684;&#x5185;&#x5B58;&#x6620;&#x5C04;&#x7684;&#x6838;&#x5FC3;&#x903B;&#x8F91;&#x662F;&#x901A;&#x8FC7;kVM&#x7684;KVM_SET_USER_MEMORY_REGION
&#x6765;&#x914D;&#x7F6E;VM&#x7684;PA&#x5230;host&#x8FDB;&#x7A0B;&#x7684;VA, &#x4F7F;&#x5F97;VM&#x7684;VA&#x88AB;map&#x5230;host&#x8FDB;&#x7A0B;&#x7684;&#x5BF9;&#x5E94;VA, &#x4ECE;&#x800C;&#x4F7F;&#x7528;host&#x8FDB;&#x7A0B;&#x7684;PA.</li>
</ul>
</li>
</ul>
<p>&#x6BD4;&#x5982;&#x5728;VM&#x91CC;&#x9762;&#x6267;&#x884C;<code>ls</code>&#x547D;&#x4EE4;, kernel(&#x5373;<code>runsc boot</code>)&#x53D1;&#x73B0;&#x662F;syscall&#x7684;exec, &#x6240;&#x4EE5;&#x9000;&#x51FA;VM, &#x5728;host&#x8FDB;&#x7A0B;
&#x7A7A;&#x95F4;load&#x8FD9;&#x4E2A;<code>ls</code>&#x7684;elf, &#x505A;&#x597D;memory&#x6620;&#x5C04;</p>
<pre><code class="lang-go">//runsc boot: launch a sandbox process
//@runsc/cli/main.go
Main()
  //@runsc/cmd/boot.go
  (b *Boot) Execute()
    //Setting up sandbox chroot in &quot;/tmp&quot;
    setUpChroot()
      //&#x539F;&#x7406;&#x4E0A;&#x662F;&#x8C03;&#x7528;unix.Mount()&#x51C6;&#x5907;chroot&#x7684;&#x76EE;&#x5F55;, &#x6BD4;&#x5982;/tmp /proc&#x7B49;
      //&#x7136;&#x540E;&#x8C03;&#x7528;pivot_root&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x505A;chroot
      pivotRoot(&quot;/tmp&quot;)
    //&#x4F7F;&#x7528;controller-fd mounts-fd spec-fd start-sync-fd io-fds io-fds device-fd&#x548C;&#x4E0A;&#x5C42;&#x4EA4;&#x4E92;
    //&#x4F7F;&#x7528;&#x4E0A;&#x9762;&#x7684;&#x4FE1;&#x606F;Create the loader.
    bootArgs := boot.Args{
      ID:             f.Arg(0),
      Spec:           spec,
      Conf:           conf,
      ControllerFD:   b.controllerFD,
      Device:         os.NewFile(uintptr(b.deviceFD), &quot;platform device&quot;),
      GoferFDs:       b.ioFDs.GetArray(),
      StdioFDs:       b.stdioFDs.GetArray(),
      NumCPU:         b.cpuNum,
      TotalMem:       b.totalMem,
      UserLogFD:      b.userLogFD,
      ProfileBlockFD: b.profileBlockFD,
      ProfileCPUFD:   b.profileCPUFD,
      ProfileHeapFD:  b.profileHeapFD,
      ProfileMutexFD: b.profileMutexFD,
      TraceFD:        b.traceFD,
    }
    //&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;kvm&#x7C7B;&#x578B;&#x7684;VM&#x505A;&#x4E3A;flatform, &#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x4E34;&#x65F6;&#x6587;&#x4EF6;&#x505A;&#x4E3A;backed memory file
    //map VDSO, &#x65B0;&#x5EFA;&#x4E00;&#x4E2A;timekeeper, &#x65B0;&#x5EFA;rootNetwork, &#x6CE8;&#x518C;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;, &#x4F5C;&#x4E3A;kernel
    //&#x7528;&#x4E0A;&#x9762;&#x7684;kernel&#x505A;&#x4E00;&#x4E2A;loader, &#x542F;&#x52A8;service&#x54CD;&#x5E94;socket&#x7684;control&#x8BF7;&#x6C42;
    l, err := boot.New(bootArgs) // l&#x662F;loader
      //createPlatform&#x5728;kvm&#x5B9E;&#x73B0;&#x4E0B;&#x662F;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;vm
      //&#x5728;Restore&#x6D41;&#x7A0B;&#x91CC;&#x4E5F;&#x4F1A;&#x8C03;&#x7528;createPlatform, &#x4ECE;&#x5F53;&#x524D;&#x7684;kernel&#x6062;&#x590D;&#x5230;&#x65B0;&#x5EFA;&#x7684;kernel
      //@runsc/boot/loader.go
      p, err := createPlatform(args.Conf, args.Device)
        p, err := platform.Lookup(&quot;kvm&quot;)
        //&#x8FD9;&#x91CC;&#x662F;kvm&#x7684;New
        //@pkg/sentry/platform/kvm/kvm.go
        p.New(deviceFile)
          updateGlobalOnce()
            updateSystemValues(int(fd))
              sz, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(fd), _KVM_GET_VCPU_MMAP_SIZE, 0)
              runDataSize = int(sz)
              hasGuestPCID = true
            //@pkg/ring0/lib_arm64.go
            ring0.Init() //&#x76EE;&#x524D;&#x4E3A;&#x7A7A;
            physicalInit()
              //&#x91CD;&#x8981;&#x5168;&#x5C40;&#x53D8;&#x91CF;, &#x8BB0;&#x5F55;&#x4E86;&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x72B6;&#x6001;&#x4E0B;&#x7684;VA&#x548C;&#x865A;&#x62DF;&#x7269;&#x7406;&#x5730;&#x5740;(&#x6216;&#x8005;&#x53EB;IPA)&#x7684;&#x6620;&#x5C04;.
              //&#x628A;host&#x7A7A;&#x95F4;&#x7528;mmap&#x586B;&#x6EE1;
              physicalRegions = computePhysicalRegions(fillAddressSpace())
          //ioctl&#x521B;&#x5EFA;&#x4E00;&#x4E2A;vm    
          vm, _, errno = unix.Syscall(unix.SYS_IOCTL, fd, _KVM_CREATE_VM, 0)
          //@pkg/sentry/platform/kvm/machine.go
          machine, err := newMachine(int(vm))
            m := &amp;machine{fd: vm}
            maxVCPUs, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CHECK_EXTENSION, _KVM_CAP_MAX_VCPUS)
            m.vCPUsByTID = make(map[uint64]*vCPU)
            m.vCPUsByID = make([]*vCPU, m.maxVCPUs)
            //&#x8FD9;&#x4E2A;kernel&#x4E0D;&#x662F;kernel.Kernel, &#x800C;&#x662F;ring0.kernel, &#x662F;&#x7ED9;kvm&#x7528;&#x7684;
            m.kernel.Init(m.maxVCPUs) //24&#x4E2A;&#x6838;&#x662F;24&#x4E2A;VCPU
            maxSlots, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CHECK_EXTENSION, _KVM_CAP_MAX_MEMSLOTS) //509&#x4E2A;
            hasTSCControl, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CHECK_EXTENSION, _KVM_CAP_TSC_CONTROL) //&#x6211;&#x8FD9;&#x91CC;&#x662F;false
            // Create the upper shared pagetables and kernel(sentry) pagetables.
            m.upperSharedPageTables = pagetables.New(newAllocator())
            m.mapUpperHalf(m.upperSharedPageTables)
            m.upperSharedPageTables.Allocator.(*allocator).base.Drain()
            m.upperSharedPageTables.MarkReadOnlyShared()
            m.kernel.PageTables = pagetables.NewWithUpper(newAllocator(), m.upperSharedPageTables, ring0.KernelStartAddress)
            // &#x914D;&#x7F6E;seccomp&#x4E3A;trap mmap, &#x5176;&#x4ED6;allow; mmap&#x4F1A;&#x89E6;&#x53D1;SIGSYS&#x4FE1;&#x53F7;
            seccompMmapRules(m)
            // Map everything in the lower half.
            //&#x5373;physicalRegions&#x91CC;&#x7684;&#x6BCF;&#x4E2A;region&#x90FD;&#x751F;&#x6210;&#x4E00;&#x4E2A;PTE(page table entry), &#x90FD;&#x5728;lower half
            m.kernel.PageTables.Map()
            // &#x628A;&#x5F53;&#x524D;host&#x8FDB;&#x7A0B;&#x5DF2;&#x7ECF;map&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7A7A;&#x95F4;(&quot;/proc/self/maps&quot;)&#x6620;&#x5C04;&#x8FDB;VM
            for line in open(&quot;/proc/self/maps&quot;)
              if vr.accessType.Execute
                //&#x6709;&#x4EE3;&#x7801;&#x88AB;&#x52A0;&#x5230;VM&#x7684;&#x9875;&#x8868;
                m.kernel.PageTables.Map() 
              m.mapPhysical(physical, length, physicalRegions)
                // &#x7528;KVM&#x7684;SET_USER_MEMORY_REGION ioctl&#x6765;&#x914D;&#x7F6E;kvm&#x7684;&#x7B2C;&#x4E8C;&#x6B21;&#x7FFB;&#x8BD1;
                // map host va&#x548C;VM pa
                handleBluepillFault(m, physical, phyRegions)
                  virtualStart, physicalStart, length, pr := calculateBluepillFault(physical, phyRegions)
                  m.setMemoryRegion(int(slot), physicalStart, length, virtualStart, flags)
                    unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_SET_USER_MEMORY_REGION, uintptr(unsafe.Pointer(&amp;userRegion)))
            //@pkg/sentry/platform/kvm/machine_arm64_unsafe.go      
            m.initArchState()
              unix.RawSyscall(_KVM_ARM_PREFERRED_TARGET)
              for maxVCPU //&#x5BF9;&#x6BCF;&#x4E2A;vCPU
                //@pkg/sentry/platform/kvm/machine.go
                m.createVCPU(i)
                  //KVM ioctl _KVM_CREATE_VCPU
                  fd, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CREATE_VCPU, uintptr(id))
                  c := &amp;vCPU{
                    id:      id,
                    fd:      int(fd),
                    machine: m,
                  }
                  c.CPU.Init(&amp;m.kernel, c.id, c)
                    // Set the kernel stack pointer(virtual address).
                    c.registers.Sp = uint64(c.StackTop()) //&#x8FD9;&#x4E2A;kernel&#x7684;stack&#x662F;&#x7ED9;&#x4E2D;&#x65AD;&#x7528;&#x7684;
                  m.vCPUsByID[c.id] = c
                  c.setSignalMask()
                    //Defines which signals are blocked during execution of KVM_RUN
                    //&#x6309;&#x7406;&#x8BF4;&#x5E94;&#x8BE5;&#x662F;&#x6BCF;&#x4E2A;&#x7EBF;&#x7A0B;&#x6765;&#x914D;&#x7F6E;, &#x4F46;&#x8FD9;&#x91CC;&#x6CA1;&#x6709;&#x5F00;&#x65B0;go routine
                    unix.RawSyscall(_KVM_SET_SIGNAL_MASK)
                  //runData&#x662F;mmap&#x6765;&#x7684;, &#x662F;&#x7528;&#x6237;&#x6001;&#x548C;KVM&#x4EA4;&#x4E92;&#x7528;&#x7684;
                  runData, err := mapRunData(int(fd))
                  c.runData = runData
                  //@pkg/sentry/platform/kvm/machine_arm64_unsafe.go
                  c.initArchState()
                    //KVM_ARM_VCPU_INIT&#x4F1A;&#x628A;cpu&#x91CD;&#x7F6E;&#x4E3A;&#x521D;&#x59CB;&#x503C;. &#x5982;&#x679C;&#x6CA1;&#x6709;&#x8FD9;&#x4E00;&#x6B65;, KVM_RUN&#x5C31;&#x4F1A;&#x9519;&#x8BEF;
                    unix.RawSyscall(_KVM_ARM_VCPU_INIT)
                    //&#x7528;setOneRegister()&#x8BBE;&#x7F6E;&#x5982;&#x4E0B;&#x5BC4;&#x5B58;&#x5668;:
                    //tcr_el1: Translation Control Register
                    //mair_el1: Multiprocessor Affinity Register
                    //ttbr0_el1: &#x7528;&#x6237;&#x6001;&#x9875;&#x8868;&#x57FA;&#x5730;&#x5740;, &#x8FD9;&#x91CC;&#x5BF9;&#x5E94;sentry, &#x4EE3;&#x7801;&#x91CC;&#x4E5F;&#x5BF9;&#x5E94;c.SetTtbr0Kvm(uintptr(data))
                    //ttbr1_el1: &#x5185;&#x6838;&#x6001;&#x9875;&#x8868;&#x57FA;&#x5730;&#x5740;, &#x8FD9;&#x91CC;&#x662F;upper&#x7A7A;&#x95F4;
                    //sp_el1: &#x5185;&#x6838;&#x6001;&#x7684;sp, &#x5904;&#x7406;&#x4E2D;&#x65AD;&#x7684;
                    //pc: &#x521D;&#x59CB;&#x6307;&#x5411;ring0.Start()
                    //r8: r8&#x662F;platform&#x4E13;&#x7528;&#x5BC4;&#x5B58;&#x5668;, &#x6307;&#x5411;c.CPU
                    //vbar_el1: &#x5F02;&#x5E38;vector&#x57FA;&#x5730;&#x5740;, &#x662F;ring0.Vectors, &#x8FD9;&#x662F;&#x4EE3;&#x7801;&#x6BB5;

                  //&#x7ED9;&#x8FD9;&#x4E2A;vCPU&#x8BBE;&#x7F6E;&#x65F6;&#x95F4;
                  //&#x5728;arm64&#x4E0A;&#x662F;setOneRegister _KVM_ARM64_REGS_TIMER_CNT
                  c.setSystemTime()

            // m&#x4EE3;&#x8868;&#x7684;machine&#x662F;&#x5783;&#x573E;&#x56DE;&#x6536;&#x7684;, &#x7528;SetFinalizer&#x673A;&#x5236;&#x6765;&#x8C03;&#x7528;m.Destroy&#x6E05;&#x7406;
            runtime.SetFinalizer(m, (*machine).Destroy)

      //&#x8FD9;&#x91CC;new&#x4E00;&#x4E2A;kernel.Kernel, &#x5305;&#x62EC;&#x4E86;&#x4E00;&#x4E2A;&#x65B0;&#x5EFA;&#x7684;kvm platform&#x7684;&#x5B9E;&#x4F8B;
      k := &amp;kernel.Kernel{
        Platform: p,
      }

      //&#x4F7F;&#x7528;&#x4E00;&#x4E2A;&#x53EB;&quot;runsc-memory&quot;&#x7684;&#x4E34;&#x65F6;&#x6587;&#x4EF6;&#x505A;&#x4E3A;backed memory file
      mf, err := createMemoryFile()
        memfd, err := memutil.CreateMemFD(&quot;runsc-memory&quot;, 0)
        memfile := os.NewFile(uintptr(memfd), memfileName)
        //@pkg/sentry/pgalloc/pgalloc.go
        mf, err := pgalloc.NewMemoryFile(memfile, pgalloc.MemoryFileOpts{})
      k.SetMemoryFile(mf)

      //VDSO
      vdso, err := loader.PrepareVDSO(k)
        //&#x8FD9;&#x4E2A;vdsodata.Binary&#x662F;&#x4E2A;&#x81EA;&#x52A8;&#x751F;&#x6210;&#x7684;[]byte&#x6570;&#x7EC4;
        //&#x597D;&#x50CF;&#x662F;&#x4ECE;vdso_bin&#x91CC;&#x8BFB;&#x51FA;&#x6765;&#x7684;
        //&#x5728;@pkg/sentry/loader/vdsodata/vdso_arm64.go
        vdsoFile := &amp;byteFullReader{data: vdsodata.Binary}
        //&#x68C0;&#x6D4B;VDSO&#x7684;elf&#x5934;, &#x8FD4;&#x56DE;&#x4E00;&#x4E2A;elfInfo&#x7ED3;&#x6784;&#x4F53;
        info, err := validateVDSO(nil, vdsoFile, uint64(len(vdsodata.Binary)))
        size, ok := hostarch.Addr(len(vdsodata.Binary)).RoundUp()
        mf := mfp.MemoryFile()
        //&#x7ED9;VDSO&#x7533;&#x8BF7;&#x9875;
        vdso, err := mf.Allocate(uint64(size), pgalloc.AllocOpts{Kind: usage.System})
        ims, err := mf.MapInternal(vdso, hostarch.ReadWrite)
        _, err = safemem.CopySeq(ims, safemem.BlockSeqOf(safemem.BlockFromSafeSlice(vdsodata.Binary)))
        //&#x518D;&#x7533;&#x8BF7;&#x4E00;&#x4E2A;&#x53C2;&#x6570;&#x9875;
        paramPage, err := mf.Allocate(hostarch.PageSize, pgalloc.AllocOpts{Kind: usage.System})

      //&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;timekeeper. &#x5305;&#x62EC;Monotonic&#x548C;Realtime&#x4E24;&#x79CD;
      //@pkg/sentry/time/calibrated_clock.go
      tk := kernel.NewTimekeeper(k, vdso.ParamPage.FileRange())
      tk.SetClocks(time.NewCalibratedClocks())

      // Create root network namespace/stack.
      netns, err := newRootNetworkNamespace(args.Conf, tk, k)
        case config.NetworkHost:
          inet.NewRootNamespace(hostinet.NewStack(), nil)
        case config.NetworkNone, config.NetworkSandbox:
          s, err := newEmptySandboxNetworkStack(clock, uniqueID, conf.AllowPacketEndpointWrite)
          creator := &amp;sandboxNetstackCreator{
            clock:                    clock,
            uniqueID:                 uniqueID,
            allowPacketEndpointWrite: conf.AllowPacketEndpointWrite,
          }
          inet.NewRootNamespace(s, creator)

      // Create capabilities.
      caps, err := specutils.Capabilities(args.Conf.EnableRaw, args.Spec.Process.Capabilities)

      // Create credentials.
      creds := auth.NewUserCredentials(
        auth.KUID(args.Spec.Process.User.UID),
        auth.KGID(args.Spec.Process.User.GID),
        extraKGIDs,
        caps,
        auth.NewRootUserNamespace())

      //&#x521D;&#x59CB;&#x5316;kernel
      k.Init(kernel.InitKernelArgs{
        FeatureSet:                  cpuid.HostFeatureSet().Fixed(),
        Timekeeper:                  tk,
        RootUserNamespace:           creds.UserNamespace,
        RootNetworkNamespace:        netns,
        ApplicationCores:            uint(args.NumCPU),
        Vdso:                        vdso,
        RootUTSNamespace:            kernel.NewUTSNamespace(args.Spec.Hostname, args.Spec.Hostname, creds.UserNamespace),
        RootIPCNamespace:            kernel.NewIPCNamespace(creds.UserNamespace),
        RootAbstractSocketNamespace: kernel.NewAbstractSocketNamespace(),
        PIDNamespace:                kernel.NewRootPIDNamespace(creds.UserNamespace),
      })

      registerFilesystems(k)
      adjustDirentCache(k)

      procArgs, err := createProcessArgs(args.ID, args.Spec, creds, k, k.RootPIDNamespace())
      err := initCompatLogs(args.UserLogFD)
      mountHints, err := newPodMountHints(args.Spec)

      eid := execID{cid: args.ID}
      //loader&#x5305;&#x62EC;kernel.Kernel
      l := &amp;Loader{
        k:             k,
        watchdog:      dog,
        sandboxID:     args.ID,
        processes:     map[execID]*execProcess{eid: {}},
        mountHints:    mountHints,
        root:          info,
        stopProfiling: stopProfiling,
      }

      sighandling.IgnoreChildStop()

      //Create the control server using the provided FD.
      ctrl, err := newController(args.ControllerFD, l)
        ctrl := &amp;controller{}
        //&#x521B;&#x5EFA;&#x57FA;&#x4E8E;unix socket urpc server
        ctrl.srv, err = server.CreateFromFD(fd)
        //&#x6CE8;&#x518C;&#x63A7;&#x5236;&#x63A5;&#x53E3;
        ctrl.srv.Register(ctrl.manager)
        ctrl.srv.Register(net)
        ctrl.srv.Register(&amp;control.Events{})
        ctrl.srv.Register(&amp;control.Fs{Kernel: l.k})
        ctrl.srv.Register(&amp;control.Lifecycle{Kernel: l.k})
        ctrl.srv.Register(&amp;control.Logging{})
        ctrl.srv.Register(&amp;control.Usage{Kernel: l.k})
        ctrl.srv.Register(&amp;control.Proc{Kernel: l.k})
        ctrl.srv.Register(&amp;control.State{Kernel: l.k})
        ctrl.srv.Register(&amp;debug{})

      l.ctrl = ctrl
      //&#x8D77;&#x4E00;&#x4E2A;go routine accept socket&#x8FDE;&#x63A5;
      ctrl.srv.StartServing()

    //&#x901A;&#x77E5;&#x7236;&#x8FDB;&#x7A0B;sandbox&#x5DF2;&#x7ECF;&#x542F;&#x52A8;&#x5B8C;&#x6BD5;, &#x5DF2;&#x7ECF;&#x51C6;&#x5907;&#x597D;controller&#x670D;&#x52A1;
    // Wait for the start signal from runsc.
    //&#x7B49;&#x5F85;runsc&#x53D1;start&#x4FE1;&#x53F7;
    l.WaitForStartSignal()
    // Run runs the root container.
    // Run the application and wait for it to finish.
    l.Run()
      //installs sandbox seccomp filters with the host.
      l.installSeccompFilters()
      //&#x5982;&#x679C;&#x4E0D;&#x662F;restore&#x573A;&#x666F;, &#x5C31;&#x65B0;&#x8D77;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;load user mode&#x7A0B;&#x5E8F;
      // Create the root container init task. It will begin running
      // when the kernel is started.
      l.createContainerProcess(true, l.sandboxID, &amp;l.root)
        // Create the FD map, which will set stdin, stdout, and stderr.
        createFDTable(ctx, info.spec.Process.Terminal, info.stdioFDs, info.spec.Process.User)
        //&#x8D77;&#x4E00;&#x4E2A;&#x76D1;&#x6D4B;gofer&#x7684;routine
        l.startGoferMonitor(cid, int32(info.goferFDs[0].FD()))
        mntr := newContainerMounter(info, l.k, l.mountHints, kernel.VFS2Enabled)
        if root
          mntr.processHints(info.conf, info.procArgs.Credentials)
        //set up the file system for all containers
        //&#x5373;&#x6240;&#x6709;&#x7684;container&#x90FD;&#x770B;&#x5230;&#x540C;&#x4E00;&#x4EFD;/&#x76EE;&#x5F55;, mount&#x7684;&#x4FE1;&#x606F;&#x653E;&#x5728;&amp;info.procArgs
        setupContainerFS(ctx, info.conf, mntr, &amp;info.procArgs)
        //@pkg/sentry/kernel/kernel.go
        // CreateProcess creates a new task in a new thread group with the given
        // options. The new task has no parent and is in the root PID namespace.
        //&#x65B0;&#x7684;task&#x5728;root pid &#x7A7A;&#x95F4;&#x91CC;, &#x6CA1;&#x6709;parent 
        l.k.CreateProcess(info.procArgs)
          //&#x51C6;&#x5907;mount namespace
          //&#x5EFA;&#x4E00;&#x4E2A;&#x7A7A;&#x7684;thread group
          tg := k.NewThreadGroup(mntns, args.PIDNamespace, NewSignalHandlers(), linux.SIGCHLD, args.Limits)
          // Create a fresh task context.
          remainingTraversals := args.MaxSymlinkTraversals
          loadArgs := loader.LoadArgs{
            Opener:              opener,
            RemainingTraversals: &amp;remainingTraversals,
            ResolveFinal:        true,
            Filename:            args.Filename,
            File:                args.File,
            CloseOnExec:         false,
            Argv:                args.Argv,
            Envv:                args.Envv,
            Features:            k.featureSet,
          }
          // LoadTaskImage loads a specified file into a new TaskImage.
          //@pkg/sentry/kernel/task_image.go
          image, se := k.LoadTaskImage(ctx, loadArgs)
            //&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x7A7A;&#x7684;memoryManager with no mappings and 1 user
            //@pkg/sentry/mm/lifecycle.go
            m := mm.NewMemoryManager(k, k, k.SleepForAddressSpaceActivation)
            //@pkg/sentry/loader/loader.go
            //Load loads args.File into a MemoryManager.
            os, ac, name, err := loader.Load(ctx, args, k.extraAuxv, k.vdso)
              loaded, ac, file, newArgv, err := loadExecutable(ctx, args)
                //&#x770B;&#x6587;&#x4EF6;&#x5934;, &#x5206;elf(&quot;\x7fELF&quot;)&#x548C;script(&quot;#!&quot;)
                case &quot;\x7fELF&quot;:
                  // loadELF loads args.File into the Task address space.
                  //@pkg/sentry/loader/elf.go
                  loaded, ac, err := loadELF(ctx, args)
                    //&#x52A0;&#x8F7D;args.File&#x5230;args.MemoryManager, &#x5E95;&#x5C42;&#x8C03;&#x7528;MemoryManager.MMap&#x5EFA;&#x7ACB;&#x4E00;&#x4E2A;&#x5185;&#x5B58;&#x533A;&#x57DF;
                    bin, ac, err := loadInitialELF(ctx, args.MemoryManager, args.Features, args.File)
                    if &#x89E3;&#x91CA;&#x5668;
                      interp, err = loadInterpreterELF(ctx, args.MemoryManager, intFile, bin)

                case &quot;#!&quot;:
                  //&#x8FD4;&#x56DE;&#x89E3;&#x91CA;&#x5668;&#x7684;&#x8DEF;&#x5F84;
                  args.Filename, args.Argv, err = parseInterpreterScript(ctx, args.Filename, args.File, args.Argv)
            // Lookup our new syscall table.
            st, ok := LookupSyscallTable(os, ac.Arch())

          // Create the task.
          config := &amp;TaskConfig{
            Kernel:                  k,
            ThreadGroup:             tg,
            TaskImage:               image,
            FSContext:               fsContext,
            FDTable:                 args.FDTable,
            Credentials:             args.Credentials,
            NetworkNamespace:        k.RootNetworkNamespace(),
            AllowedCPUMask:          sched.NewFullCPUSet(k.applicationCores),
            UTSNamespace:            args.UTSNamespace,
            IPCNamespace:            args.IPCNamespace,
            AbstractSocketNamespace: args.AbstractSocketNamespace,
            MountNamespaceVFS2:      mntnsVFS2,
            ContainerID:             args.ContainerID,
            UserCounters:            k.GetUserCounters(args.Credentials.RealKUID),
          }
          t, err := k.tasks.NewTask(ctx, config)
            t, err := ts.newTask(cfg)
          t.traceExecEvent(image) // Simulate exec for tracing.
      l.watchdog.Start() //45s&#x5468;&#x671F;, 3m&#x8D85;&#x65F6;
      l.k.Start()
        k.started = true
        k.cpuClockTicker = ktime.NewTimer(k.timekeeper.monotonicClock, newKernelCPUClockTicker(k))
        k.cpuClockTicker.Swap(ktime.Setting{
          Enabled: true,
          Period:  linux.ClockTick,
        })
        // Start task goroutines.
        for t, tid := range k.tasks.Root.tids {
          t.Start(tid)
            //@pkg/sentry/kernel/task_run.go
            go t.run(uintptr(tid))
              // Activate our address space.
              t.Activate() //&#x8C03;&#x7528;platform&#x7684;NewAddressSpace()
              for
                t.doStop() //&#x7B49;&#x5F85;&#x4E0B;&#x4E00;&#x6B21;&#x8FD0;&#x884C;
                //&#x6CE8;&#x610F;&#x8FD9;&#x4E2A;&#x7ED3;&#x6784;, &#x4E00;&#x884C;&#x5C31;&#x652F;&#x6301;&#x72B6;&#x6001;&#x673A;&#x7684;&#x8FC1;&#x79FB;
                //&#x56E0;&#x4E3A;&#x591A;&#x4E2A;&#x72B6;&#x6001;&#x90FD;&#x6709;execute&#x51FD;&#x6570;, &#x6267;&#x884C;&#x540E;&#x8FD4;&#x56DE;&#x4E0B;&#x4E00;&#x4E2A;&#x72B6;&#x6001;
                //&#x4E0D;&#x540C;&#x7684;&#x72B6;&#x6001;:
                //runSyscallAfterPtraceEventClone
                //runSyscallAfterVforkStop
                //runSyscallAfterExecStop
                //runExit
                //runExitMain
                //runExitNotify
                //runApp
                //runInterrupt
                //runInterruptAfterSignalDeliveryStop
                //runSyscallAfterPtraceEventSeccomp
                //runSyscallAfterSyscallEnterStop
                //runSyscallAfterSysemuStop
                //runSyscallReinvoke
                //runSyscallExit
                //runVsyscallAfterPtraceEventSeccomp
                //&#x521D;&#x59CB;&#x72B6;&#x6001;&#x662F;(*runApp):
                t.runState = t.runState.execute(t)
                  if t.interrupted()
                    return (*runInterrupt)(nil) //&#x4E0B;&#x4E2A;&#x72B6;&#x6001;&#x662F;interrupt
                  //&#x5728;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x6001;&#x4E4B;&#x524D;, &#x6267;&#x884C;task work
                  if atomic.LoadInt32(&amp;t.taskWorkCount) &gt; 0
                    queue := t.taskWork
                    for _, work := range queue
                      work.TaskWork(t)
                  //&#x5904;&#x7406;&#x53EF;&#x80FD;&#x7684;SyscallReturn
                  //&#x5904;&#x7406;&#x53EF;&#x80FD;&#x7684;SavedSignalMask
                  //&#x8C03;&#x7528;platform&#x7684;switch
                  info, at, err := t.p.Switch(t, t.MemoryManager(), t.Arch(), t.rseqCPU)
                  switch err {
                  case nil:
                    return t.doSyscall() //&#x9ED8;&#x8BA4;&#x5C31;&#x662F;syscall
                  case platform.ErrContextInterrupt:
                    //&#x88AB;platform.Context.Interrupt()&#x6253;&#x65AD;
                    return (*runApp)(nil)
                  case platform.ErrContextSignal:
                    //&#x88AB;&#x4FE1;&#x53F7;&#x6253;&#x65AD;
                    t.MemoryManager().HandleUserFault() //&#x5904;&#x7406;&#x7528;&#x6237;pagefault
                    if &#x662F;&#x540C;&#x6B65;signal
                        t.SendSignal(info)
                    else
                        t.k.sendExternalSignal(info, &quot;application&quot;)
                    return (*runApp)(nil)
                  case platform.ErrContextCPUPreempted:
                    t.rseqPreempted = true
                    return (*runApp)(nil)
                  }
        }
    l.WaitExit()
    l.Destroy()
</code></pre>
<h2 id="platform"><a name="platform" class="anchor-navigation-ex-anchor" href="#platform"><i class="fa fa-link" aria-hidden="true"></i></a>4.10. platform</h2>
<p>kernel&#x5305;&#x62EC;&#x4E86;platform, &#x6BD4;&#x5982;&#x5728;&#x521D;&#x59CB;&#x5316;&#x7684;&#x65F6;&#x5019;:</p>
<pre><code class="lang-go">p, err := createPlatform(cm.l.root.conf, deviceFile)
//Kernel&#x5305;&#x62EC;platform
k := &amp;kernel.Kernel{
    Platform: p,
}
</code></pre>
<p>platform&#x62BD;&#x8C61;&#x4E86;&#x4E00;&#x4E2A;platform&#x7684;&#x80FD;&#x529B;, &#x4E3B;&#x8981;&#x662F;&#x63CF;&#x8FF0;&#x8C03;&#x5EA6;&#x80FD;&#x529B;, &#x5730;&#x5740;&#x7A7A;&#x95F4;&#x80FD;&#x529B;.
&#x6BD4;&#x5982;MemoryManager&#x662F;&#x5728;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x4E4B;&#x4E0A;&#x7684;&#x4E00;&#x79CD;&#x62BD;&#x8C61;:</p>
<pre><code class="lang-go">// MemoryManager represents an abstraction above the platform address space
// which manages memory mappings and their contents.
type MemoryManager interface {
    //usermem.IO provides access to the contents of a virtual memory space.
    usermem.IO
    // MMap establishes a memory mapping.
    MMap(ctx context.Context, opts memmap.MMapOpts) (hostarch.Addr, error)
    // AddressSpace returns the AddressSpace bound to mm.
    AddressSpace() AddressSpace
}
</code></pre>
<p>&#x5730;&#x5740;&#x7A7A;&#x95F4;</p>
<pre><code class="lang-go">// AddressSpace represents a virtual address space in which a Context can
// execute.
type AddressSpace interface {
    // MapFile creates a shared mapping of offsets fr from f at address addr.
    // Any existing overlapping mappings are silently replaced.
    //
    // If precommit is true, the platform should eagerly commit resources (e.g.
    // physical memory) to the mapping. The precommit flag is advisory and
    // implementations may choose to ignore it.
    //
    // Preconditions:
    // * addr and fr must be page-aligned.
    // * fr.Length() &gt; 0.
    // * at.Any() == true.
    // * At least one reference must be held on all pages in fr, and must
    //   continue to be held as long as pages are mapped.
    MapFile(addr hostarch.Addr, f memmap.File, fr memmap.FileRange, at hostarch.AccessType, precommit bool) error

    // Unmap unmaps the given range.
    //
    // Preconditions:
    // * addr is page-aligned.
    // * length &gt; 0.
    Unmap(addr hostarch.Addr, length uint64)

    // Release releases this address space. After releasing, a new AddressSpace
    // must be acquired via platform.NewAddressSpace().
    Release()

    // PreFork() is called before creating a copy of AddressSpace. This
    // guarantees that this address space will be in a consistent state.
    PreFork()

    // PostFork() is called after creating a copy of AddressSpace.
    PostFork()

    // AddressSpaceIO methods are supported iff the associated platform&apos;s
    // Platform.SupportsAddressSpaceIO() == true. AddressSpaces for which this
    // does not hold may panic if AddressSpaceIO methods are invoked.
    AddressSpaceIO
}
</code></pre>
<p>platform&#x5305;&#x62EC;&#x4E86;Context&#x62BD;&#x8C61;, &#x5305;&#x62EC;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;:</p>
<pre><code class="lang-go">// Switch resumes execution of the thread specified by the arch.Context
// in the provided address space. This call will block while the thread
// is executing.
// &#x6B63;&#x5E38;&#x5E94;&#x8BE5;&#x662F;&#x6210;&#x529F;&#x8C03;&#x7528;&#x4E00;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;.
// &#x5982;&#x679C;&#x6B63;&#x5728;&#x6267;&#x884C;&#x8FD9;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x65F6;&#x5019;&#x6709;signal, &#x8FD4;&#x56DE;ErrContextSignal
// &#x5982;&#x679C;&#x8C03;&#x7528;&#x4E86;Interrupt()&#x5219;&#x8FD4;&#x56DE;ErrContextInterrupt
Switch(ctx context.Context, mm MemoryManager, ac arch.Context, cpu int32) (*linux.SignalInfo, hostarch.AccessType, error)

// PullFullState() pulls a full state of the application thread.
PullFullState(as AddressSpace, ac arch.Context)

// Interrupt interrupts a concurrent call to Switch(), causing it to return
// ErrContextInterrupt.
Interrupt()

// Release() releases any resources associated with this context.
Release()
</code></pre>
<p>&#x6839;&#x636E;<code>g3doc/architecture_guide/platforms.md</code>, gvisor&#x9700;&#x8981;&#x5E73;&#x53F0;&#x5B9E;&#x73B0;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x62E6;&#x622A;, &#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;, &#x548C;memory map. &#x8FD9;&#x4E9B;&#x9700;&#x6C42;&#x662F;&#x4EE5;interface&#x7684;&#x5F62;&#x5F0F;&#x6765;&#x4F53;&#x73B0;&#x7684;:</p>
<pre><code class="lang-go">type Platform interface {
    NewAddressSpace() (AddressSpace, error)
    NewContext() Context
}

type Context interface {
    Switch(as AddressSpace, ac arch.Context) (..., error)
}

type AddressSpace interface {
    MapFile(addr hostarch.Addr, f File, fr FileRange, at hostarch.AccessType, ...) error
    Unmap(addr hostarch.Addr, length uint64)
}
</code></pre>
<p>&#x73B0;&#x5728;&#x6709;ptrace&#x65B9;&#x5F0F;&#x548C;KVM&#x65B9;&#x5F0F;: ptrace&#x65B9;&#x5F0F;&#x66F4;&#x901A;&#x7528;, &#x4F46;&#x6027;&#x80FD;&#x5DEE;; KVM&#x65B9;&#x5F0F;&#x9700;&#x8981;&#x786C;&#x4EF6;&#x865A;&#x62DF;&#x5316;&#x652F;&#x6301;, &#x6027;&#x80FD;&#x597D;&#x70B9;.</p>
<h2 id="&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;switch"><a name="&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;switch" class="anchor-navigation-ex-anchor" href="#&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;switch"><i class="fa fa-link" aria-hidden="true"></i></a>4.11. &#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;Switch()</h2>
<p>&#x662F;kernel&#x8C03;&#x7684;:
&#x5728;<code>pkg/sentry/kernel/task_run.go</code></p>
<pre><code class="lang-go">// run runs the task goroutine.
//
// threadID a dummy value set to the task&apos;s TID in the root PID namespace to
// make it visible in stack dumps. A goroutine for a given task can be identified
// searching for Task.run()&apos;s argument value.
func (t *Task) run(threadID uintptr) {
    atomic.StoreInt64(&amp;t.goid, goid.Get())

    // Construct t.blockingTimer here. We do this here because we can&apos;t
    // reconstruct t.blockingTimer during restore in Task.afterLoad(), because
    // kernel.timekeeper.SetClocks() hasn&apos;t been called yet.
    blockingTimerNotifier, blockingTimerChan := ktime.NewChannelNotifier()
    t.blockingTimer = ktime.NewTimer(t.k.MonotonicClock(), blockingTimerNotifier)
    defer t.blockingTimer.Destroy()
    t.blockingTimerChan = blockingTimerChan

    // Activate our address space.
    t.Activate()
    // The corresponding t.Deactivate occurs in the exit path
    // (runExitMain.execute) so that when
    // Platform.CooperativelySharesAddressSpace() == true, we give up the
    // AddressSpace before the task goroutine finishes executing.

    // If this is a newly-started task, it should check for participation in
    // group stops. If this is a task resuming after restore, it was
    // interrupted by saving. In either case, the task is initially
    // interrupted.
    t.interruptSelf()

    for {
        // Explanation for this ordering:
        //
        // - A freshly-started task that is stopped should not do anything
        // before it enters the stop.
        //
        // - If taskRunState.execute returns nil, the task goroutine should
        // exit without checking for a stop.
        //
        // - Task.Start won&apos;t start Task.run if t.runState is nil, so this
        // ordering is safe.
        t.doStop()
        t.runState = t.runState.execute(t) //&#x672C;&#x8D28;&#x4E0A;&#x662F;&#x5728;&#x5FAA;&#x73AF;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;t.runState.execute, &#x7ED3;&#x5408;&#x540E;&#x9762;&#x7684;&#x5206;&#x6790;, &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x89E6;&#x53D1;&#x4E00;&#x4E2A;syscall cycle&#x7684;&#x6267;&#x884C;.
        if t.runState == nil {
            t.accountTaskGoroutineEnter(TaskGoroutineNonexistent)
            t.goroutineStopped.Done()
            t.tg.liveGoroutines.Done()
            t.tg.pidns.owner.liveGoroutines.Done()
            t.tg.pidns.owner.runningGoroutines.Done()
            t.p.Release()

            // Deferring this store triggers a false positive in the race
            // detector (https://github.com/golang/go/issues/42599).
            atomic.StoreInt64(&amp;t.goid, 0)
            // Keep argument alive because stack trace for dead variables may not be correct.
            runtime.KeepAlive(threadID)
            return
        }
    }
}

// The runApp state checks for interrupts before executing untrusted
// application code.
type runApp struct{}

func (app *runApp) execute(t *Task) taskRunState {
    //&#x5148;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x9700;&#x8981;&#x5904;&#x7406;interrupt
    //&#x5728;&#x6267;&#x884C;&#x7528;&#x6237;&#x4EE3;&#x7801;&#x4E4B;&#x524D;, &#x6267;&#x884C;&#x91CC;&#x9762;&#x7684;taskWork
    for _, work := range queue {
        work.TaskWork(t)
    }
    if t.haveSyscallReturn {
    }
    if t.haveSavedSignalMask {
    }
    if t.rseqPreempted {
    }
    if t.hasTracer() {
    }
    //&#x4E0B;&#x9762;&#x5C31;&#x8C03;&#x7528;&#x4E86;t.p.Switch
    info, at, err := t.p.Switch(t, t.MemoryManager(), t.Arch(), t.rseqCPU)

    switch err {
    case nil: // &#x6700;&#x5E38;&#x89C1;&#x7684;case
        // Handle application system call.
        // &#x8FD9;&#x91CC;&#x5C31;&#x662F;&#x5904;&#x7406;&#x7528;&#x6237;&#x7684;syscall
        return t.doSyscall()
    case platform.ErrContextInterrupt:
    case platform.ErrContextSignalCPUID:
    case platform.ErrContextSignal:
    case platform.ErrContextCPUPreempted:
    default:

    }
}
</code></pre>
<p>&#x8FD9;&#x91CC;&#x662F;&#x6267;&#x884C;syscall&#x7684;&#x5730;&#x65B9;
<code>@pkg/sentry/kernel/task_syscall.go</code></p>
<pre><code class="lang-go">// doSyscall is the entry point for an invocation of a system call specified by
// the current state of t&apos;s registers.
//
// The syscall path is very hot; avoid defer.
func (t *Task) doSyscall() taskRunState {
    t.Arch().SyscallSaveOrig()

    sysno := t.Arch().SyscallNo()
    args := t.Arch().SyscallArgs()

    if t.syscallFilters.Load() != nil {
    }

    return t.doSyscallEnter(sysno, args)
}

func (t *Task) doSyscallEnter(sysno uintptr, args arch.SyscallArguments) taskRunState {
    if next, ok := t.ptraceSyscallEnter(); ok {
        return next
    }
    return t.doSyscallInvoke(sysno, args)
}

func (t *Task) doSyscallInvoke(sysno uintptr, args arch.SyscallArguments) taskRunState {
    rval, ctrl, err := t.executeSyscall(sysno, args)

    if ctrl != nil {
        if !ctrl.ignoreReturn {
            t.Arch().SetReturn(rval)
        }
        if ctrl.next != nil {
            return ctrl.next
        }
    } else if err != nil {
        t.Arch().SetReturn(uintptr(-ExtractErrno(err, int(sysno))))
        t.haveSyscallReturn = true
    } else {
        t.Arch().SetReturn(rval)
    }

    return (*runSyscallExit)(nil).execute(t)
}

//&#x8FD9;&#x91CC;&#x7684;executeSyscall&#x5C31;&#x662F;gvisor&#x62E6;&#x622A;syscall&#x540E;, &#x771F;&#x6B63;&#x5904;&#x7406;&#x8FD9;&#x4E2A;syscall&#x7684;&#x5730;&#x65B9;
func (t *Task) executeSyscall(sysno uintptr, args arch.SyscallArguments) (rval uintptr, ctrl *SyscallControl, err error) {
    s := t.SyscallTable() //&#x67E5;&#x8868;&#x5230;&#x5177;&#x4F53;&#x7684;syscall
    fn := s.Lookup(sysno)
    if fn != nil {
        // Call our syscall implementation.
        rval, ctrl, err = fn(t, args) //&#x8C03;&#x7528;fn
    } else {
        // Use the missing function if not found.
        rval, err = t.SyscallTable().Missing(t, sysno, args)
    }
}
</code></pre>
<h2 id="ptrace"><a name="ptrace" class="anchor-navigation-ex-anchor" href="#ptrace"><i class="fa fa-link" aria-hidden="true"></i></a>4.12. ptrace</h2>
<p>gvisor&#x8BD5;&#x7528;ptrace&#x6765;&#x6267;&#x884C;&#x7528;&#x6237;&#x4EE3;&#x7801;, &#x4F46;&#x4E0D;&#x5141;&#x8BB8;&#x5176;&#x6267;&#x884C;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;.</p>
<p>ptrace&#x6709;context&#x7684;&#x5B9E;&#x73B0;&#x5B9E;&#x4F8B;:&#x4E3B;&#x8981;&#x662F;&#x5B9E;&#x73B0;&#x4E86;Switch()&#x65B9;&#x6CD5;</p>
<pre><code class="lang-go">// Switch runs the provided context in the given address space.
func (c *context) Switch(ctx pkgcontext.Context, mm platform.MemoryManager, ac arch.Context, cpu int32) (*linux.SignalInfo, hostarch.AccessType, error) {
    as := mm.AddressSpace()
    s := as.(*subprocess)
    //&#x8FD9;&#x91CC;&#x7684;&#x6548;&#x679C;&#x662F;&#x8BA9;&#x8FD9;&#x4E2A;subprocess&#x6267;&#x884C;&#x5230;&#x4E0B;&#x4E00;&#x6B21;syscall, &#x7136;&#x540E;&#x505C;&#x4E0B;&#x6765;
    isSyscall := s.switchToApp(c, ac) //&#x6709;syscall&#x548C;signal&#x4E24;&#x79CD;&#x53EF;&#x80FD;
    ...&#x4FDD;&#x5B58;faultSP, faultAddr, faultIP
    &#x5982;&#x679C;&#x662F;syscall, &#x5C31;&#x8FD4;&#x56DE;nil, hostarch.NoAccess, nil
    &#x5982;&#x679C;&#x6709;SIGSEGV&#x4FE1;&#x53F7;, &#x5C31;&#x8FD4;&#x56DE;&amp;si, hostarch.NoAccess, platform.ErrContextSignal
    &#x6700;&#x540E;&#x6839;&#x636E;&#x6761;&#x4EF6;&#x8FD4;&#x56DE;&amp;si, at, platform.ErrContextSignalCPUID

}
</code></pre>
<p>Switch()&#x7684;&#x57FA;&#x7840;&#x903B;&#x8F91;&#x662F;&#x6267;&#x884C;&#x4E00;&#x4E2A;syscall sycle, &#x7136;&#x540E;&#x505C;&#x5728;&#x4E0B;&#x4E00;&#x4E2A;syscall.</p>
<p>&#x8FD9;&#x91CC;&#x9762;&#x5173;&#x952E;&#x662F;switchToApp</p>
<pre><code class="lang-go">// switchToApp is called from the main SwitchToApp entrypoint.
//
// This function returns true on a system call, false on a signal.
func (s *subprocess) switchToApp(c *context, ac arch.Context) bool {
    // Lock the thread for ptrace operations.
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    // Grab our thread from the pool.
    currentTID := int32(procid.Current())
    t := s.sysemuThreads.lookupOrCreate(currentTID, s.newThread)

    // Reset necessary registers.
    regs := &amp;ac.StateData().Regs // &#x4ECE;ac&#x91CC;&#x9762;&#x8BFB;&#x51FA;regs
    t.resetSysemuRegs(regs)

    // Set registers. &#x8981;&#x5148;&#x8BBE;&#x7F6E;&#x5BC4;&#x5B58;&#x5668;, &#x5BC4;&#x5B58;&#x5668;&#x7684;&#x503C;&#x6765;&#x81EA;&#x4E8E;&#x4E0A;&#x6B21;&#x4FDD;&#x5B58;&#x7684;&#x503C;
    if err := t.setRegs(regs); err != nil {
        panic(fmt.Sprintf(&quot;ptrace set regs (%+v) failed: %v&quot;, regs, err))
    }

    // &#x8FD9;&#x91CC;&#x770B;&#x4F3C;&#x50CF;&#x662F;&#x4E2A;&#x4E3B;&#x5FAA;&#x73AF;, &#x4F46;&#x5B9E;&#x9645;&#x53EA;&#x662F;&#x60F3;&#x6267;&#x884C;&#x4E00;&#x6B21;system call
    for {
        // Start running until the next system call.
        if isSingleStepping(regs) {
            if _, _, errno := unix.RawSyscall6(
                unix.SYS_PTRACE,
                unix.PTRACE_SYSEMU_SINGLESTEP,
                uintptr(t.tid), 0, 0, 0, 0); errno != 0 {
                panic(fmt.Sprintf(&quot;ptrace sysemu failed: %v&quot;, errno))
            }
        } else {
            if _, _, errno := unix.RawSyscall6(
                unix.SYS_PTRACE,
                unix.PTRACE_SYSEMU, //&#x901A;&#x5E38;&#x662F;&#x8D70;&#x8FD9;&#x91CC;, &#x6BCF;&#x6B21;&#x90FD;&#x7528;ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x6765;&#x8BBE;&#x7F6E;, &#x8BA9;tracee&#x5728;&#x4E0B;&#x4E00;&#x6B21;syscall&#x4E4B;&#x524D;&#x505C;&#x4F4F;
                uintptr(t.tid), 0, 0, 0, 0); errno != 0 {
                panic(fmt.Sprintf(&quot;ptrace sysemu failed: %v&quot;, errno))
            }
        }
        // Wait for the syscall-enter stop.
        sig := t.wait(stopped) //&#x6CE8;&#x91CA;&#x8BF4;&#x7684;&#x5F88;&#x660E;&#x786E;, wait syscall-enter stop(&#x4E0B;&#x9762;&#x4F1A;&#x6709;&#x8BF4;&#x660E;)
        if sig == unix.SIGSTOP {
            // SIGSTOP was delivered to another thread in the same thread
            // group, which initiated another group stop. Just ignore it.
            continue
        }
        t.getRegs(regs) //wait()&#x8FD4;&#x56DE;&#x8D70;&#x5230;&#x8FD9;&#x91CC;&#x8BF4;&#x660E;&#x8FD9;&#x4E2A;tracee&#x7684;&#x7EBF;&#x7A0B;&#x5DF2;&#x7ECF;&#x505C;&#x5728;syscall&#x4E86;. &#x9A6C;&#x4E0A;&#x4FDD;&#x5B58;&#x5BC4;&#x5B58;&#x5668;&#x5230;t, &#x4EE5;&#x4FBF;&#x4E0B;&#x6B21;&#x6062;&#x590D;.
        t.getFPRegs(fpState, uint64(fpLen), useXsave)
        t.getTLS(&amp;tls)
        ac.SetTLS(uintptr(tls))

        // Is it a system call? &#x5982;&#x679C;&#x662F;syscall, &#x5C31;return true&#x4E86;, &#x76F4;&#x63A5;&#x4ECE;&#x672C;&#x51FD;&#x6570;&#x8FD4;&#x56DE;.
        if sig == (syscallEvent | unix.SIGTRAP) {
            s.arm64SyscallWorkaround(t, regs)

            // Ensure registers are sane.
            updateSyscallRegs(regs)
            return true
        }

        //&#x4E0B;&#x9762;&#x662F;signal&#x7684;&#x5904;&#x7406;&#x6D41;&#x7A0B;
        t.getSignalInfo(&amp;c.signalInfo)
        //&#x5904;&#x7406;&#x7684;&#x65F6;&#x5019;&#x770B;&#x8FD9;&#x4E2A;signal&#x662F;kernel&#x53D1;&#x7684;&#x8FD8;&#x662F;&#x81EA;&#x5DF1;&#x8FDB;&#x7A0B;&#x53D1;&#x7684;, &#x5176;&#x4ED6;&#x8FDB;&#x7A0B;&#x53D1;&#x7684;&#x88AB;&#x5FFD;&#x7565;.
    }
}
</code></pre>
<h3 id="threadsetregs"><a name="threadsetregs" class="anchor-navigation-ex-anchor" href="#threadsetregs"><i class="fa fa-link" aria-hidden="true"></i></a>4.12.1. thread.setRegs</h3>
<p>&#x4E0A;&#x9762;switchToApp()&#x51FD;&#x6570;&#x4E2D;, &#x4E0A;&#x6765;&#x5C31;&#x4ECE;adress space&#x91CC;&#x8BFB;&#x51FA;&#x4FDD;&#x5B58;&#x7684;&#x5BC4;&#x5B58;&#x5668;, &#x7528;thread.setRegs()&#x6062;&#x590D;&#x5230;cpu&#x4E2D;&#x53BB;.
&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5C31;&#x7528;&#x5230;&#x4E86;&#x4E0B;&#x9762;&#x4F1A;&#x63D0;&#x5230;&#x7684;ptrace&#x7684;<code>PTRACE_SETREGSET</code>&#x547D;&#x4EE4;</p>
<pre><code class="lang-go">// setRegs sets the general purpose register set.
func (t *thread) setRegs(regs *arch.Registers) error {
    iovec := unix.Iovec{
        Base: (*byte)(unsafe.Pointer(regs)),
        Len:  uint64(unsafe.Sizeof(*regs)),
    }
    _, _, errno := unix.RawSyscall6(
        unix.SYS_PTRACE,
        unix.PTRACE_SETREGSET,
        uintptr(t.tid),
        linux.NT_PRSTATUS,
        uintptr(unsafe.Pointer(&amp;iovec)),
        0, 0)
    if errno != 0 {
        return errno
    }
    return nil
}
</code></pre>
<h3 id="&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;"><a name="&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;" class="anchor-navigation-ex-anchor" href="#&#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;"><i class="fa fa-link" aria-hidden="true"></i></a>4.12.2. &#x4E3B;&#x8981;&#x7ED3;&#x6784;&#x4F53;</h3>
<p>&#x5B50;&#x8FDB;&#x7A0B;&#x62E5;&#x6709;&#x7EBF;&#x7A0B;&#x6C60;</p>
<pre><code class="lang-go">// subprocess is a collection of threads being traced.
type subprocess struct {
    platform.NoAddressSpaceIO

    // requests is used to signal creation of new threads.
    requests chan chan *thread

    // sysemuThreads are reserved for emulation.
    sysemuThreads threadPool

    // syscallThreads are reserved for syscalls (except clone, which is
    // handled in the dedicated goroutine corresponding to requests above).
    syscallThreads threadPool

    // mu protects the following fields.
    mu sync.Mutex

    // contexts is the set of contexts for which it&apos;s possible that
    // context.lastFaultSP == this subprocess.
    contexts map[*context]struct{}
}
</code></pre>
<p>&#x7EBF;&#x7A0B;</p>
<pre><code class="lang-go">// thread is a traced thread; it is a thread identifier.
//
// This is a convenience type for defining ptrace operations.
type thread struct {
    tgid int32
    tid  int32
    cpu  uint32

    // initRegs are the initial registers for the first thread.
    //
    // These are used for the register set for system calls.
    initRegs arch.Registers
}
</code></pre>
<p>thread&#x6709;&#x4E2A;syscall&#x65B9;&#x6CD5;, &#x7528;&#x4E8E;&#x6267;&#x884C;&#x4E00;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;<strong>cycle</strong>. &#x6CE8;&#x610F;&#x8FD9;&#x91CC;&#x7528;&#x4E86;cycle&#x4E00;&#x8BCD;, &#x6267;&#x884C;&#x8FC7;&#x7A0B;&#x548C;switchToApp()&#x5F88;&#x50CF;: &#x4E5F;&#x662F;&#x5148;load&#x5BC4;&#x5B58;&#x5668;, &#x8C03;&#x7528;ptrace&#x7684;PTRACE_CONT, &#x7136;&#x540E;wait(), &#x5F85;tracee&#x7684;&#x7EBF;&#x7A0B;&#x505C;&#x4F4F;&#x540E;&#x4FDD;&#x5B58;&#x5BC4;&#x5B58;&#x5668;.
&#x770B;&#x6CE8;&#x91CA;&#x8FD9;&#x4E2A;syscall&#x4E0D;&#x662F;&#x7ED9;app&#x7528;&#x7684;, &#x800C;&#x662F;&#x67D0;&#x79CD;&#x6761;&#x4EF6;&#x4E0B;inject&#x5230;&#x8FDC;&#x7A0B;&#x4E0A;&#x4E0B;&#x6587;&#x7684;.</p>
<pre><code class="lang-go">// syscall executes a system call cycle in the traced context.
//
// This is _not_ for use by application system calls, rather it is for use when
// a system call must be injected into the remote context (e.g. mmap, munmap).
// Note that clones are handled separately.
func (t *thread) syscall(regs *arch.Registers) (uintptr, error) {
    // Set registers.
    if err := t.setRegs(regs); err != nil {
        panic(fmt.Sprintf(&quot;ptrace set regs failed: %v&quot;, err))
    }

    for {
        // Execute the syscall instruction. The task has to stop on the
        // trap instruction which is right after the syscall
        // instruction.
        if _, _, errno := unix.RawSyscall6(unix.SYS_PTRACE, unix.PTRACE_CONT, uintptr(t.tid), 0, 0, 0, 0); errno != 0 {
            panic(fmt.Sprintf(&quot;ptrace syscall-enter failed: %v&quot;, errno))
        }

        sig := t.wait(stopped)
        if sig == unix.SIGTRAP {
            // Reached syscall-enter-stop.
            break
        } else {
            // Some other signal caused a thread stop; ignore.
            if sig != unix.SIGSTOP &amp;&amp; sig != unix.SIGCHLD {
                log.Warningf(&quot;The thread %d:%d has been interrupted by %d&quot;, t.tgid, t.tid, sig)
            }
            continue
        }
    }

    // Grab registers.
    if err := t.getRegs(regs); err != nil {
        panic(fmt.Sprintf(&quot;ptrace get regs failed: %v&quot;, err))
    }

    return syscallReturnValue(regs)
}
</code></pre>
<p>&#x7EBF;&#x7A0B;&#x6C60;</p>
<pre><code class="lang-go">// threadPool is a collection of threads.
type threadPool struct {
    // mu protects below.
    mu sync.RWMutex

    // threads is the collection of threads.
    //
    // This map is indexed by system TID (the calling thread); which will
    // be the tracer for the given *thread, and therefore capable of using
    // relevant ptrace calls.
    threads map[int32]*thread
}
</code></pre>
<h3 id="ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;"><a name="ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;" class="anchor-navigation-ex-anchor" href="#ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;"><i class="fa fa-link" aria-hidden="true"></i></a>4.12.3. ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;</h3>
<p>&#x8981;&#x7406;&#x89E3;&#x8FD9;&#x90E8;&#x5206;, &#x9700;&#x8981;&#x770B;<code>man ptrace</code>
ptrace&#x662F;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x53EF;&#x4EE5;&#x8BA9;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;(tracer)&#x89C2;&#x5BDF;&#x548C;&#x63A7;&#x5236;&#x53E6;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;(tracee)&#x7684;&#x5185;&#x5B58;&#x548C;&#x5BC4;&#x5B58;&#x5668;.&#x4E3B;&#x8981;&#x662F;&#x7528;&#x6765;&#x5B9E;&#x73B0;&#x65AD;&#x70B9;&#x548C;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x8DDF;&#x8E2A;&#x7528;&#x7684;.</p>
<p>tracee&#x9700;&#x8981;&#x5148;&#x88AB;attach&#x5230;tracer&#x4E0A;. &#x8FD9;&#x4E2A;attach&#x662F;&#x4EE5;&#x7EBF;&#x7A0B;&#x4E3A;&#x5355;&#x4F4D;&#x7684;: &#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x7684;&#x591A;&#x4E2A;&#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x5206;&#x522B;&#x88AB;attach&#x5230;&#x4E0D;&#x540C;&#x7684;tracer&#x4E0A;, &#x6CA1;&#x6709;&#x88AB;attach&#x7684;&#x7EBF;&#x7A0B;&#x5C31;&#x8FD8;&#x662F;&#x7167;&#x5E38;&#x6267;&#x884C;.
&#x8BB0;&#x4F4F;ptrace&#x662F;&#x5BF9;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#x7684;.</p>
<pre><code class="lang-c">#include &lt;sys/ptrace.h&gt;

//&#x4E0B;&#x9762;&#x7684;pid&#x662F;tid, &#x5373;&#x7EBF;&#x7A0B;id
long ptrace(enum __ptrace_request request, pid_t pid,
            void *addr, void *data);
</code></pre>
<p>&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x53EF;&#x4EE5;&#x53D1;&#x8D77;trace&#x5230;&#x53E6;&#x5916;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;:</p>
<ul>
<li>fork&#x4E00;&#x4E2A;&#x5B50;&#x8FDB;&#x7A0B;, &#x7136;&#x540E;&#x5728;&#x5B50;&#x8FDB;&#x7A0B;&#x91CC;&#x8C03;&#x7528;ptrace PTRACE_TRACEME, &#x7136;&#x540E;&#x518D;&#x7528;execve. &#x8FD9;&#x6837;&#x8FD9;&#x4E2A;&#x5B50;&#x8FDB;&#x7A0B;&#x5C31;&#x53EF;&#x4EE5;&#x88AB;trace&#x4E86;</li>
<li>&#x7528;PTRACE_ATTACH or PTRACE_SEIZE&#x6765;attach&#x5230;&#x53E6;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;.</li>
</ul>
<p>tracee&#x5728;&#x6709;signal&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x505C;&#x4E0B;&#x6765;, &#x5373;&#x4F7F;ignore&#x7684;signal&#x4E5F;&#x4F1A;&#x505C;&#x4F4F;. &#x8FD9;&#x4E2A;&#x65F6;&#x5019;, tracer&#x7684;wait()&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x4F1A;&#x8FD4;&#x56DE;, &#x7136;&#x540E;tracer&#x53EF;&#x4EE5;&#x901A;&#x8FC7;ptrace&#x547D;&#x4EE4;&#x6765;&#x5BF9;&#x5DF2;&#x7ECF;&#x505C;&#x4F4F;&#x7684;tracee&#x505A;&#x68C0;&#x67E5;&#x548C;&#x4FEE;&#x6539;. &#x7136;&#x540E;tracer&#x8BA9;tracee&#x7EE7;&#x7EED;&#x8FD0;&#x884C;. &#x6700;&#x540E;&#x7528;PTRACE_DETACH&#x6765;&#x89E3;&#x9664;trace&#x72B6;&#x6001;, &#x8BA9;tracee&#x53EF;&#x4EE5;&#x7EE7;&#x7EED;&#x6B63;&#x5E38;&#x8FD0;&#x884C;.</p>
<h3 id="ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;"><a name="ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;" class="anchor-navigation-ex-anchor" href="#ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;"><i class="fa fa-link" aria-hidden="true"></i></a>4.12.4. ptrace&#x53EF;&#x4EE5;&#x505A;&#x4EC0;&#x4E48;?</h3>
<p>ptrace&#x7684;command&#x5F88;&#x4E30;&#x5BCC;, command&#x5C31;&#x662F;&#x4F20;&#x7ED9;ptrace&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;request</p>
<pre><code>The value of request determines the action to be performed:
PTRACE_TRACEME: &#x552F;&#x4E00;&#x4E00;&#x4E2A;tracee&#x8C03;&#x7528;&#x7684;command, &#x7528;&#x4E8E;&#x628A;&#x81EA;&#x8EAB;&#x7F6E;&#x4E3A;tracee
PTRACE_PEEKTEXT, PTRACE_PEEKDATA: &#x67E5;&#x770B;tracee&#x7684;&#x5185;&#x5B58;, &#x5728;linux&#x4E0B;&#x9762;, text&#x548C;data&#x662F;&#x4E00;&#x4E2A;&#x7A7A;&#x95F4;, &#x6548;&#x679C;&#x4E00;&#x6837;.
PTRACE_POKETEXT, PTRACE_POKEDATA: &#x4FEE;&#x6539;tracee&#x7684;&#x5185;&#x5B58;.
PTRACE_PEEKUSER: &#x8BFB;tracee&#x7684;USER&#x533A;&#x57DF;, &#x8FD9;&#x662F;&#x4E2A;&#x542B;&#x6709;&#x5BC4;&#x5B58;&#x5668;&#x548C;&#x5176;&#x4ED6;&#x4FE1;&#x606F;&#x7684;&#x533A;&#x57DF;(&#x89C1;&lt;sys/user.h&gt;)
PTRACE_POKEUSER: &#x4FEE;&#x6539;tracee&#x7684;USER&#x533A;&#x57DF;
PTRACE_GETREGS, PTRACE_GETFPREGS: &#x8BFB;tracee&#x7684;&#x901A;&#x7528;&#x5BC4;&#x5B58;&#x5668;&#x6216;&#x8005;&#x6D6E;&#x70B9;&#x5BC4;&#x5B58;&#x5668;
PTRACE_SETREGS, PTRACE_SETFPREGS: &#x4FEE;&#x6539;tracee&#x5BC4;&#x5B58;&#x5668;
PTRACE_GETREGSET: &#x8BFB;CPU&#x7279;&#x6B8A;&#x5BC4;&#x5B58;&#x5668;
PTRACE_SETREGSET: &#x4FEE;&#x6539;CPU&#x5BC4;&#x5B58;&#x5668;
PTRACE_GETSIGINFO: &#x8BFB;&#x53D6;signal&#x7684;&#x4FE1;&#x606F;. &#x8FD9;&#x4E2A;signal&#x5BFC;&#x81F4;&#x4E86;tracee&#x7684;stop
PTRACE_PEEKSIGINFO
PTRACE_SETSIGINFO: &#x4FEE;&#x6539;signal&#x4FE1;&#x606F;&#x7ED9;tracee&#x770B;
PTRACE_GETSIGMASK
PTRACE_SETSIGMASK
PTRACE_SETOPTIONS: &#x4F7F;&#x7528;data&#x6765;&#x533A;&#x5206;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x5177;&#x4F53;option, &#x7528;&#x4E8E;&#x63A7;&#x5236;ptrace&#x884C;&#x4E3A;
PTRACE_CONT: &#x7EE7;&#x7EED;tracee
PTRACE_SYSCALL, PTRACE_SINGLESTEP: &#x4E5F;&#x662F;&#x7EE7;&#x7EED;tracee, &#x4F46;&#x8BA9;&#x5B83;&#x5728;&#x4E0B;&#x4E00;&#x4E2A;syscall&#x7684;&#x65F6;&#x5019;&#x505C;&#x4E0B;&#x6765;, &#x6216;&#x8005;&#x662F;&#x5728;&#x4E0B;&#x4E00;&#x4E2A;&#x6307;&#x4EE4;&#x65F6;&#x505C;&#x4E0B;&#x6765;.
PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP: &#x548C;&#x4E0A;&#x9762;&#x5DEE;&#x4E0D;&#x591A;
PTRACE_LISTEN: &#x4E5F;&#x662F;&#x8BA9;tracee&#x7EE7;&#x7EED;, &#x4F46;&#x662F;&#x4E0D;&#x6267;&#x884C;(&#x4E0D;&#x4F1A;&#x88AB;&#x8C03;&#x5EA6;&#x5230;)... 
PTRACE_KILL: kill tracee
PTRACE_INTERRUPT: &#x8BA9;tracee&#x505C;&#x4E0B;&#x6765;
PTRACE_ATTACH: attach tracee. &#x9700;&#x8981;&#x76F8;&#x5E94;&#x6743;&#x9650;
PTRACE_SEIZE: &#x548C;attach&#x7C7B;&#x4F3C;, &#x4F46;&#x4E0D;&#x4F1A;&#x5BFC;&#x81F4;tracee&#x505C;&#x6B62;
PTRACE_DETACH: dettach
</code></pre><p>tracee&#x6709;stop&#x548C;running&#x72B6;&#x6001;, &#x867D;&#x7136;&#x5728;blocking&#x7684;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x65F6;&#x5019;tracee&#x88AB;&#x963B;&#x585E;&#x4E86;, &#x4F46;&#x5B9E;&#x9645;&#x8FD8;&#x5728;&#x5185;&#x6838;&#x6001;&#x8FD0;&#x884C;, &#x662F;running&#x7684;&#x72B6;&#x6001;.
stop&#x72B6;&#x6001;&#x7EDF;&#x79F0;ptrace-stop, &#x5F53;tracee&#x8FDB;&#x5165;ptrace-stop&#x72B6;&#x6001;&#x65F6;, &#x4F1A;&#x901A;&#x8FC7;waitpid()&#x901A;&#x77E5;tracer. &#x6240;&#x4EE5;tracer&#x8981;&#x5728;&#x5FAA;&#x73AF;&#x91CC;&#x7B49;&#x5F85;</p>
<pre><code class="lang-go">pid = waitpid(pid_or_minus_1, &amp;status, __WALL);
</code></pre>
<p>ptrace-stop&#x6709;&#x51E0;&#x79CD;&#x53EF;&#x80FD;:</p>
<ul>
<li>Signal-delivery-stop: &#x5F53;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x6536;&#x5230;signal&#x65F6;, &#x9664;&#x4E86;sigkill, kernel&#x4F1A;&#x9009;&#x62E9;&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x7684;&#x67D0;&#x4E2A;&#x7EBF;&#x7A0B;&#x6765;handle signal(&#x4F46;&#x5982;&#x679C;&#x8FD9;&#x4E2A;signal&#x662F;tgkill&#x4EA7;&#x751F;&#x7684;, &#x90A3;&#x76EE;&#x6807;&#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x88AB;caller&#x6307;&#x5B9A;). &#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x88AB;&#x9009;&#x4E2D;&#x7684;&#x7EBF;&#x7A0B;&#x662F;tracee, &#x5C31;&#x4F1A;&#x8FDB;&#x5165;signal-delivery-stop. &#x8FD9;&#x4E2A;&#x65F6;&#x5019;, signal&#x8FD8;&#x6CA1;&#x6709;&#x5230;&#x8FBE;tracee, &#x800C;&#x662F;&#x5148;&#x88AB;tracer&#x77E5;&#x9053;: &#x5982;&#x679C;tracer&#x4E0D;&#x533A;supress&#x8FD9;&#x4E2A;signal, tracer&#x7684;&#x4E0B;&#x4E00;&#x6B21;ptrace  restart&#x547D;&#x4EE4;&#x4F1A;inject&#x8FD9;&#x4E2A;signal&#x5230;tracee.</li>
<li>Group-stop: stop signal&#x4F1A;&#x5BFC;&#x81F4;&#x6574;&#x4E2A;&#x8FDB;&#x7A0B;&#x7684;&#x5168;&#x90E8;&#x7EBF;&#x7A0B;stop. &#x90A3;tracee&#x4F1A;&#x8FDB;&#x5165;group-stop. &#x6CE8;&#x610F;&#x8FD9;&#x4E2A;stop signal&#x4E5F;&#x662F;&#x7ECF;&#x8FC7;&#x4E86;Signal-delivery-stop&#x7136;&#x540E;&#x7531;tracer inject&#x5230;tracee&#x7684;, &#x8FDB;&#x800C;&#x5BFC;&#x81F4;&#x4E86;&#x6574;&#x4E2A;&#x8FDB;&#x7A0B;stop.</li>
<li>PTRACE_EVENT stops: ptrace&#x4E8B;&#x4EF6;&#x5BFC;&#x81F4;&#x7684;stop, &#x6BD4;&#x5982;PTRACE_EVENT_FORK, PTRACE_EVENT_CLONE</li>
<li>Syscall-stops: &#x8FD9;&#x4E2A;&#x573A;&#x666F;&#x662F;&#x56E0;&#x4E3A;&#x4E4B;&#x524D;ptrace&#x8BBE;&#x7F6E;&#x4E86;PTRACE_SYSCALL or PTRACE_SYSEMU&#x547D;&#x4EE4;, &#x4F1A;&#x5BFC;&#x81F4;tracee&#x5728;&#x8C03;&#x7528;syscall&#x4E4B;&#x524D;stop, &#x8FD9;&#x4E2A;&#x5C31;&#x662F;Syscall-stop</li>
<li>PTRACE_EVENT_SECCOMP stops: &#x548C;seccomp&#x6709;&#x5173;</li>
<li>PTRACE_SINGLESTEP stops: &#x5355;&#x6B65;</li>
</ul>
<p>&#x6CE8;&#x610F;, &#x56E0;&#x4E3A;ptrace&#x5927;&#x91CF;&#x7528;&#x4E86;waitpid(), &#x800C;&#x771F;&#x6B63;&#x7684;tracee&#x7684;&#x7236;&#x8FDB;&#x7A0B;&#x4E00;&#x822C;&#x4E5F;&#x8C03;&#x7528;wait()&#x6765;&#x7B49;&#x5F85;&#x5B50;&#x8FDB;&#x7A0B;&#x9000;&#x51FA;, &#x90A3;tracer&#x4F1A;&#x5148;&#x6536;&#x5230;waitpid&#x7684;&#x901A;&#x77E5;, &#x7136;&#x540E;&#x518D;&#x901A;&#x77E5;tracee&#x7684;&#x7236;&#x8FDB;&#x7A0B;.</p>
<h2 id="kvm"><a name="kvm" class="anchor-navigation-ex-anchor" href="#kvm"><i class="fa fa-link" aria-hidden="true"></i></a>4.13. kvm</h2>
<p>&#x76EE;&#x5F55;&#x5728;<code>gvisor/pkg/sentry/platform/kvm</code></p>
<h3 id="golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;"><a name="golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;" class="anchor-navigation-ex-anchor" href="#golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.1. golang&#x7684;&#x6C47;&#x7F16;&#x57FA;&#x7840;</h3>
<p>&#x5B98;&#x65B9;&#x6587;&#x6863;: <a href="https://go.dev/doc/asm" target="_blank">https://go.dev/doc/asm</a></p>
<pre><code>FP: Frame pointer: arguments and locals.
PC: Program counter: jumps and branches.
SB: Static base pointer: global symbols.
SP: Stack pointer: the highest address within the local stack frame.
</code></pre><p>&#x67D0;&#x4E9B;CPU&#x6307;&#x4EE4;&#x96C6;, &#x6BD4;&#x5982;arm64, &#x6570;&#x636E;&#x662F;&#x4ECE;&#x53F3;&#x5230;&#x5DE6;:</p>
<pre><code>MRS Move System register to general-purpose register
MSR Move general-purpose register to System register

MRS    R0,CPSR            ; delivery CPSR Content to R0
MSR    CPSR,R0            ; delivery R0 Content to CPSR
</code></pre><p>&#x6BD4;&#x5982;&#x5728;kernel&#x4EE3;&#x7801;&#x91CC;:</p>
<pre><code>mrs    x0, tpidrro_el0 // &#x7279;&#x6B8A;&#x5BC4;&#x5B58;&#x5668;tpidrro_el0&#x8D4B;&#x503C;&#x7ED9;x0
msr    sctlr_el1, x0 // x0&#x8D4B;&#x503C;&#x7ED9;&#x7279;&#x6B8A;&#x5BC4;&#x5B58;&#x5668;sctlr_el1
</code></pre><p>&#x4F46;&#x6CE8;&#x610F;, go&#x91CC;&#x9762;MOV&#x7684;&#x65B9;&#x5411;&#x662F;&#x4ECE;&#x5DE6;&#x5411;&#x53F3;:</p>
<pre><code>MOVL    g(CX), AX     // Move g into AX.
MOVL    g_m(AX), BX   // Move g.m into BX.
</code></pre><p>&#x6240;&#x4EE5;, ARM64&#x7684;MRS/MSR&#x5728;golang&#x91CC;&#x662F;&#x53CD;&#x7684;: &#x5B83;&#x4EEC;&#x4F9D;&#x7136;&#x9075;&#x5FAA;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;&#x7684;&#x539F;&#x5219;:</p>
<pre><code>MSR R1, MDSCR_EL1       // access to the DCC from EL0
MRS TTBR1_EL1, R1
</code></pre><p>&#x518D;&#x5F3A;&#x8C03;&#x4E00;&#x6B21;: <strong>&#x5728;go&#x7684;&#x6C47;&#x7F16;&#x91CC;, MSR&#x548C;MRS&#x7684;&#x4F7F;&#x7528;&#x548C;ARM&#x5B98;&#x65B9;&#x6587;&#x6863;&#x7684;&#x65B9;&#x5411;&#x76F8;&#x53CD;</strong></p>
<h3 id="arm64-exception-level"><a name="arm64-exception-level" class="anchor-navigation-ex-anchor" href="#arm64-exception-level"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.2. arm64 exception level</h3>
<p>&#x8BE6;&#x89C1;: <a href="https://developer.arm.com/documentation/102412/0102/Privilege-and-Exception-levels" target="_blank">https://developer.arm.com/documentation/102412/0102/Privilege-and-Exception-levels</a></p>
<ul>
<li>&#x5BC4;&#x5B58;&#x5668;&#x90FD;&#x662F;&#x5E26;EL&#x540E;&#x7F00;&#x7684;.</li>
<li>&#x4F4E;EL&#x4E0D;&#x80FD;&#x8BBF;&#x95EE;&#x9AD8;EL&#x7684;&#x5BC4;&#x5B58;&#x5668;; &#x5F3A;&#x884C;&#x8BBF;&#x95EE;&#x4F1A;&#x5F02;&#x5E38;, &#x7C7B;&#x522B;&#x5E94;&#x8BE5;&#x662F;&#x6307;&#x4EE4;&#x5F02;&#x5E38;</li>
<li>&#x9AD8;EL&#x53EF;&#x4EE5;&#x8BBF;&#x95EE;&#x4F4E;EL&#x7684;&#x5BC4;&#x5B58;&#x5668;, &#x4F46;&#x9664;&#x4E86;&#x865A;&#x62DF;&#x5316;&#x573A;&#x666F;, &#x5176;&#x5B83;&#x573A;&#x666F;&#x5E76;&#x4E0D;&#x5E38;&#x7528;?</li>
</ul>
<h3 id="arm64&#x5185;&#x5B58;&#x57FA;&#x7840;"><a name="arm64&#x5185;&#x5B58;&#x57FA;&#x7840;" class="anchor-navigation-ex-anchor" href="#arm64&#x5185;&#x5B58;&#x57FA;&#x7840;"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.3. arm64&#x5185;&#x5B58;&#x57FA;&#x7840;</h3>
<p>&#x57FA;&#x7840;&#x6982;&#x5FF5;:</p>
<ul>
<li>AARCH64&#x652F;&#x6301;&#x865A;&#x62DF;&#x5185;&#x5B58;&#x7684;tag, &#x865A;&#x62DF;&#x5185;&#x5B58;&#x7684;&#x6700;&#x9AD8;8&#x4F4D;&#x662F;tag, &#x5728;&#x5730;&#x5740;&#x7FFB;&#x8BD1;&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x88AB;&#x5FFD;&#x7565;.</li>
<li>PC, LR, SP, ELR&#x91CC;&#x9762;&#x90FD;&#x662F;VA</li>
<li>AArch64&#x6709;48&#x4F4D;VA, &#x7A7A;&#x95F4;&#x6709;256TB, &#x6709;&#x4E24;&#x4E2A;range&#x7A7A;&#x95F4;
0xFFFF_0000_0000_0000 &#x5230; 0xFFFF_FFFF_FFFF_FFFF &#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;&#x662F;TTBR1, &#x5185;&#x6838;&#x6001;
&#x6216;
0x0000_0000_0000_0000 &#x5230; 0x0000_FFFF_FFFF_FFFF &#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;&#x662F;TTBR0, &#x7528;&#x6237;&#x6001;</li>
<li>IPA&#x4E5F;&#x662F;48&#x4F4D;</li>
<li>PA&#x4E5F;&#x662F;48&#x4F4D;, &#x5E76;&#x4E14;secure&#x548C;non-secure&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x662F;&#x72EC;&#x7ACB;&#x7684;</li>
<li>TTBR&#x662F;&#x5730;&#x5740;&#x8F6C;&#x6362;&#x8868;&#x7684;&#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;, &#x8FD9;&#x4E2A;&#x8868;&#x7531;&#x786C;&#x4EF6;&#x81EA;&#x52A8;&#x67E5;, &#x5E76;&#x88AB;&#x7F13;&#x5B58;&#x5230;TLB&#x4E2D;; TTBR&#x91CC;&#x9762;&#x4FDD;&#x5B58;&#x7684;&#x662F;&#x7269;&#x7406;&#x5730;&#x5740;, &#x662F;&#x7ED9;&#x786C;&#x4EF6;MMU waker&#x770B;&#x7684;.
&#x8FD9;&#x4E2A;&#x8868;&#x6700;&#x591A;&#x6709;&#x56DB;&#x7EA7;, &#x5730;&#x5740;&#x6700;&#x591A;48&#x4F4D;, &#x6700;&#x5927;64KB&#x4E00;&#x4E2A;&#x6620;&#x5C04;</li>
</ul>
<p>&#x4E00;&#x4E2A;VA&#x600E;&#x4E48;&#x627E;&#x5230;PA?
<img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915082938.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915082950.png" alt=""><br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915083000.png" alt="">  </p>
<h4 id="vm&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;"><a name="vm&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;" class="anchor-navigation-ex-anchor" href="#vm&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;"><i class="fa fa-link" aria-hidden="true"></i></a>VM&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;</h4>
<p>&#x7528;KVM&#x542F;&#x52A8;&#x7684;VM, &#x4ECE;VM&#x770B;&#x6765;, &#x5B83;&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x5C31;&#x662F;&#x5176;&#x6240;&#x5728;&#x7684;host&#x7684;qemu&#x8FDB;&#x7A0B;(&#x6216;gvisor&#x8FDB;&#x7A0B;)&#x7684;&#x8FDB;&#x7A0B;&#x7A7A;&#x95F4;.<br>&#x7B2C;&#x4E00;&#x6B65;&#x5148;&#x7528;VM&#x91CC;&#x7684;VA&#x901A;&#x8FC7;TTBR&#x5BC4;&#x5B58;&#x5668;&#x6307;&#x5411;&#x7684;page table, &#x67E5;&#x5230;IPA. &#x8FD9;&#x4E2A;IPA&#x5176;&#x5B9E;&#x5C31;&#x662F;&#x542F;&#x52A8;VM&#x7684;&#x8FDB;&#x7A0B;&#x4E2D;&#x67D0;&#x4E2A;&#x5730;&#x5740;.<br>&#x7B2C;&#x4E8C;&#x6B65;&#x62FF;&#x7740;IPA&#x901A;&#x8FC7;VTTBR&#x5BC4;&#x5B58;&#x5668;&#x6307;&#x5411;&#x7684;page table&#x6765;&#x67E5;PA. &#x8FD9;&#x4E2A;VTTBR&#x662F;&#x5728;EL2&#x91CC;&#x7684;hypervisor&#x914D;&#x7F6E;&#x7684;.<br><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915083026.png" alt="">  </p>
<p>&#x518D;&#x8BF4;&#x4E00;&#x904D;, <strong>VM&#x770B;&#x5230;&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;, &#x5C31;&#x662F;VM&#x6240;&#x5728;&#x7684;&#x8FDB;&#x7A0B;&#x5730;&#x5740;</strong>.</p>
<h3 id="kvm&#x57FA;&#x7840;"><a name="kvm&#x57FA;&#x7840;" class="anchor-navigation-ex-anchor" href="#kvm&#x57FA;&#x7840;"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.4. KVM&#x57FA;&#x7840;</h3>
<p>&#x7528;&#x6237;&#x6001;&#x662F;&#x901A;&#x8FC7;open(&quot;/dev/kvm&quot;)&#x7136;&#x540E;&#x505A;ioctl&#x6765;&#x548C;&#x5185;&#x6838;&#x7684;kvm&#x6A21;&#x5757;&#x4EA4;&#x4E92;&#x7684;.
KVM&#x652F;&#x6301;&#x7684;IOCTL&#x662F;:</p>
<pre><code class="lang-go">// KVM ioctls.
//
// Only the ioctls we need in Go appear here; some additional ioctls are used
// within the assembly stubs (KVM_INTERRUPT, etc.).
// &#x8FD9;&#x91CC;&#x9762;&#x5305;&#x62EC;&#x521B;&#x5EFA;VM, &#x521B;&#x5EFA;VCPU, &#x8BBE;&#x7F6E;&#x5BC4;&#x5B58;&#x5668;, &#x8BFB;&#x53D6;&#x5BC4;&#x5B58;&#x5668;&#x7B49;&#x7B49;
const (
    _KVM_CREATE_VM              = 0xae01
    _KVM_GET_VCPU_MMAP_SIZE     = 0xae04
    _KVM_CREATE_VCPU            = 0xae41
    _KVM_SET_TSS_ADDR           = 0xae47
    _KVM_RUN                    = 0xae80
    _KVM_NMI                    = 0xae9a
    _KVM_CHECK_EXTENSION        = 0xae03
    _KVM_GET_TSC_KHZ            = 0xaea3
    _KVM_SET_TSC_KHZ            = 0xaea2
    _KVM_INTERRUPT              = 0x4004ae86
    _KVM_SET_MSRS               = 0x4008ae89
    _KVM_SET_USER_MEMORY_REGION = 0x4020ae46
    _KVM_SET_REGS               = 0x4090ae82
    _KVM_SET_SREGS              = 0x4138ae84
    _KVM_GET_MSRS               = 0xc008ae88
    _KVM_GET_REGS               = 0x8090ae81
    _KVM_GET_SREGS              = 0x8138ae83
    _KVM_GET_SUPPORTED_CPUID    = 0xc008ae05
    _KVM_SET_CPUID2             = 0x4008ae90
    _KVM_SET_SIGNAL_MASK        = 0x4004ae8b
    _KVM_GET_VCPU_EVENTS        = 0x8040ae9f
    _KVM_SET_VCPU_EVENTS        = 0x4040aea0
)

// KVM exit reasons.
const (
    _KVM_EXIT_EXCEPTION       = 0x1
    _KVM_EXIT_IO              = 0x2
    _KVM_EXIT_HYPERCALL       = 0x3
    _KVM_EXIT_DEBUG           = 0x4
    _KVM_EXIT_HLT             = 0x5
    _KVM_EXIT_MMIO            = 0x6
    _KVM_EXIT_IRQ_WINDOW_OPEN = 0x7
    _KVM_EXIT_SHUTDOWN        = 0x8
    _KVM_EXIT_FAIL_ENTRY      = 0x9
    _KVM_EXIT_INTERNAL_ERROR  = 0x11
    _KVM_EXIT_SYSTEM_EVENT    = 0x18
    _KVM_EXIT_ARM_NISV        = 0x1c
)

// KVM capability options.
const (
    _KVM_CAP_MAX_MEMSLOTS          = 0x0a
    _KVM_CAP_MAX_VCPUS             = 0x42
    _KVM_CAP_ARM_VM_IPA_SIZE       = 0xa5
    _KVM_CAP_VCPU_EVENTS           = 0x29
    _KVM_CAP_ARM_INJECT_SERROR_ESR = 0x9e
    _KVM_CAP_TSC_CONTROL           = 0x3c
)

// KVM limits.
const (
    _KVM_NR_MEMSLOTS      = 0x100
    _KVM_NR_VCPUS         = 0xff
    _KVM_NR_INTERRUPTS    = 0x100
    _KVM_NR_CPUID_ENTRIES = 0x100
)

// KVM kvm_memory_region::flags.
const (
    _KVM_MEM_LOG_DIRTY_PAGES = uint32(1) &lt;&lt; 0
    _KVM_MEM_READONLY        = uint32(1) &lt;&lt; 1
    _KVM_MEM_FLAGS_NONE      = 0
)

// KVM hypercall list.
//
// Canonical list of hypercalls supported.
const (
    // On amd64, it uses &apos;HLT&apos; to leave the guest.
    //
    // Unlike amd64, arm64 can only uses mmio_exit/psci to leave the guest.
    //
    // _KVM_HYPERCALL_VMEXIT is only used on arm64 for now.
    _KVM_HYPERCALL_VMEXIT int = iota
    _KVM_HYPERCALL_MAX
)
</code></pre>
<h4 id="gvisor&#x5BF9;cpu&#x548C;ring0kernel&#x7684;&#x62BD;&#x8C61;"><a name="gvisor&#x5BF9;cpu&#x548C;ring0kernel&#x7684;&#x62BD;&#x8C61;" class="anchor-navigation-ex-anchor" href="#gvisor&#x5BF9;cpu&#x548C;ring0kernel&#x7684;&#x62BD;&#x8C61;"><i class="fa fa-link" aria-hidden="true"></i></a>gvisor&#x5BF9;CPU&#x548C;ring0.kernel&#x7684;&#x62BD;&#x8C61;</h4>
<p>&#x6CE8;&#x610F;kernel&#x8FD9;&#x4E2A;&#x8BCD;&#x5728;gvisor&#x91CC;&#x6709;&#x4E24;&#x4E2A;&#x4E0D;&#x540C;&#x7684;&#x610F;&#x601D;:</p>
<ul>
<li>kernel.kernel: &#x662F;sentry&#x7684;&#x7528;&#x6237;&#x6001;kernel</li>
<li>ring0.kernel: &#x4E13;&#x95E8;&#x7BA1;&#x865A;&#x62DF;&#x5316;&#x7684;</li>
</ul>
<p><code>pkg/ring0/defs.go</code>
&#x4E00;&#x4E2A;kernel&#x53EF;&#x4EE5;&#x88AB;&#x591A;&#x4E2A;CPU&#x5171;&#x4EAB;</p>
<pre><code class="lang-go">// Kernel is a global kernel object.
//
// This contains global state, shared by multiple CPUs.
type Kernel struct {
    // PageTables are the kernel pagetables; this must be provided.
    PageTables *pagetables.PageTables

    KernelArchState
}
</code></pre>
<p>CPU</p>
<pre><code class="lang-go">// CPU is the per-CPU struct.
type CPU struct {
    // self is a self reference.
    //
    // This is always guaranteed to be at offset zero.
    self *CPU // &#x6301;&#x6709;&#x5BF9;&#x81EA;&#x5DF1;&#x7684;&#x5F15;&#x7528;, &#x7B2C;&#x4E00;&#x6B21;&#x89C1;&#x8FD9;&#x4E48;&#x7528;&#x7684;...

    // kernel is reference to the kernel that this CPU was initialized
    // with. This reference is kept for garbage collection purposes: CPU
    // registers may refer to objects within the Kernel object that cannot
    // be safely freed.
    kernel *Kernel

    // CPUArchState is architecture-specific state.
    CPUArchState

    // registers is a set of registers; these may be used on kernel system
    // calls and exceptions via the Registers function.
    registers arch.Registers

    // floatingPointState holds floating point state.
    floatingPointState fpu.State

    // hooks are kernel hooks.
    hooks Hooks
}
</code></pre>
<p>&#x5BF9;arm64&#x6765;&#x8BF4;:</p>
<pre><code class="lang-go">// KernelArchState contains architecture-specific state.
type KernelArchState struct {
}

// CPUArchState contains CPU-specific arch state.
type CPUArchState struct {
    // stack is the stack used for interrupts on this CPU.
    stack [128]byte //&#x4E2D;&#x65AD;&#x6808;&#x53EA;&#x6709;128&#x5B57;&#x8282;

    // errorCode is the error code from the last exception.
    errorCode uintptr

    // errorType indicates the type of error code here, it is always set
    // along with the errorCode value above.
    //
    // It will either by 1, which indicates a user error, or 0 indicating a
    // kernel error. If the error code below returns false (kernel error),
    // then it cannot provide relevant information about the last
    // exception.
    errorType uintptr

    // faultAddr is the value of far_el1.
    faultAddr uintptr

    // el0Fp is the address of application&apos;s fpstate.
    el0Fp uintptr

    // ttbr0Kvm is the value of ttbr0_el1 for sentry.
    ttbr0Kvm uintptr

    // ttbr0App is the value of ttbr0_el1 for applicaton.
    ttbr0App uintptr

    // exception vector.
    vecCode Vector

    // application context pointer.
    appAddr uintptr

    // lazyVFP is the value of cpacr_el1.
    lazyVFP uintptr

    // appASID is the asid value of guest application.
    appASID uintptr
}
</code></pre>
<h4 id="machine&#x548C;vcpu&#x7684;&#x5B9A;&#x4E49;"><a name="machine&#x548C;vcpu&#x7684;&#x5B9A;&#x4E49;" class="anchor-navigation-ex-anchor" href="#machine&#x548C;vcpu&#x7684;&#x5B9A;&#x4E49;"><i class="fa fa-link" aria-hidden="true"></i></a>machine&#x548C;vCPU&#x7684;&#x5B9A;&#x4E49;</h4>
<p>machine&#x5C31;&#x662F;&#x4E00;&#x4E2A;kvm new&#x51FA;&#x6765;&#x7684;&#x4E00;&#x4E2A;VM, &#x5305;&#x62EC;&#x4E00;&#x4E2A;kernel&#x548C;&#x591A;&#x4E2A;vCPU</p>
<pre><code class="lang-go">// machine contains state associated with the VM as a whole.
type machine struct {
    // fd is the vm fd.
    fd int

    // machinePoolIndex is the index in the machinePool array.
    machinePoolIndex uint32

    // nextSlot is the next slot for setMemoryRegion.
    //
    // This must be accessed atomically. If nextSlot is ^uint32(0), then
    // slots are currently being updated, and the caller should retry.
    nextSlot uint32

    // upperSharedPageTables tracks the read-only shared upper of all the pagetables.
    upperSharedPageTables *pagetables.PageTables

    // kernel is the set of global structures.
    kernel ring0.Kernel

    // mu protects vCPUs.
    mu sync.RWMutex

    // available is notified when vCPUs are available.
    available sync.Cond

    // vCPUsByTID are the machine vCPUs.
    //
    // These are populated dynamically.
    vCPUsByTID map[uint64]*vCPU

    // vCPUsByID are the machine vCPUs, can be indexed by the vCPU&apos;s ID.
    vCPUsByID []*vCPU

    // maxVCPUs is the maximum number of vCPUs supported by the machine.
    maxVCPUs int

    // maxSlots is the maximum number of memory slots supported by the machine.
    maxSlots int

    // tscControl checks whether cpu supports TSC scaling
    tscControl bool

    // usedSlots is the set of used physical addresses (not sorted).
    usedSlots []uintptr

    // nextID is the next vCPU ID.
    nextID uint32

    // machineArchState is the architecture-specific state.
    machineArchState
}
</code></pre>
<p>&#x6CE8;&#x610F;&#x8FD9;&#x91CC;&#x7684;vCPU&#x5176;&#x5B9E;&#x662F;&#x548C;KVM&#x7684;KVM_CREATE_VCPU&#x5BF9;&#x5E94;&#x7684;</p>
<pre><code class="lang-go">// vCPU is a single KVM vCPU.
type vCPU struct {
    // CPU is the kernel CPU data.
    //
    // This must be the first element of this structure, it is referenced
    // by the bluepill code (see bluepill_amd64.s).
    ring0.CPU // vCPU&#x5305;&#x542B;&#x4E86;CPU&#x7684;&#x62BD;&#x8C61;

    // id is the vCPU id.
    id int

    // fd is the vCPU fd.
    fd int

    // tid is the last set tid.
    tid uint64

    // userExits is the count of user exits.
    userExits uint64

    // guestExits is the count of guest to host world switches.
    guestExits uint64

    // faults is a count of world faults (informational only).
    faults uint32

    // state is the vCPU state.
    //
    // This is a bitmask of the three fields (vCPU*) described above.
    state uint32

    // runData for this vCPU.
    runData *runData

    // machine associated with this vCPU.
    machine *machine

    // active is the current addressSpace: this is set and read atomically,
    // it is used to elide unnecessary interrupts due to invalidations.
    active atomicAddressSpace

    // vCPUArchState is the architecture-specific state.
    vCPUArchState

    // dieState holds state related to vCPU death.
    dieState dieState
}
</code></pre>
<h3 id="pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;"><a name="pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;" class="anchor-navigation-ex-anchor" href="#pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.5. pagetable&#x4E4B;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;region&#x7684;map&#x8868;</h3>
<p><code>pkg/sentry/platform/kvm/physical_map.go</code>&#x5BF9;&#x865A;&#x62DF;&#x5730;&#x5740;&#x548C;&#x7269;&#x7406;&#x5730;&#x5740;&#x7684;&#x5B9A;&#x4E49;:</p>
<pre><code class="lang-go">type region struct {
    virtual uintptr
    length  uintptr
}

type physicalRegion struct {
    region
    physical uintptr
}

// &#x7528;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x8868;&#x793A;&#x6240;&#x6709;&#x7684;region
// region&#x4ECE;&#x865A;&#x62DF;&#x5730;&#x5740;0&#x5F00;&#x59CB;, &#x5230;ring0.MaximumUserAddress
// &#x7269;&#x7406;&#x5730;&#x5740;&#x4ECE;physical := uintptr(reservedMemory)&#x5F00;&#x59CB;.
// &#x8FD9;&#x4E2A;reservedMemory&#x5728;arm64&#x4E0A;&#x662F;0, &#x5728;amd64&#x4E0A;&#x662F;0x100000000
//&#x6BD4;&#x5982;&#x5728;x86&#x673A;&#x5668;&#x4E0A;
// physicalRegion: virtual [1000,3f5b92bd1000) =&gt; physical [100001000,3f5c92bd1000)
// physicalRegion: virtual [7f5d12bd1000,7ffffffff000) =&gt; physical [3f5c92bd1000,3fff7ffff000)
// &#x8FD9;&#x91CC;&#x7684;physical&#x5730;&#x5740;&#x4ECE;100001000(4G+1000)&#x5F00;&#x59CB;, &#x56E0;&#x4E3A;&#x5728;x86&#x4E0A;reservedMemory = 0x100000000

//&#x5728;arm64&#x4E0A;(a53)
// region: virtual [fef5ca6000,ffff75ca6000)
// physicalRegion: virtual [1000,10000) =&gt; physical [1000,10000)
// physicalRegion: virtual [10000,abf000) =&gt; physical [10000,abf000)
// physicalRegion: virtual [abf000,ac0000) =&gt; physical [abf000,ac0000)
// physicalRegion: virtual [ac0000,181f000) =&gt; physical [ac0000,181f000)
// physicalRegion: virtual [181f000,fef5ca6000) =&gt; physical [181f000,fef5ca6000)
// physicalRegion: virtual [ffff75ca6000,ffff9cb58000) =&gt; physical [fef5ca6000,ff1cb58000)
// physicalRegion: virtual [ffff9cb58000,ffff9cb59000) =&gt; physical [ff1cb58000,ff1cb59000)
// physicalRegion: virtual [ffff9cb59000,ffff9cb5a000) =&gt; physical [ff1cb59000,ff1cb5a000)
// physical_map.go:177] physicalRegion: virtual [ffff9cb5a000,fffffffff000) =&gt; physical [ff1cb5a000,ff7ffff000)

var physicalRegions []physicalRegion
</code></pre>
<p><code>pkg/sentry/platform/kvm/virtual_map.go</code></p>
<pre><code class="lang-go">type virtualRegion struct {
    region
    accessType hostarch.AccessType
    shared     bool
    offset     uintptr
    filename   string
}
</code></pre>
<p>&#x521D;&#x59CB;&#x7684;physicalRegions<del>&#x57FA;&#x672C;&#x4E0A;&#x662F;&#x4E2A;virtual &#x548C;physical 1:1&#x7684;&#x6620;&#x5C04;</del>&#x6839;&#x636E;host&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x548C;target&#x7684;VM&#x7269;&#x7406;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x8BA1;&#x7B97;&#x800C;&#x6765;, <code>applyPhysicalRegions()</code>&#x51FD;&#x6570;&#x4F1A;&#x904D;&#x5386;physicalRegions&#x4EE5;&#x6B64;&#x6765;&#x66F4;&#x6539;pagetable, &#x6BD4;&#x5982;<code>pkg/sentry/platform/kvm/machine_arm64.go</code>&#x4E2D;:</p>
<pre><code class="lang-go">func (m *machine) mapUpperHalf(pageTable *pagetables.PageTables) {
    applyPhysicalRegions(func(pr physicalRegion) bool {
        //&#x589E;&#x52A0;&#x4E00;&#x4E2A;pageTable&#x6620;&#x5C04;
        pageTable.Map(
            //&#x8FD9;&#x91CC;&#x5BF9;UpperHalf&#x6765;&#x8BF4;, &#x52A0;&#x4E0A;&#x4E86;ffff000000000000, &#x5373;&#x865A;&#x62DF;&#x5730;&#x5740;=&#x7269;&#x7406;&#x5730;&#x5740;+ffff000000000000
            hostarch.Addr(ring0.KernelStartAddress|pr.virtual),
            pr.length,
            pagetables.MapOpts{AccessType: hostarch.AnyAccess, Global: true},
            pr.physical)

        return true // Keep iterating.
    })
}
</code></pre>
<p>&#x540E;&#x9762;&#x4F1A;&#x770B;&#x5230; vCPU&#x521D;&#x59CB;&#x5316;&#x7684;&#x65F6;&#x5019;, &#x4F1A;&#x914D;&#x7F6E;&#x7528;&#x6237;&#x6001;&#x7684;TTBR0&#x548C;&#x5185;&#x6838;&#x6001;&#x7684;TTBR1
&#x6CE8;&#x610F;ttbr&#x914D;&#x7F6E;&#x7684;&#x662F;&#x7269;&#x7406;&#x5730;&#x5740;. &#x5BF9;VM&#x6765;&#x8BF4;, &#x5176;&#x7269;&#x7406;&#x5730;&#x5740;&#x5C31;&#x662F;&#x6240;&#x5728;qemu&#x8FDB;&#x7A0B;(&#x6216;gvisor&#x8FDB;&#x7A0B;)&#x7684;ptes&#x53D8;&#x91CF;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;.</p>
<pre><code class="lang-go">    // ttbr0_el1
    data = c.machine.kernel.PageTables.TTBR0_EL1(false, 0)

    reg.id = _KVM_ARM64_REGS_TTBR0_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    c.SetTtbr0Kvm(uintptr(data))

    // ttbr1_el1
    data = c.machine.kernel.PageTables.TTBR1_EL1(false, 0)

    reg.id = _KVM_ARM64_REGS_TTBR1_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }
</code></pre>
<p>TTBR0&#x548C;TTBR1&#x5206;&#x522B;&#x662F; PageTables&#x4E0B;&#x9762;&#x7684;&#x4E24;&#x4E2A;&#x5730;&#x5740;: rootPhysical&#x548C;archPageTables.rootPhysical</p>
<pre><code class="lang-go">// TTBR0_EL1 returns the translation table base register 0.
//
//go:nosplit
func (p *PageTables) TTBR0_EL1(noFlush bool, asid uint16) uint64 {
    return uint64(p.rootPhysical) | (uint64(asid)&amp;ttbrASIDMask)&lt;&lt;ttbrASIDOffset
}

// TTBR1_EL1 returns the translation table base register 1.
//
//go:nosplit
func (p *PageTables) TTBR1_EL1(noFlush bool, asid uint16) uint64 {
    return uint64(p.archPageTables.rootPhysical) | (uint64(asid)&amp;ttbrASIDMask)&lt;&lt;ttbrASIDOffset
}
</code></pre>
<p>TTBR0&#x7684;&#x5730;&#x5740;&#x662F;&#x5728;<code>pkg/ring0/pagetables/pagetables.go</code>&#x7684;PageTables&#x7684;Init&#x91CC;&#x9762;&#x8D4B;&#x503C;&#x7684;:</p>
<pre><code class="lang-go">// Init initializes a set of PageTables.
//
// +checkescape:hard,stack
//go:nosplit
func (p *PageTables) Init(allocator Allocator) {
    p.Allocator = allocator
    p.root = p.Allocator.NewPTEs()
    p.rootPhysical = p.Allocator.PhysicalFor(p.root)
}
</code></pre>
<p>&#x800C;TTBR1&#x7684;&#x5730;&#x5740;&#x5728;<code>pkg/ring0/pagetables/pagetables_arm64.go</code></p>
<pre><code class="lang-go">// InitArch does some additional initialization related to the architecture.
//
// +checkescape:hard,stack
//go:nosplit
func (p *PageTables) InitArch(allocator Allocator) {
    if p.upperSharedPageTables != nil {
        p.cloneUpperShared()
    } else {
        p.archPageTables.root = p.Allocator.NewPTEs()
        p.archPageTables.rootPhysical = p.Allocator.PhysicalFor(p.archPageTables.root)
    }
}
</code></pre>
<p>&#x6709;&#x4E24;&#x79CD;Allocator, </p>
<ul>
<li><code>pkg/ring0/pagetables/allocator.go</code>
&#x8FD9;&#x662F;base&#x7684;allocator, &#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x5728;<code>pkg/ring0/pagetables/allocator_unsafe.go</code>, &#x5C31;&#x662F;&#x666E;&#x901A;&#x7684;new&#x4E00;&#x4E2A;PTE table&#x7684;&#x7ED3;&#x6784;&#x4F53;, &#x5B83;&#x7684;<code>PhysicalFor</code>&#x51FD;&#x6570;&#x5B9E;&#x9645;&#x4E0A;&#x83B7;&#x53D6;&#x7684;&#x662F;&#x8FD9;&#x4E2A;PTE&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;, <code>uintptr(unsafe.Pointer(ptes))</code>;
&#x8FD9;&#x4E2A;allocator&#x662F;&#x7ED9;kernel&#x7528;&#x7684;, &#x56E0;&#x4E3A;kernel&#x8FD0;&#x884C;&#x5728;vm&#x5916;&#x9762;; &#x4ECE;&#x5916;&#x9762;&#x770B;, vm&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;&#x5C31;&#x662F;&#x5916;&#x9762;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;.</li>
<li><code>pkg/sentry/platform/kvm/bluepill_allocator.go</code>
KVM&#x7684;bluepill&#x7684;&#x5B9E;&#x73B0;&#x662F;&#x7528;base&#x7684;allocator&#x7533;&#x8BF7;PTE&#x8868;, &#x518D;&#x7528;bluepill&#x8FDB;&#x5165;guest&#x6A21;&#x5F0F;&#x4E00;&#x6B21;, &#x7136;&#x540E;&#x9000;&#x51FA;guest.<pre><code class="lang-go">func (a *allocator) NewPTEs() *pagetables.PTEs {
  ptes := a.base.NewPTEs() // escapes: bluepill below.
  if a.cpu != nil {
      bluepill(a.cpu)
  }
  return ptes
}
// PhysicalFor returns the physical address for a set of PTEs.
// translateToPhysical()&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5C31;&#x662F;&#x4ECE;&#x5168;&#x5C40;&#x8868;physicalRegions&#x91CC;&#x9762;&#x5339;&#x914D;&#x865A;&#x62DF;&#x5730;&#x5740;&#x627E;&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;.
// &#x7EAF;&#x8F6F;&#x4EF6;&#x67E5;&#x8868;, &#x6CA1;&#x6709;&#x786C;&#x4EF6;&#x53C2;&#x4E0E;.
func (a *allocator) PhysicalFor(ptes *pagetables.PTEs) uintptr {
  virtual := a.base.PhysicalFor(ptes)
  physical, _, ok := translateToPhysical(virtual)
  if !ok {
      panic(fmt.Sprintf(&quot;PhysicalFor failed for %p&quot;, ptes)) // escapes: panic.
  }
  return physical
}
</code></pre>
&#x8FD9;&#x4E2A;&#x662F;&#x7ED9;&#x91CC;&#x9762;&#x7528;&#x7684;. </li>
</ul>
<h4 id="kvmsetusermemoryregion"><a name="kvmsetusermemoryregion" class="anchor-navigation-ex-anchor" href="#kvmsetusermemoryregion"><i class="fa fa-link" aria-hidden="true"></i></a>KVM_SET_USER_MEMORY_REGION</h4>
<p>kvm&#x5927;&#x6982;&#x652F;&#x6301;512&#x4E2A;slot, gvisor&#x5B9A;&#x4E49;&#x4E86;faultBlockSize&#x4E3A;2G.</p>
<p><code>setMemoryRegion()</code>&#x51FD;&#x6570;&#x8C03;&#x7528;&#x4E86;kvm&#x7684;KVM_SET_USER_MEMORY_REGION API:</p>
<pre><code class="lang-go">// setMemoryRegion initializes a region.
//
// This may be called from bluepillHandler, and therefore returns an errno
// directly (instead of wrapping in an error) to avoid allocations.
//
//go:nosplit
func (m *machine) setMemoryRegion(slot int, physical, length, virtual uintptr, flags uint32) unix.Errno {
    userRegion := userMemoryRegion{
        slot:          uint32(slot),
        flags:         uint32(flags),
        guestPhysAddr: uint64(physical),
        memorySize:    uint64(length),
        userspaceAddr: uint64(virtual),
    }

    // Set the region.
    _, _, errno := unix.RawSyscall(
        unix.SYS_IOCTL,
        uintptr(m.fd),
        _KVM_SET_USER_MEMORY_REGION,
        uintptr(unsafe.Pointer(&amp;userRegion)))
    return errno
}
</code></pre>
<p>&#x6CE8;&#x610F;&#x8FD9;&#x4E2A;API&#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x544A;&#x8BC9;KVM, &#x53D1;&#x751F;&#x5728;EL2&#x7684;&#x7B2C;&#x4E8C;&#x9636;&#x6BB5;&#x7684;&#x5730;&#x5740;&#x8BE5;&#x5982;&#x4F55;&#x7FFB;&#x8BD1;:</p>
<pre><code>&#x521D;&#x59CB;&#x5316;VM: 
    ioctl KVM_SET_USER_MEMORY_REGION : &#x51B3;&#x5B9A;&#x4E86;VM_PA --&gt; host_VA
&#x7B2C;&#x4E00;&#x9636;&#x6BB5;: VM_VA --&gt; VM_PA
&#x7B2C;&#x4E8C;&#x9636;&#x6BB5;: VM_PA --&gt; host_VA --&gt; host_PA
</code></pre><p><code>mapPhysical()</code>&#x8C03;&#x7528;&#x4E86;<code>setMemoryRegion()</code>&#x51FD;&#x6570;&#x4ECE;&#x5168;&#x5C40;&#x8868;physicalRegions, &#x6309;&#x7167;&#x5165;&#x53C2;&#x7269;&#x7406;&#x5730;&#x5740;&#x548C;&#x957F;&#x5EA6;, &#x8C03;&#x7528;kvm&#x7684;ioctl&#x6765;&#x6620;&#x5C04;USER_MEMORY_REGION</p>
<pre><code class="lang-go">// mapPhysical&#x7684;&#x5165;&#x53C2;phyRegions&#x90FD;&#x662F;&#x4F20;&#x5165;&#x5168;&#x5C40;&#x53D8;&#x91CF;physicalRegions
//&#x6BD4;&#x5982;&#x5728;x86&#x673A;&#x5668;&#x4E0A;
// physicalRegion: virtual [1000,3f5b92bd1000) =&gt; physical [100001000,3f5c92bd1000)
// physicalRegion: virtual [7f5d12bd1000,7ffffffff000) =&gt; physical [3f5c92bd1000,3fff7ffff000)
// &#x8FD9;&#x91CC;&#x7684;physical&#x5730;&#x5740;&#x4ECE;100001000(4G+1000)&#x5F00;&#x59CB;, &#x56E0;&#x4E3A;&#x5728;x86&#x4E0A;reservedMemory = 0x100000000

(m *machine) mapPhysical(physical, length uintptr, phyRegions []physicalRegion, flags uint32)
    //&#x4F20;&#x5165;physical, &#x4ECE;phyRegions&#x91CC;&#x67E5;&#x8868;, &#x5E76;&#x8003;&#x8651;&#x5BF9;&#x9F50;, &#x8FD4;&#x56DE;virtualStart, physicalStart, length
    _, physicalStart, length, ok := calculateBluepillFault(physical, phyRegions)
    //&#x5982;&#x679C;&#x6CA1;map
    if !m.hasSlot(physicalStart)
        handleBluepillFault(m, physical, phyRegions, flags)
            //&#x53C8;&#x6765;&#x4E00;&#x6B21;
            virtualStart, physicalStart, length, pr := calculateBluepillFault(physical, phyRegions)
            //&#x56E0;&#x4E3A;kvm&#x662F;&#x4EE5;slot&#x6765;&#x7BA1;&#x7406;&#x5185;&#x5B58;&#x7684;, &#x8FD9;&#x91CC;&#x7528;atomic&#x548C;for&#x5FAA;&#x73AF;&#x6765;&#x81EA;&#x5DF1;&#x505A;&#x4E92;&#x65A5;
            slot := atomic.SwapUint32(&amp;m.nextSlot, ^uint32(0))
            for slot == ^uint32(0) { //&#x5728;&#x8FD9;&#x91CC;&#x7B49;&#x5F85;atomic&#x6362;&#x51FA;&#x7684;value&#x4E0D;&#x662F;ffffffff
                yield() // Race with another call.
                slot = atomic.SwapUint32(&amp;m.nextSlot, ^uint32(0))
            }
            m.setMemoryRegion(int(slot), physicalStart, length, virtualStart, flags)
                //&#x7528;KVM&#x7684;_KVM_SET_USER_MEMORY_REGION ioctl&#x628A;
                unix.RawSyscall(unix.SYS_IOCTL, ..._KVM_SET_USER_MEMORY_REGION...)
</code></pre>
<h4 id="mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;&#x7528;&#x6237;&#x6001;page-falut&#x5904;&#x7406;&#x8DEF;&#x5F84;"><a name="mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;&#x7528;&#x6237;&#x6001;page-falut&#x5904;&#x7406;&#x8DEF;&#x5F84;" class="anchor-navigation-ex-anchor" href="#mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;&#x7528;&#x6237;&#x6001;page-falut&#x5904;&#x7406;&#x8DEF;&#x5F84;"><i class="fa fa-link" aria-hidden="true"></i></a>mapPhysical()&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;&#x7528;&#x6237;&#x6001;page falut&#x5904;&#x7406;&#x8DEF;&#x5F84;</h4>
<pre><code class="lang-go">//pkg/sentry/mm
(mm *MemoryManager) handleASIOFault()
    mm.mapASLocked()

(mm *MemoryManager) HandleUserFault()
    mm.mapASLocked()

(mm *MemoryManager) populateVMA()
    mm.mapASLocked()

(mm *MemoryManager) populateVMAAndUnlock()
    mm.mapASLocked()

(mm *MemoryManager) MLock()
    mm.mapASLocked()

(mm *MemoryManager) MLockAll()
    mm.mapASLocked()

//pkg/sentry/mm/address_space.go
(mm *MemoryManager) mapASLocked()
    //pkg/sentry/platform/kvm/address_space.go
    mm.as.MapFile()
        as.mapLocked()
            //pkg/sentry/platform/kvm/machine.go
            as.machine.mapPhysical()
                //pkg/sentry/platform/kvm/bluepill_fault.go
                handleBluepillFault()
                    //pkg/sentry/platform/kvm/machine_unsafe.go
                    m.setMemoryRegion()
                        unix.RawSyscall(unix.SYS_IOCTL, _KVM_SET_USER_MEMORY_REGION)
</code></pre>
<h4 id="mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;seccompmmaphandler"><a name="mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;seccompmmaphandler" class="anchor-navigation-ex-anchor" href="#mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;seccompmmaphandler"><i class="fa fa-link" aria-hidden="true"></i></a>mapPhysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;seccompMmapHandler</h4>
<p>&#x5728;new&#x4E00;&#x4E2A;VM&#x7684;&#x65F6;&#x5019;, host&#x8FDB;&#x7A0B;&#x7684;mmap&#x4F1A;&#x88AB;seccomp&#x62E6;&#x622A;, &#x8F6C;&#x7531;seccompMmapHandler()&#x6765;&#x5904;&#x7406;<br>&#x51C6;&#x786E;&#x7684;&#x8BF4;, &#x5728;newMachine()&#x91CC;&#x9762;, seccompMmapRules()&#x7528;sigsysHandler&#x6765;&#x5904;&#x7406;sigsys</p>
<pre><code class="lang-go">// seccompMmapRules adds seccomp rules to trap mmap system calls that will be
// handled in seccompMmapHandler.
func seccompMmapRules(m *machine) {
    // &#x53EA;&#x5728;host&#x8FDB;&#x7A0B;&#x6267;&#x884C;&#x4E00;&#x6B21;
    seccompMmapRulesOnce.Do(func() {
        // &#x8C03;&#x7528;unix.RawSyscall6(unix.SYS_RT_SIGACTION, ...)&#x66FF;&#x6362;handler
        sighandling.ReplaceSignalHandler(unix.SIGSYS, addrOfSigsysHandler(), &amp;savedSigsysHandler)
        rules := []seccomp.RuleSet{}
        rules = append(rules, []seccomp.RuleSet{
            // Trap mmap system calls and handle them in sigsysGoHandler
            {
                Rules: seccomp.SyscallRules{
                    unix.SYS_MMAP: {
                        {
                            seccomp.MatchAny{},
                            seccomp.MatchAny{},
                            seccomp.MaskedEqual(unix.PROT_EXEC, 0),
                            /* MAP_DENYWRITE is ignored and used only for filtering. */
                            seccomp.MaskedEqual(unix.MAP_DENYWRITE, 0),
                        },
                    },
                },
                Action: linux.SECCOMP_RET_TRAP,
            },
        }...)
        instrs, err := seccomp.BuildProgram(rules, linux.SECCOMP_RET_ALLOW, linux.SECCOMP_RET_ALLOW)
    })
    ...
</code></pre>
<p>&#x6839;&#x636E;sigaction&#x7684;&#x914D;&#x7F6E;, sigsys&#x88AB;&#x89E6;&#x53D1;&#x7684;&#x65F6;&#x5019;, <code>sigsysHandler(int sig,  siginfo_t  *info,  void  *ucontext)</code>&#x4F1A;&#x88AB;&#x8C03;&#x7528;</p>
<pre><code class="lang-go">// The arguments are the following:
//
//     R0 - The signal number.
//     R1 - Pointer to siginfo_t structure.
//     R2 - Pointer to ucontext structure.
//
TEXT &#xB7;sigsysHandler(SB),NOSPLIT,$0
    // si_code should be SYS_SECCOMP.
    MOVD    SIGINFO_CODE(R1), R7
    CMPW    $1, R7
    BNE    fallback

    CMPW    $SYS_MMAP, R8
    BNE    fallback

    MOVD    R2, 8(RSP)
    BL    &#xB7;seccompMmapHandler(SB)   // Call the handler.

    RET

fallback:
    // Jump to the previous signal handler.
    MOVD    &#xB7;savedHandler(SB), R7
    B    (R7)

// &#x53D6;&#x4E0A;&#x9762;&#x51FD;&#x6570;&#x7684;&#x5730;&#x5740;
// func addrOfSighandler() uintptr
TEXT &#xB7;addrOfSigsysHandler(SB), $0-8
    MOVD    $&#xB7;sigsysHandler(SB), R0
    MOVD    R0, ret+0(FP)
    RET
</code></pre>
<p>&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;, &#x5728;&#x521D;&#x59CB;&#x5316;&#x7684;&#x65F6;&#x5019;, host&#x8FDB;&#x7A0B;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x6709;&#x5F88;&#x591A;&#x5DF2;&#x7ECF;mmap&#x6210;&#x4E86;&#x4E0D;&#x53EF;&#x8BBF;&#x95EE;, &#x90A3;&#x4E48;&#x540E;&#x9762;&#x7684;mmap&#x5F97;&#x5230;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;, &#x5E94;&#x8BE5;&#x662F;&#x843D;&#x5728;&#x548C;&#x76EE;&#x6807;VM&#x7269;&#x7406;&#x5730;&#x5740;&#x8303;&#x56F4;(40bit)&#x7684;&#x8FDE;&#x7EED;&#x5730;&#x5740;&#x7A7A;&#x95F4;.
&#x5728;&#x8FD9;&#x4E2A;signal&#x5904;&#x7406;&#x51FD;&#x6570;&#x91CC;&#x9762;, &#x8C03;&#x7528;&#x4E86;seccompMmapHandler</p>
<pre><code class="lang-go">// seccompMmapHandler is a signal handler for runtime mmap system calls
// that are trapped by seccomp.
//
// It executes the mmap syscall with specified arguments and maps a new region
// to the guest.
//
//go:nosplit
func seccompMmapHandler(context unsafe.Pointer) {
    //&#x4ECE;ucontext&#x4E0A;&#x4E0B;&#x6587;&#x6062;&#x590D;&#x5F53;&#x65F6;mmap&#x7684;&#x5165;&#x53C2;, &#x5E76;&#x91CD;&#x65B0;&#x8C03;&#x7528;mmap
    addr, length, errno := seccompMmapSyscall(context)
        //&#x7C7B;&#x4F3C;&#x8FD9;&#x6837;:
        unix.RawSyscall6(uintptr(ctx.Regs[8]), uintptr(ctx.Regs[0]), ...)
    for &#x5728;machinePool&#x91CC;&#x6240;&#x6709;host&#x8FDB;&#x7A0B;&#x7BA1;&#x7406;&#x7684;VM
        physical, length, ok := translateToPhysical(virtual)
        //&#x7528;KVM&#x7684;SET_USER_MEMORY_REGION ioctl&#x6765;&#x914D;&#x7F6E;kvm&#x7684;&#x7B2C;&#x4E8C;&#x6B21;&#x7FFB;&#x8BD1;
        m.mapPhysical(physical, length, physicalRegions)
}
</code></pre>
<p>&#x6CE8;: <code>man sigaction</code>
sigaction&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x63A5;&#x53D7;&#x4E24;&#x79CD;&#x5F62;&#x5F0F;&#x7684;handler</p>
<pre><code class="lang-c">           struct sigaction {
               void     (*sa_handler)(int);
               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask;
               int        sa_flags;
               void     (*sa_restorer)(void);
           };
</code></pre>
<p>&#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x7528;&#x7684;&#x662F;<code>void     (*sa_sigaction)(int, siginfo_t *, void *)</code></p>
<blockquote>
<p>If  SA_SIGINFO  is specified in sa_flags, then sa_sigaction (instead of sa_handler) specifies the signal-handling function for signum.  This function receives three arguments, as described below.</p>
</blockquote>
<pre><code class="lang-c">           void
           handler(int sig, siginfo_t *info, void *ucontext)
           {
               ...
           }

       These three arguments are as follows

       sig    The number of the signal that caused invocation of the handler.

       info   A pointer to a siginfo_t, which is a structure containing further information about the signal, as described below.

       ucontext
              This is a pointer to a ucontext_t structure, cast to void *.  The structure pointed to by this field contains signal context information that was  saved  on  the  user-space  stack  by  the  kernel;  for details, see sigreturn(2).  Further information about the ucontext_t structure can be found in getcontext(3).  Commonly, the handler
              function doesn&apos;t make any use of the third argument.

       The siginfo_t data type is a structure with the following fields:

           siginfo_t {
               int      si_signo;     /* Signal number */
               int      si_errno;     /* An errno value */
               int      si_code;      /* Signal code */
               int      si_trapno;    /* Trap number that caused
                                         hardware-generated signal
                                         (unused on most architectures) */
               pid_t    si_pid;       /* Sending process ID */
               uid_t    si_uid;       /* Real user ID of sending process */
               int      si_status;    /* Exit value or signal */
               clock_t  si_utime;     /* User time consumed */
               clock_t  si_stime;     /* System time consumed */
               sigval_t si_value;     /* Signal value */
               int      si_int;       /* POSIX.1b signal */
               void    *si_ptr;       /* POSIX.1b signal */
               int      si_overrun;   /* Timer overrun count;
                                         POSIX.1b timers */
               int      si_timerid;   /* Timer ID; POSIX.1b timers */
               void    *si_addr;      /* Memory location which caused fault */
               long     si_band;      /* Band event (was int in
                                         glibc 2.3.2 and earlier) */
               int      si_fd;        /* File descriptor */
               short    si_addr_lsb;  /* Least significant bit of address
                                         (since Linux 2.6.32) */
               void    *si_lower;     /* Lower bound when address violation
                                         occurred (since Linux 3.19) */
               void    *si_upper;     /* Upper bound when address violation
                                         occurred (since Linux 3.19) */
               int      si_pkey;      /* Protection key on PTE that caused
                                         fault (since Linux 4.6) */
               void    *si_call_addr; /* Address of system call instruction
                                         (since Linux 3.5) */
               int      si_syscall;   /* Number of attempted system call
                                         (since Linux 3.5) */
               unsigned int si_arch;  /* Architecture of attempted system call
                                         (since Linux 3.5) */
           }
</code></pre>
<p>&#x6CE8;2: <code>man sigretrun</code><br>&#x8FD9;&#x4E5F;&#x662F;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x4F46;&#x4E0D;&#x80FD;&#x88AB;&#x7528;&#x6237;&#x76F4;&#x63A5;&#x8C03;&#x7528;, &#x800C;&#x662F;&#x88AB;libc&#x8C03;&#x7528;&#x505A;&#x4E3A;<code>signal trampoline(&#x8E66;&#x5E8A;)</code>.<br>kernel&#x5728;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x6001;&#x7684;&#x65F6;&#x5019;, &#x770B;&#x5230;&#x6709;signal pending, &#x5C31;&#x628A;&#x5F53;&#x524D;&#x4E0A;&#x4E0B;&#x6587;ucontext&#x4FDD;&#x5B58;&#x5728;&#x8BE5;&#x8FDB;&#x7A0B;&#x7684;&#x7528;&#x6237;&#x7A7A;&#x95F4;, &#x7136;&#x540E;&#x8C03;&#x7528;&#x7528;&#x6237;&#x6001;&#x7684;sighandler, &#x5F53;&#x8FD9;&#x4E2A;handler&#x8FD4;&#x56DE;&#x7684;&#x65F6;&#x5019;, &#x8FD4;&#x56DE;&#x5230;libc&#x7684;<code>signal trampoline</code>&#x4EE3;&#x7801;, <code>sigreturn</code>&#x5728;&#x8FD9;&#x4E2A;<code>trampoline</code>&#x4EE3;&#x7801;&#x91CC;&#x88AB;&#x8C03;&#x7528;, &#x8FD9;&#x662F;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x5185;&#x6838;&#x4F1A;&#x628A;&#x4E4B;&#x524D;&#x7684;&#x4E3A;&#x8C03;&#x7528;sighandler&#x7684;&#x51C6;&#x5907;&#x5DE5;&#x4F5C;undo, &#x4ECE;ucontext&#x91CC;&#x9762;&#x6062;&#x590D;&#x4E0A;&#x4E0B;&#x6587;, &#x6062;&#x590D;&#x539F;&#x6765;&#x8FDB;&#x7A0B;&#x7684;&#x6267;&#x884C;.</p>
<blockquote>
<p>If the Linux kernel determines that an unblocked signal is pending for a process, then, at the next transition back to user mode in that process (e.g., upon return from a sys&#x2010;tem call or when the process is rescheduled onto the CPU), it creates a new frame on the user-space stack where it saves various pieces of process  context  (processor  status word, registers, signal mask, and signal stack settings).</p>
<p>The  kernel  also  arranges  that,  during the transition back to user mode, the signal handler is called, and that, upon return from the handler, control passes to a piece of user-space code commonly called the &quot;signal trampoline&quot;.  The signal trampoline code in turn calls sigreturn().</p>
<p>This sigreturn() call undoes everything that was done&#x2014;changing the process&apos;s signal mask, switching signal stacks (see sigaltstack(2))&#x2014;in order to invoke the  signal  handler. Using  the information that was earlier saved on the user-space stack sigreturn() restores the process&apos;s signal mask, switches stacks, and restores the process&apos;s context (processor flags and registers, including the stack pointer and instruction pointer), so that the process resumes execution at the point where it was interrupted by the signal.</p>
</blockquote>
<h4 id="mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;newmachine"><a name="mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;newmachine" class="anchor-navigation-ex-anchor" href="#mapphysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;newmachine"><i class="fa fa-link" aria-hidden="true"></i></a>mapPhysical&#x7684;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x4E4B;newMachine</h4>
<p>&#x89C1;&#x4E0B;&#x9762;</p>
<h3 id="kvm&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;vm"><a name="kvm&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;vm" class="anchor-navigation-ex-anchor" href="#kvm&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;vm"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.6. KVM&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;VM</h3>
<p>New&#x4E00;&#x4E2A;kvm&#x5B9E;&#x4F8B;&#x5C31;&#x662F;</p>
<pre><code class="lang-go">func New() {
    deviceFile, err := os.OpenFile(&quot;/dev/kvm&quot;, unix.O_RDWR, 0)
    fd := deviceFile.Fd()
    // &#x6CE8;&#x610F;&#x8FD9;&#x91CC;, &#x4E0D;&#x7BA1;New&#x591A;&#x5C11;&#x4E2A;VM, updateGlobalOnce&#x53EA;&#x88AB;&#x8C03;&#x7528;&#x4E00;&#x6B21;
    // 
    // Ensure global initialization is done.
    globalOnce.Do(func() {
        globalErr = updateGlobalOnce(int(fd))
            physicalInit()
                //&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5728;host&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x5185;, &#x8C03;&#x7528;&#x591A;&#x6B21;mmap, &#x4F7F;&#x5176;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x5145;&#x6EE1;unix.PROT_NONE&#x5C5E;&#x6027;(&#x5373;&#x4E0D;&#x53EF;&#x8BBF;&#x95EE;)&#x7684;mmap&#x6620;&#x5C04;, &#x6700;&#x540E;&#x53EA;&#x4FDD;&#x7559;&#x4E00;&#x4E2A;&#x5C0F;&#x4E8E;40bit&#x7684;host&#x5730;&#x5740;&#x7A7A;&#x95F4;
                //&#x6B63;&#x5982;&#x5176;&#x540D;&#x79F0;&#x6240;&#x793A;, &#x7528;&#x4E0D;&#x53EF;&#x8BBF;&#x95EE;&#x7684;&#x5730;&#x5740;&#x6620;&#x5C04;&#x586B;&#x5145;host&#x7684;&#x5927;&#x90E8;&#x5206;&#x5730;&#x5740;&#x7A7A;&#x95F4;, &#x53EA;&#x4FDD;&#x7559;&#x4E00;&#x4E2A;&#x5C0F;&#x4E8E;40bit(ARM64)&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;.
                //&#x8FD9;&#x4E48;&#x505A;&#x7684;&#x76EE;&#x7684;&#x662F;&#x8BA9;host&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x53EF;&#x4EE5;injective
                fillAddressSpace() // &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x5DF2;&#x7ECF;map&#x4E86;&#x7684;&#x5730;&#x5740;&#x533A;&#x57DF;, &#x8FD9;&#x4E9B;&#x533A;&#x57DF;&#x662F;excludedRegions
                //&#x5C06;&#x4E0A;&#x9762;excludedRegions&#x9010;&#x4E2A;addValidRegion&#x5230;&#x5168;&#x5C40;&#x8868;physicalRegions, &#x7269;&#x7406;&#x5730;&#x5740;&#x4ECE;reservedMemory(arm64&#x4E0A;&#x662F;0)&#x5F00;&#x59CB;&#x9012;&#x589E;
                //&#x5C06;&#x5269;&#x4E0B;&#x7684;host&#x5730;&#x5740;&#x7A7A;&#x95F4;(&#x5373;&#x4E0A;&#x9762;&#x4FDD;&#x7559;&#x7684;40bit&#x5927;&#x5C0F;&#x7684;&#x7A7A;&#x95F4;)addValidRegion&#x5230;&#x5168;&#x5C40;&#x8868;physicalRegions
                //&#x6545;&#x5168;&#x5C40;&#x8868;physicalRegion&#x4E0D;&#x662F;1:1&#x7684;&#x7269;&#x7406;&#x5230;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7684;&#x6620;&#x5C04;
                //&#x800C;&#x662F;&#x7269;&#x7406;&#x5730;&#x5740;&#x4ECE;0&#x5F00;&#x59CB;&#x7684;, &#x591A;&#x4E2A;&#x5230;host&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x6620;&#x5C04;; &#x524D;&#x9762;&#x7684;&#x591A;&#x7EC4;&#x6620;&#x5C04;&#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x4E0D;&#x80FD;&#x8BBF;&#x95EE;&#x7684;, &#x53EA;&#x6709;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x6620;&#x5C04;&#x624D;&#x662F;VM&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x5230;host&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x4E00;&#x4E2A;
                //&#x6BD4;&#x5982;&#x5728;x86&#x673A;&#x5668;&#x4E0A;
                // physicalRegion: virtual [1000,3f5b92bd1000) =&gt; physical [100001000,3f5c92bd1000)
                // physicalRegion: virtual [7f5d12bd1000,7ffffffff000) =&gt; physical [3f5c92bd1000,3fff7ffff000)
                // &#x8FD9;&#x91CC;&#x7684;physical&#x5730;&#x5740;&#x4ECE;100001000(4G+1000)&#x5F00;&#x59CB;, &#x56E0;&#x4E3A;&#x5728;x86&#x4E0A;reservedMemory = 0x100000000
                computePhysicalRegions()
            updateSystemValues(int(fd))
            ring0.Init()
    })

    for { //&#x76F4;&#x63A5;&#x7684;syscall&#x8C03;&#x7528;&#x8981;&#x81EA;&#x5DF1;&#x7528;&#x4E2A;for&#x6765;&#x5904;&#x7406;unix.EINTR, man 7 signal&#x8BF4;&#x7684;&#x5F88;&#x6E05;&#x695A;, &#x50CF;read/write/ioctl&#x7B49;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x4F5C;&#x7528;&#x5728;slow&#x7684;device&#x4E0A;, &#x5982;&#x679C;&#x5728;&#x8FD8;&#x6CA1;&#x6709;transfer&#x6570;&#x636E;&#x524D;&#x88AB;signal&#x6253;&#x65AD;, &#x6839;&#x636E;SA_RESTART&#x7684;&#x60C5;&#x51B5;, &#x53EF;&#x4EE5;&#x8FD4;&#x56DE;EINTR
        vm, _, errno = unix.Syscall(unix.SYS_IOCTL, fd, _KVM_CREATE_VM, 0)
        if errno == unix.EINTR {
            continue
        }
        if errno != 0 {
            return nil, fmt.Errorf(&quot;creating VM: %v&quot;, errno)
        }
        break
    }
    // Create a VM context.
    machine, err := newMachine(int(vm))
    // All set.
    return &amp;KVM{
        machine: machine,
    }, nil
}

// NewContext returns an interruptible context.
func (k *KVM) NewContext() platform.Context {
    return &amp;context{
        machine: k.machine,
    }
}
</code></pre>
<h4 id="newmachine"><a name="newmachine" class="anchor-navigation-ex-anchor" href="#newmachine"><i class="fa fa-link" aria-hidden="true"></i></a>newMachine</h4>
<pre><code class="lang-go">// newMachine returns a new VM context.
func newMachine(vm int) (*machine, error) {
    // Create the machine.
    m := &amp;machine{fd: vm}
    // Pull the maximum vCPUs.
    // CPU&#x865A;&#x62DF;&#x5316;: &#x6700;&#x5927;&#x7684;vCPU&#x4E2A;&#x6570;
    m.getMaxVCPU()
    // Pull the maximum slots.
    // &#x5185;&#x5B58;&#x865A;&#x62DF;&#x5316;: &#x6700;&#x5927;&#x7684;&#x5185;&#x5B58;slot&#x6570;, &#x5927;&#x6982;512&#x4E2A;
    unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CHECK_EXTENSION, _KVM_CAP_MAX_MEMSLOTS)
    // Check TSC Scaling
    unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CHECK_EXTENSION, _KVM_CAP_TSC_CONTROL)

    // Create the upper shared pagetables and kernel(sentry) pagetables.
    m.upperSharedPageTables = pagetables.New(newAllocator())
    // &#x5E94;&#x8BE5;&#x662F;&#x5BF9;&#x5E94;ffff000000000000&#x7A7A;&#x95F4;(kernel)
    // map &#x865A;&#x62DF;&#x5730;&#x5740;=&#x7269;&#x7406;&#x5730;&#x5740;+ffff000000000000
    m.mapUpperHalf(m.upperSharedPageTables)
    m.upperSharedPageTables.MarkReadOnlyShared()
    //&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;pagetable, &#x5E76;&#x628A;upper pagetable&#x8BBE;&#x4E3A;&#x4E0A;&#x9762;&#x7684;m.upperSharedPageTables
    m.kernel.PageTables = pagetables.NewWithUpper(newAllocator(), m.upperSharedPageTables, ring0.KernelStartAddress) // KernelStartAddress&#x662F;ffff000000000000

    // Install seccomp rules to trap runtime mmap system calls. They will
    // be handled by seccompMmapHandler.
    // &#x914D;&#x7F6E;seccomp&#x4E3A;trap mmap, &#x5176;&#x4ED6;allow; mmap&#x4F1A;&#x89E6;&#x53D1;SIGSYS&#x4FE1;&#x53F7;
    // &#x5F53;newMachine&#x7684;&#x8FDB;&#x7A0B;(&#x975E;guest)&#x8C03;&#x7528;mmap&#x65F6;, seccompMmapHandler()&#x4F1A;&#x88AB;&#x8C03;&#x7528;(&#x4F4D;&#x4E8E;pkg/sentry/platform/kvm/machine_unsafe.go)
    // &#x5F53;host&#x8FDB;&#x7A0B;(&#x5305;&#x62EC;VM&#x7684;&#x8FDB;&#x7A0B;)mmap&#x7684;&#x65F6;&#x5019;, mmap&#x4F1A;&#x89E6;&#x53D1;SIGSYS&#x4FE1;&#x53F7;, handler&#x91CC;&#x9762;
    // &#x4E3A;&#x6BCF;&#x4E2A;VM, &#x90FD;&#x4F7F;&#x7528;m.mapPhysical(physical, length, physicalRegions, _KVM_MEM_FLAGS_NONE)
    seccompMmapRules(m)

    // Apply the physical mappings. Note that these mappings may point to
    // guest physical addresses that are not actually available. These
    // physical pages are mapped on demand, see kernel_unsafe.go.
    applyPhysicalRegions(func(pr physicalRegion) bool {
        // Map everything in the lower half.
        m.kernel.PageTables.Map(
            hostarch.Addr(pr.virtual),
            pr.length,
            pagetables.MapOpts{AccessType: hostarch.ReadWrite},
            pr.physical)

        return true // Keep iterating.
    })

    // &#x628A;&#x5F53;&#x524D;host&#x8FDB;&#x7A0B;&#x5DF2;&#x7ECF;map&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x6620;&#x5C04;&#x8FDB;VM
    // &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x4F5C;&#x7528;&#x662F;&#x628A;host&#x8FDB;&#x7A0B;&#x7684;&#x5DF2;&#x7ECF;&#x5EFA;&#x7ACB;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;region&#x6620;&#x5C04;&#x8FDB;VM, &#x8BA9;VM&#x770B;&#x5230;&#x548C;host&#x8FDB;&#x7A0B;&#x76F8;&#x540C;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;, &#x5E76;&#x5BF9;&#x5E94;&#x5230;&#x76F8;&#x540C;&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;, &#x5373;VM&#x80FD;&#x591F;&#x6267;&#x884C;host&#x8FDB;&#x7A0B;&#x7684;&#x4EE3;&#x7801;. &#x6BD4;&#x5982;&#x5728;VM&#x6267;&#x884C;host&#x4E2D;&#x7684;funcx, VM&#x4E2D;&#x76F4;&#x63A5;&#x4F7F;&#x7528;funcx&#x5728;host&#x4E2D;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;, VM&#x4E2D;&#x81EA;&#x5DF1;&#x7EF4;&#x62A4;&#x7684;&#x9875;&#x8868;&#x628A;&#x8FD9;&#x4E2A;VA&#x8F6C;&#x5230;PA, &#x8FD9;&#x4E2A;PA&#x662F;VM&#x7684;&quot;&#x7269;&#x7406;&#x5730;&#x5740;&quot;, &#x56E0;&#x4E3A;&#x8FD9;&#x4E2A;PA&#x548C;host&#x7684;VA&#x5DF2;&#x7ECF;&#x5728;KVM&#x4E2D;&#x5EFA;&#x7ACB;&#x4E86;&#x6620;&#x5C04;(ioctl KVM_SET_USER_MEMORY_REGION), &#x7ECF;&#x8FC7;KVM&#x7684;&#x7B2C;&#x4E8C;&#x6B21;&#x5730;&#x5740;&#x7FFB;&#x8BD1;, &#x8FD9;&#x4E2A;host&#x7684;VA&#x5C31;&#x88AB;&#x7FFB;&#x8BD1;&#x6210;&#x771F;&#x6B63;&#x7684;PA.
    // &#x5176;&#x5B9E;&#x5C31;&#x662F;&#x76F8;&#x5F53;&#x4E8E;&#x7ECF;&#x8FC7;VM&#x7684;&#x4E24;&#x4E2A;&#x9636;&#x6BB5;&#x7684;MMU&#x7FFB;&#x8BD1;, &#x7ED3;&#x679C;&#x5C31;&#x662F;VM&#x80FD;&#x76F4;&#x63A5;&#x8BBF;&#x95EE;host&#x7A7A;&#x95F4;&#x7684;&#x4EE3;&#x7801;.
    applyVirtualRegions()
        f, err := os.Open(&quot;/proc/self/maps&quot;)
        //&#x7528;regex&#x89E3;&#x6790;&#x6BCF;&#x884C;&#x5F97;&#x5230;&#x865A;&#x62DF;&#x5730;&#x5740;start&#x548C;length
        //&#x5BF9;&#x6BCF;&#x4E2A;virtual region
        for &#x6BCF;&#x4E2A;entry
            //1. &#x4ECE;host&#x865A;&#x62DF;&#x5730;&#x5740;&#x67E5;&#x5230;VM&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;
            physical, length, ok := translateToPhysical(virtual)
            //2. &#x5982;&#x679C;&#x5C5E;&#x6027;&#x6709;execute, &#x5373;host&#x8FDB;&#x7A0B;&#x7684;&#x4EE3;&#x7801;, install&#x5230;VM&#x7684;kernel pagetable&#x91CC;
            //&#x53EA;&#x6709;&#x4EE3;&#x7801;&#x88AB;&#x52A0;&#x5230;VM&#x7684;&#x9875;&#x8868;
            m.kernel.PageTables.Map(
                hostarch.Addr(virtual),
                length,
                pagetables.MapOpts{AccessType: vr.accessType},
                physical)
            //3. &#x6BCF;&#x4E2A;entry&#x90FD;&#x4F1A;&#x8C03;&#x7528;kvm&#x7684;ioctl KVM_SET_USER_MEMORY_REGION, &#x8BA9;VM&#x53EF;&#x4EE5;&#x8BBF;&#x95EE;host&#x8FDB;&#x7A0B;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x533A;&#x57DF;
            // Ensure the physical range is mapped.
            m.mapPhysical(physical, length, physicalRegions)

    // &#x505A;&#x4E2A;_KVM_ARM_PREFERRED_TARGET&#x7684;KVM ioctl
    m.initArchState()
        //&#x5728;&#x91CC;&#x9762;newVCPU(), &#x6700;&#x591A;maxvcpu&#x4E2A;
        for int(m.nextID) &lt; m.maxVCPUs-1 {
            c := m.newVCPU() //&#x89C1;&#x4E0B;&#x9762;
            c.state = 0
            m.initialvCPUs[c.id] = c
        }
    // m&#x4EE3;&#x8868;&#x7684;machine&#x662F;&#x5783;&#x573E;&#x56DE;&#x6536;&#x7684;, &#x7528;SetFinalizer&#x673A;&#x5236;&#x6765;&#x8C03;&#x7528;m.Destroy&#x6E05;&#x7406;
    runtime.SetFinalizer(m, (*machine).Destroy)
}

func (m *machine) Destroy() {
    runtime.SetFinalizer(m, nil)
    ...
}
</code></pre>
<h3 id="arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;"><a name="arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;" class="anchor-navigation-ex-anchor" href="#arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.7. arm64&#x5F02;&#x5E38;&#x5411;&#x91CF;</h3>
<p><a href="https://developer.arm.com/documentation/100933/0100/AArch64-exception-vector-table" target="_blank">https://developer.arm.com/documentation/100933/0100/AArch64-exception-vector-table</a>
&#x6BCF;&#x4E2A;exception level&#x90FD;&#x6709;&#x72EC;&#x7ACB;&#x7684;&#x5F02;&#x5E38;&#x5411;&#x91CF;&#x8868;
&#x5411;&#x91CF;&#x8868;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x914D;&#x5728;VBAR&#x5BC4;&#x5B58;&#x5668;&#x91CC;</p>
<blockquote>
<p>The virtual address of each table base is set by the <em>Vector Based Address Registers:</em> VBAR_EL3, VBAR_EL2 and VBAR_EL1.</p>
</blockquote>
<p>&#x6BCF;&#x4E2A;vector table&#x6709;16&#x4E2A;entry, &#x6BCF;&#x4E2A;entry&#x56FA;&#x5B9A;128&#x4E2A;&#x5B57;&#x8282;(&#x53EF;&#x4EE5;&#x6709;32&#x4E2A;&#x6307;&#x4EE4;). &#x786C;&#x4EF6;&#x4F1A;&#x6839;&#x636E;&#x60C5;&#x51B5;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;entry.</p>
<ul>
<li>The type of exception (SError, FIQ, IRQ, or Synchronous)</li>
<li>If the exception is being taken at the same Exception level, the stack pointer to be used (SP0 or SPn)</li>
<li>If the exception is being taken at a lower Exception level, the Execution state of the next lower level (AArch64 or AArch32).</li>
</ul>
<p>&#x89E3;&#x91CA;&#x4E00;&#x4E0B;, arm64&#x7684;sp&#x5BC4;&#x5B58;&#x5668;&#x6BCF;&#x4E2A;EL&#x90FD;&#x6709;, &#x4F46;&#x4E0D;&#x4E00;&#x5B9A;&#x90FD;&#x7528;:
<code>SPSel</code>&#x9009;&#x62E9;&#x5BC4;&#x5B58;&#x5668;&#x7684;0&#x4F4D;, &#x6765;&#x51B3;&#x5B9A;&#x7528;&#x54EA;&#x4E2A;SP</p>
<table>
<thead>
<tr>
<th>SP</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0b0</td>
<td>Use SP_EL0 at all Exception levels.</td>
</tr>
<tr>
<td>0b1</td>
<td>Use SP_ELx for Exception level ELx.</td>
</tr>
</tbody>
</table>
<p>&#x9ED8;&#x8BA4;&#x662F;1, &#x5C31;&#x662F;&#x8BF4;&#x9ED8;&#x8BA4;&#x6BCF;&#x4E2A;EL&#x90FD;&#x7528;&#x81EA;&#x5DF1;&#x7684;SP&#x5BC4;&#x5B58;&#x5668;.</p>
<p>&#x4E3E;&#x4F8B;&#x6765;&#x8BF4;:</p>
<blockquote>
<p>If kernel code is executing at EL1 and an IRQ interrupt is signaled, an IRQ exception occurs. This particular interrupt is not associated with the hypervisor or secure environment and is also handled within the kernel, and the SPSel bit is set, so SP_EL1 is used.</p>
<p>Execution takes place, therefore, from address VBAR_EL1 + 0x280.</p>
</blockquote>
<p><img src="img/golang_gvisor&#x4EE3;&#x7801;_KVM_20220915083443.png" alt="">  </p>
<p>gvisor&#x91CC;&#x9762;, &#x8FD9;&#x4E2A;&#x5411;&#x91CF;&#x8868;&#x5728;<code>pkg/ring0/entry_arm64.s</code></p>
<pre><code class="lang-go">TEXT &#xB7;Vectors(SB),NOSPLIT,$0
    PCALIGN $2048
    // gvisor&#x5E76;&#x4E0D;&#x652F;&#x6301;SP0, &#x5C31;&#x662F;&#x8BF4;&#x8FD9;&#x91CC;`SPSel`&#x662F;1
    B &#xB7;El1_sync_invalid(SB)
    PCALIGN $128
    B &#xB7;El1_irq_invalid(SB)
    PCALIGN $128
    B &#xB7;El1_fiq_invalid(SB)
    PCALIGN $128
    B &#xB7;El1_error_invalid(SB)

    // &#x63A5;&#x4E0B;&#x6765;&#x7684;4&#x4E2A;entry&#x662F;El1&#x89E6;&#x53D1;&#x7684;
    PCALIGN $128
    B &#xB7;El1_sync(SB)
    PCALIGN $128
    B &#xB7;El1_irq(SB)
    PCALIGN $128
    B &#xB7;El1_fiq(SB)
    PCALIGN $128
    B &#xB7;El1_error(SB)

    // &#x8FD9;4&#x4E2A;entry&#x662F;64&#x4F4D;&#x7684;EL0&#x89E6;&#x53D1;&#x7684;
    PCALIGN $128
    B &#xB7;El0_sync(SB)
    PCALIGN $128
    B &#xB7;El0_irq(SB)
    PCALIGN $128
    B &#xB7;El0_fiq(SB)
    PCALIGN $128
    B &#xB7;El0_error(SB)

    // &#x8FD9;4&#x4E2A;entry&#x662F;32&#x4F4D;&#x7684;EL0&#x89E6;&#x53D1;&#x7684;. &#x5C31;&#x662F;&#x8BF4;&#x8FD9;&#x91CC;&#x4E0D;&#x652F;&#x6301;32&#x4F4D;&#x7528;&#x6237;&#x6001;&#x6A21;&#x5F0F;
    PCALIGN $128
    B &#xB7;El0_sync_invalid(SB)
    PCALIGN $128
    B &#xB7;El0_irq_invalid(SB)
    PCALIGN $128
    B &#xB7;El0_fiq_invalid(SB)
    PCALIGN $128
    B &#xB7;El0_error_invalid(SB)
</code></pre>
<p>&#x8FD9;&#x4E2A;&#x5730;&#x5740;<code>ring0.Vectors</code>&#x88AB;&#x914D;&#x7F6E;&#x5230;_KVM_ARM64_REGS_VBAR_EL1</p>
<pre><code class="lang-go">    // vbar_el1
    reg.id = _KVM_ARM64_REGS_VBAR_EL1
    // ring0.Vectors&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;
    vectorLocation := reflect.ValueOf(ring0.Vectors).Pointer()
    // &#x865A;&#x62DF;&#x5730;&#x5740;&#x52A0;&#x4E0A;KernelStartAddress(ffff000000000000)
    data = uint64(ring0.KernelStartAddress | vectorLocation)
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }
</code></pre>
<p>VBAR&#x91CC;&#x914D;&#x7684;&#x662F;&#x865A;&#x62DF;&#x5730;&#x5740;, &#x524D;&#x9762;&#x8BB2;&#x8FC7;, <del>kernel&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;</del>upperhalf&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;=&#x7269;&#x7406;&#x5730;&#x5740;+ffff000000000000, &#x800C;&#x5BF9;&#x4E8E;VM&#x6765;&#x8BF4;, &#x8FD9;&#x4E2A;&#x7269;&#x7406;&#x5730;&#x5740;&#x5C31;&#x662F;&#x5176;&#x6240;&#x5728;VM&#x8FDB;&#x7A0B;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;.<br>&#x6240;&#x4EE5;&#x53D1;&#x751F;&#x5F02;&#x5E38;&#x65F6;, &#x56E0;&#x4E3A;&#x662F;EL1, &#x5982;&#x679C;TLB&#x6CA1;&#x547D;&#x4E2D;, CPU&#x7684;MMU&#x5148;&#x627E;&#x5230;TTBR1, walk PTE(page table entry), &#x627E;&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;; &#x8FD9;&#x4E2A;&#x7269;&#x7406;&#x5730;&#x5740;&#x5C31;&#x662F;<code>ring0.Vectors</code>&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;; MMU&#x77E5;&#x9053;&#x73B0;&#x5728;&#x662F;2 stage translate&#x6A21;&#x5F0F;, &#x5C31;&#x53BB;&#x627E;VTTBR(KVM&#x914D;&#x7F6E;&#x7684;)&#x7684;page table&#x57FA;&#x5730;&#x5740;&#x53BB;&#x627E;&#x7269;&#x7406;&#x5730;&#x5740;, &#x8FD9;&#x6B21;&#x627E;&#x5230;&#x771F;&#x6B63;&#x7684;&#x7269;&#x7406;&#x5730;&#x5740;.</p>
<h4 id="el0&#x540C;&#x6B65;&#x5F02;&#x5E38;"><a name="el0&#x540C;&#x6B65;&#x5F02;&#x5E38;" class="anchor-navigation-ex-anchor" href="#el0&#x540C;&#x6B65;&#x5F02;&#x5E38;"><i class="fa fa-link" aria-hidden="true"></i></a>EL0&#x540C;&#x6B65;&#x5F02;&#x5E38;</h4>
<p>&#x5F02;&#x5E38;&#x5165;&#x53E3;&#x5148;&#x4FDD;&#x5B58;&#x7528;&#x6237;&#x4E0A;&#x4E0B;&#x6587;&#x7684;&#x5BC4;&#x5B58;&#x5668;, &#x7136;&#x540E;&#x6BD4;&#x8F83;&#x5F02;&#x5E38;&#x539F;&#x56E0;&#x5BC4;&#x5B58;&#x5668;&#x8DF3;&#x8F6C;&#x5230;&#x76F8;&#x5E94;&#x5904;&#x7406;</p>
<pre><code class="lang-go">// El0_sync is the handler for El0_sync.
TEXT &#xB7;El0_sync(SB),NOSPLIT,$0
    KERNEL_ENTRY_FROM_EL0
    MRS ESR_EL1, R25                  // read the syndrome register
    LSR  $ESR_ELx_EC_SHIFT, R25, R24  // exception class
    CMP $ESR_ELx_EC_SVC64, R24
    BEQ el0_svc                       // SVC in 64-bit state
    CMP $ESR_ELx_EC_DABT_LOW, R24
    BEQ el0_da                        // data abort in EL0
    CMP $ESR_ELx_EC_IABT_LOW, R24
    BEQ el0_ia                        // instruction abort in EL0
    CMP $ESR_ELx_EC_FP_ASIMD, R24
    BEQ el0_fpsimd_acc                // FP/ASIMD access
    CMP $ESR_ELx_EC_SVE, R24
    BEQ el0_sve_acc                   // SVE access
    CMP $ESR_ELx_EC_FP_EXC64, R24
    BEQ el0_fpsimd_exc                // FP/ASIMD exception
    CMP $ESR_ELx_EC_SP_ALIGN, R24
    BEQ el0_sp_pc                     // stack alignment exception
    CMP $ESR_ELx_EC_PC_ALIGN, R24
    BEQ el0_sp_pc                     // pc alignment exception
    CMP $ESR_ELx_EC_UNKNOWN, R24
    BEQ el0_undef                     // unknown exception in EL0
    CMP $ESR_ELx_EC_BREAKPT_LOW, R24
    BEQ el0_dbg                       // debug exception in EL0
    CMP $ESR_ELx_EC_SYS64, R24
    BEQ el0_sys                       // configurable trap
    CMP $ESR_ELx_EC_WFx, R24
    BEQ el0_wfx                       // WFX trap
    B   el0_invalid
</code></pre>
<p><code>RSP</code>: stack pointer</p>
<pre><code class="lang-go">// RSV_REG is a register that holds el1 information temporarily.
#define RSV_REG     R18_PLATFORM

// RSV_REG_APP is a register that holds el0 information temporarily.
#define RSV_REG_APP     R19
</code></pre>
<p>KERNEL_ENTRY_FROM_EL0()&#x4FDD;&#x5B58;&#x7528;&#x6237;app&#x7684;&#x4E0A;&#x4E0B;&#x6587;</p>
<pre><code class="lang-go">// KERNEL_ENTRY_FROM_EL0 is the entry code of the vcpu from el0 to el1.
#define KERNEL_ENTRY_FROM_EL0 \
    SUB $16, RSP, RSP; \        // step1, save r18, r19 into kernel temporary stack.
    STP (RSV_REG, RSV_REG_APP), 16*0(RSP); \
    WORD $0xd538d092; \    // MRS   TPIDR_EL1, R18
    MOVD CPU_APP_ADDR(RSV_REG), RSV_REG_APP; \ // step2, load app context pointer.
    //&#x4FDD;&#x5B58;r0&#x5230;r31&#x7B49;&#x901A;&#x7528;&#x5BC4;&#x5B58;&#x5668;
    REGISTERS_SAVE(RSV_REG_APP, 0); \          // step3, save app context.
    MOVD RSV_REG_APP, R20; \
    LDP 16*0(RSP), (RSV_REG, RSV_REG_APP); \
    ADD $16, RSP, RSP; \
    STP (RSV_REG, RSV_REG_APP), PTRACE_R18(R20); \ // &#x66F4;&#x65B0;r18 r19&#x5230;&#x4E0A;&#x4E0B;&#x6587;
    MRS TPIDR_EL0, R3; \
    MOVD R3, PTRACE_TLS(R20); \                     //TPIDR_EL0&#x4FDD;&#x5B58;&#x5230;TLS
    WORD $0xd5384003; \      //  MRS SPSR_EL1, R3
    MOVD R3, PTRACE_PSTATE(R20); \                    //&#x72B6;&#x6001;&#x5BC4;&#x5B58;&#x5668;&#x4FDD;&#x5B58;&#x5230;PSTATE
    MRS ELR_EL1, R3; \
    MOVD R3, PTRACE_PC(R20); \                        //ELR_EL1&#x4FDD;&#x5B58;&#x5230;PC
    WORD $0xd5384103; \      //  MRS SP_EL0, R3
    MOVD R3, PTRACE_SP(R20);                        //SP_EL0&#x4FDD;&#x5B58;&#x5230;SP
</code></pre>
<h4 id="el0&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x4E4B;svc&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5F02;&#x5E38;"><a name="el0&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x4E4B;svc&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5F02;&#x5E38;" class="anchor-navigation-ex-anchor" href="#el0&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x4E4B;svc&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5F02;&#x5E38;"><i class="fa fa-link" aria-hidden="true"></i></a>EL0&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x4E4B;SVC&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5F02;&#x5E38;</h4>
<pre><code class="lang-go">// System call vectors.
const (
    Syscall                 Vector = El0SyncSVC
    PageFault               Vector = El0SyncDa
    VirtualizationException Vector = El0ErrBounce
)

el0_svc:
    WORD $0xd538d092     //MRS   TPIDR_EL1, R18

    MOVD $0, CPU_ERROR_CODE(RSV_REG) // Clear error code.

    MOVD $1, R3
    MOVD R3, CPU_ERROR_TYPE(RSV_REG) // Set error type to user.

    //Syscall&#x662F;El0SyncSVC
    MOVD $Syscall, R3
    // &#x76F8;&#x5F53;&#x4E8E;c.vecCode = El0SyncSVC
    MOVD R3, CPU_VECTOR_CODE(RSV_REG)

    //&#x5982;&#x679C;&#x76F4;&#x63A5;eret, &#x5219;&#x4F1A;&#x8FD4;&#x56DE;EL0, &#x56E0;&#x4E3A;&#x662F;&#x5728;EL0&#x89E6;&#x53D1;&#x7684;&#x5F02;&#x5E38;
    //&#x4F46;&#x8FD9;&#x91CC;&#x662F;&#x8981;&#x8FD4;&#x56DE;EL1
    B &#xB7;kernelExitToEl1(SB)
</code></pre>
<p>&#x8FD9;&#x91CC;&#x7684;CPU_VECTOR_CODE&#x662F;c.vecCode&#x5728;c(&#x5C31;&#x662F;CPU&#x90A3;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;)&#x7684;&#x504F;&#x79FB;&#x91CF;
<code>RSV_REG</code>&#x662F;<code>R18_PLATFORM</code></p>
<h4 id="kernelexittoel1"><a name="kernelexittoel1" class="anchor-navigation-ex-anchor" href="#kernelexittoel1"><i class="fa fa-link" aria-hidden="true"></i></a>kernelExitToEl1</h4>
<p>kernelExitToEl1()<strong>&#x53EF;&#x4EE5;&#x5728;EL0_SVC&#x91CC;&#x9762;&#x8C03;&#x7528;, &#x4E5F;&#x53EF;&#x4EE5;&#x5728;EL1_SVC&#x91CC;&#x9762;&#x8C03;&#x7528;</strong>.</p>
<p>&#x6062;&#x590D;&#x5BC4;&#x5B58;&#x5668;, &#x6700;&#x540E;&#x8C03;&#x7528;eret&#x4ECE;&#x5F02;&#x5E38;&#x8FD4;&#x56DE;. &#x5373;&#x4ECE;EL1&#x7684;&#x5F02;&#x5E38;&#x6001;&#x8FD4;&#x56DE;&#x5230;EL1&#x7684;&#x6B63;&#x5E38;&#x6001;.</p>
<pre><code class="lang-go">// kernelExitToEl1 is the entrypoint for sentry in guest_el1.
// Prepare the vcpu environment for sentry.
TEXT &#xB7;kernelExitToEl1(SB),NOSPLIT,$0
    WORD $0xd538d092     //MRS   TPIDR_EL1, R18 //&#x662F;vCPU&#x7ED3;&#x6784;&#x4F53;?
    MOVD CPU_REGISTERS+PTRACE_PSTATE(RSV_REG), R1 
    WORD $0xd5184001  //MSR R1, SPSR_EL1 //&#x6062;&#x590D;&#x4FDD;&#x5B58;&#x7684;SPSR_EL1

    //&#x8BBE;&#x7F6E;ELR&#x4E3A;&#x4E4B;&#x524D;&#x4FDD;&#x5B58;&#x7684;PC
    MOVD CPU_REGISTERS+PTRACE_PC(RSV_REG), R1
    MSR R1, ELR_EL1 //&#x6062;&#x590D;&#x4FDD;&#x5B58;&#x7684;ELR

    // restore sentry&apos;s tls.
    MOVD CPU_REGISTERS+PTRACE_TLS(RSV_REG), R1
    MSR R1, TPIDR_EL0 //&#x7528;&#x7684;&#x662F;TPIDR_EL0, &#x8BF4;&#x660E;sEntry&#x4E5F;&#x662F;&#x5728;VM&#x7684;&#x7528;&#x6237;&#x6001;

    MOVD CPU_REGISTERS+PTRACE_SP(RSV_REG), R1
    MOVD R1, RSP //&#x6062;&#x590D;&#x4FDD;&#x5B58;&#x7684;SP

    REGISTERS_LOAD(RSV_REG, CPU_REGISTERS)
    SWITCH_TO_KVM_PAGETABLE() //&#x4F7F;&#x7528;c.ttbr0Kvm &#x9875;&#x8868;, &#x8FD9;&#x4E2A;&#x597D;&#x50CF;&#x662F;&#x548C;sentry&#x5BF9;&#x5E94;&#x7684;. &#x4E5F;&#x914D;&#x5728;ttbr0&#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;&#x91CC;; &#x76F8;&#x5E94;&#x7684;, &#x8FD8;&#x6709;&#x4E2A;SWITCH_TO_APP_PAGETABLE, &#x662F;&#x4F7F;&#x7528;c.ttbr0App&#x9875;&#x8868;
    MRS TPIDR_EL1, RSV_REG

    MOVD CPU_REGISTERS+PTRACE_R19(RSV_REG), RSV_REG_APP

    ERET()
</code></pre>
<p>kernelExitToEl1&#x8FD4;&#x56DE;El1, &#x5E76;&#x5207;&#x6362;&#x5230;KVM&#x9875;&#x8868;(&#x6216;&#x8005;&#x8BF4;sEntry&#x9875;&#x8868;), KVM&#x9875;&#x8868;&#x4E5F;&#x662F;&#x7528;ttbr0&#x6765;&#x914D;&#x7684;, &#x7B97;&#x7528;&#x6237;&#x9875;&#x8868;(&#x6216;&#x8005;&#x8BF4;&#x4E0B;&#x534A;&#x90E8;&#x9875;&#x8868;).</p>
<p>&#x8FD9;&#x91CC;&#x7684;&#x5173;&#x952E;&#x70B9;&#x662F;&#x4ECE;TPIDR_EL1&#x62FF;&#x5230;vCPU&#x7684;&#x7ED3;&#x6784;&#x4F53;, &#x8FD9;&#x4E2A;&#x5E94;&#x8BE5;&#x662F;&#x6307;VM&#x7684;&quot;kernel&quot;&#x7684;&#x4FE1;&#x606F;, &#x4ECE;&#x91CC;&#x9762;&#x6062;&#x590D;SPSR_EL1, &#x800C;SPSR_EL1&#x91CC;&#x9762;&#x662F;&#x4FDD;&#x5B58;&#x7684;pstate&#x5BC4;&#x5B58;&#x5668;(&#x662F;kernel&#x7684;&#x5417;?), eret&#x8981;&quot;&#x9000;&#x56DE;&quot;&#x7684;EL&#x7EA7;&#x522B;&#x662F;&#x4ECE;SPSR_EL1&#x91CC;&#x67E5;&#x7684;.<br>&#x7528;&#x5F53;&#x65F6;&#x8BB0;&#x5F55;&#x7684;PC(CPU_REGISTERS+PTRACE_PC(RSV_REG))&#x6062;&#x590D;&#x5230;ELR_EL1, &#x90A3;&#x4E48;&#x8FD9;&#x4E2A;ELR&#x5E26;&#x6211;&#x4EEC;&#x5230;&#x54EA;&#x91CC;&#x5462;?</p>
<p>&#x6CE8;:
<code>SPSR_EL1</code>&#x662F;Saved Program Status Register, Holds the saved process state when an exception is taken to EL1. &#x5F53;&#x5F02;&#x5E38;&#x88AB;EL1&#x5904;&#x7406;&#x65F6;, SPSR_EL1&#x6301;&#x6709;&#x4FDD;&#x5B58;&#x7684;&#x72B6;&#x6001;&#x5BC4;&#x5B58;&#x5668;</p>
<h4 id="&#x987A;&#x4FBF;&#x770B;&#x4E00;&#x4E0B;kernelexittoel0"><a name="&#x987A;&#x4FBF;&#x770B;&#x4E00;&#x4E0B;kernelexittoel0" class="anchor-navigation-ex-anchor" href="#&#x987A;&#x4FBF;&#x770B;&#x4E00;&#x4E0B;kernelexittoel0"><i class="fa fa-link" aria-hidden="true"></i></a>&#x987A;&#x4FBF;&#x770B;&#x4E00;&#x4E0B;kernelExitToEl0</h4>
<p>kernelExitToEl0&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5728;<code>(c *CPU) SwitchToUser</code>&#x91CC;&#x9762;&#x88AB;&#x8C03;&#x7528;, </p>
<pre><code class="lang-go">// kernelExitToEl0 is the entrypoint for application in guest_el0.
// Prepare the vcpu environment for container application.
TEXT &#xB7;kernelExitToEl0(SB),NOSPLIT,$0
    // Step1, save sentry context into memory.
    MRS TPIDR_EL1, RSV_REG
    REGISTERS_SAVE(RSV_REG, CPU_REGISTERS)
    MOVD RSV_REG_APP, CPU_REGISTERS+PTRACE_R19(RSV_REG)
    MRS TPIDR_EL0, R3
    MOVD R3, CPU_REGISTERS+PTRACE_TLS(RSV_REG)

    WORD $0xd5384003    //    MRS SPSR_EL1, R3
    MOVD R3, CPU_REGISTERS+PTRACE_PSTATE(RSV_REG)
    MOVD R30, CPU_REGISTERS+PTRACE_PC(RSV_REG)
    MOVD RSP, R3
    MOVD R3, CPU_REGISTERS+PTRACE_SP(RSV_REG)

    MOVD CPU_REGISTERS+PTRACE_R3(RSV_REG), R3

    // Step2, switch to temporary stack.
    LOAD_KERNEL_STACK(RSV_REG)

    // Step3, load app context pointer.
    MOVD CPU_APP_ADDR(RSV_REG), RSV_REG_APP

    // Step4, prepare the environment for container application.
    // set sp_el0.
    MOVD PTRACE_SP(RSV_REG_APP), R1
    WORD $0xd5184101        //MSR R1, SP_EL0
    // set pc.
    MOVD PTRACE_PC(RSV_REG_APP), R1
    MSR R1, ELR_EL1
    // set pstate.
    MOVD PTRACE_PSTATE(RSV_REG_APP), R1
    WORD $0xd5184001  //MSR R1, SPSR_EL1

    // need use kernel space address to excute below code, since
    // after SWITCH_TO_APP_PAGETABLE the ASID is changed to app&apos;s
    // ASID.
    WORD $0x10000061        // ADR R1, do_exit_to_el0
    ORR $0xffff000000000000, R1, R1
    JMP (R1)

do_exit_to_el0:
    // RSV_REG &amp; RSV_REG_APP will be loaded at the end.
    REGISTERS_LOAD(RSV_REG_APP, 0)
    MOVD PTRACE_TLS(RSV_REG_APP), RSV_REG
    MSR RSV_REG, TPIDR_EL0

    // switch to user pagetable.
    LDP PTRACE_R18(RSV_REG_APP), (RSV_REG, RSV_REG_APP)

    SUB $STACK_FRAME_SIZE, RSP, RSP
    STP (RSV_REG, RSV_REG_APP), 16*0(RSP)
    STP (R0, R1), 16*1(RSP)

    WORD $0xd538d092    //MRS   TPIDR_EL1, R18

    SWITCH_TO_APP_PAGETABLE()

    LDP 16*1(RSP), (R0, R1)
    LDP 16*0(RSP), (RSV_REG, RSV_REG_APP)
    ADD $STACK_FRAME_SIZE, RSP, RSP

    ERET()
</code></pre>
<h4 id="el1&#x540C;&#x6B65;&#x5F02;&#x5E38;el1sync"><a name="el1&#x540C;&#x6B65;&#x5F02;&#x5E38;el1sync" class="anchor-navigation-ex-anchor" href="#el1&#x540C;&#x6B65;&#x5F02;&#x5E38;el1sync"><i class="fa fa-link" aria-hidden="true"></i></a>EL1&#x540C;&#x6B65;&#x5F02;&#x5E38;El1_sync</h4>
<p>&#x5728;El1&#x72B6;&#x6001;&#x4E0B;&#x7684;&#x540C;&#x6B65;&#x5F02;&#x5E38;&#x5165;&#x53E3;&#x4E0B;&#x9762;, &#x901A;&#x8FC7;&#x8BFB;&#x53D6;ESR_EL1, &#x5F02;&#x5E38;&#x53EF;&#x5206;&#x4E3A;:</p>
<ul>
<li>&#x6570;&#x636E;&#x9519;&#x8BEF;, &#x4EE3;&#x7801;&#x9519;&#x8BEF;, &#x6808;&#x5BF9;&#x9F50;&#x9519;&#x8BEF;, pc&#x5BF9;&#x9F50;&#x9519;&#x8BEF;&#x7B49;&#x9519;&#x8BEF;&#x5F02;&#x5E38;. </li>
<li>svc&#x5F02;&#x5E38;, &#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7528;&#x7684; -- &#x4F46;&#x8FD9;&#x91CC;&#x5DF2;&#x7ECF;&#x662F;el1&#x4E86;, &#x8FD8;&#x6709;&#x5565;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;?</li>
<li>&#x5176;&#x4ED6;&#x5F02;&#x5E38;<pre><code class="lang-go">// El1_sync is the handler for El1_sync.
TEXT &#xB7;El1_sync(SB),NOSPLIT,$0
  KERNEL_ENTRY_FROM_EL1 // &#x4FDD;&#x5B58;sentry&#x4E0A;&#x4E0B;&#x6587;&#x5BC4;&#x5B58;&#x5668;, load kernel stack
  MRS ESR_EL1, R25                  // read the syndrome register
  LSR  $ESR_ELx_EC_SHIFT, R25, R24  // exception class
  CMP $ESR_ELx_EC_DABT_CUR, R24
  BEQ el1_da                        // data abort in EL1
  CMP $ESR_ELx_EC_IABT_CUR, R24
  BEQ el1_ia                        // instruction abort in EL1
  CMP $ESR_ELx_EC_FP_ASIMD, R24
  BEQ el1_fpsimd_acc                // FP/ASIMD access
  CMP $ESR_ELx_EC_SVE, R24
  BEQ el1_sve_acc                   // SVE access
  CMP $ESR_ELx_EC_SP_ALIGN, R24
  BEQ el1_sp_pc                     // stack alignment exception
  CMP $ESR_ELx_EC_PC_ALIGN, R24
  BEQ el1_sp_pc                     // pc alignment exception
  CMP $ESR_ELx_EC_UNKNOWN, R24
  BEQ el1_undef                     // unknown exception in EL1
  CMP $ESR_ELx_EC_SVC64, R24
  BEQ el1_svc                       // SVC in 64-bit state
  CMP $ESR_ELx_EC_BREAKPT_CUR, R24
  BEQ el1_dbg                       // debug exception in EL1
  B el1_invalid
</code></pre>
</li>
</ul>
<p>&#x4E00;&#x822C;&#x7684;&#x9519;&#x8BEF;&#x5F02;&#x5E38;
&#x6700;&#x540E;&#x8C03;&#x7528;HaltEl1ExceptionAndResume</p>
<pre><code class="lang-go">// HaltEl1ExceptionAndResume calls Hooks.KernelException and resume.
TEXT &#xB7;HaltEl1ExceptionAndResume(SB),NOSPLIT,$0-8
    WORD $0xd538d092            // MRS TPIDR_EL1, R18
    MOVD CPU_SELF(RSV_REG), R3  // Load vCPU.
    MOVD R3, 8(RSP)             // First argument (vCPU).
    MOVD vector+0(FP), R3
    MOVD R3, 16(RSP)            // Second argument (vector).
    CALL &#xB7;kernelException(SB)   // Call the trampoline.
    B &#xB7;kernelExitToEl1(SB)      // Resume.
</code></pre>
<p>&#x800C;svc&#x5F02;&#x5E38;&#x8C03;&#x7528;<code>HaltEl1SvcAndResume</code>, &#x5B83;&#x4E5F;&#x4F1A;&#x8C03;&#x7528;&#x94A9;&#x5B50;&#x51FD;&#x6570;&#x5904;&#x7406;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;:<code>kernelSyscall</code></p>
<pre><code class="lang-go">el1_svc:
    B &#xB7;HaltEl1SvcAndResume(SB)

// HaltEl1SvcAndResume calls Hooks.KernelSyscall and resume.
TEXT &#xB7;HaltEl1SvcAndResume(SB),NOSPLIT,$0
    WORD $0xd538d092            // MRS TPIDR_EL1, R18
    MOVD CPU_SELF(RSV_REG), R3  // Load vCPU.
    MOVD R3, 8(RSP)             // First argument (vCPU).
    CALL &#xB7;kernelSyscall(SB)     // Call the trampoline.
    B &#xB7;kernelExitToEl1(SB)      // Resume.
</code></pre>
<h4 id="el1&#x5176;&#x4ED6;&#x5F02;&#x5E38;irq-fiq-error&#x90FD;&#x8D70;shutdown&#x6D41;&#x7A0B;-&#x5173;&#x95ED;guest"><a name="el1&#x5176;&#x4ED6;&#x5F02;&#x5E38;irq-fiq-error&#x90FD;&#x8D70;shutdown&#x6D41;&#x7A0B;-&#x5173;&#x95ED;guest" class="anchor-navigation-ex-anchor" href="#el1&#x5176;&#x4ED6;&#x5F02;&#x5E38;irq-fiq-error&#x90FD;&#x8D70;shutdown&#x6D41;&#x7A0B;-&#x5173;&#x95ED;guest"><i class="fa fa-link" aria-hidden="true"></i></a>EL1&#x5176;&#x4ED6;&#x5F02;&#x5E38;(irq, fiq, error)&#x90FD;&#x8D70;shutdown&#x6D41;&#x7A0B;, &#x5173;&#x95ED;guest</h4>
<pre><code class="lang-go">// El1_irq is the handler for El1_irq.
TEXT &#xB7;El1_irq(SB),NOSPLIT,$0
    B &#xB7;Shutdown(SB)

// El1_fiq is the handler for El1_fiq.
TEXT &#xB7;El1_fiq(SB),NOSPLIT,$0
    B &#xB7;Shutdown(SB)

// El1_error is the handler for El1_error.
TEXT &#xB7;El1_error(SB),NOSPLIT,$0
    B &#xB7;Shutdown(SB)

// Shutdown stops the guest.
TEXT &#xB7;Shutdown(SB),NOSPLIT,$0
    // PSCI EVENT.
    MOVD $0x84000009, R0
    HVC $0 // hypervisor call
</code></pre>
<h3 id="kvmcreatevcpu"><a name="kvmcreatevcpu" class="anchor-navigation-ex-anchor" href="#kvmcreatevcpu"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.8. KVM_CREATE_VCPU</h3>
<p>&#x6BD4;&#x5982;&#x5728;<code>pkg/sentry/platform/kvm/machine.go</code>&#x4E2D;, &#x6709;&#x4E2A;&#x51FD;&#x6570;<code>newVCPU</code>&#x5C31;&#x4F7F;&#x7528;&#x4E86;<code>_KVM_CREATE_VCPU</code></p>
<pre><code class="lang-go">// newVCPU creates a returns a new vCPU.
//
// Precondition: mu must be held.
func (m *machine) newVCPU() *vCPU {
    // Create the vCPU.
    id := int(atomic.AddUint32(&amp;m.nextID, 1) - 1)
    fd, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CREATE_VCPU, uintptr(id))
    if errno != 0 {
        panic(fmt.Sprintf(&quot;error creating new vCPU: %v&quot;, errno))
    }

    c := &amp;vCPU{
        id:      id,
        fd:      int(fd),
        machine: m,
    }
    c.CPU.Init(&amp;m.kernel, c.id, c)
        c.self = c    // Set self reference.
        c.kernel = k  // Set kernel reference.
        c.init(cpuID) // Perform architectural init.
            // Set the kernel stack pointer(virtual address).
            c.registers.Sp = uint64(c.StackTop())
        c.floatingPointState = fpu.NewState()
        // hooks&#x662F;
        c.hooks = hooks &#x6216;&#x8005; c.hooks = defaultHooks{}
    m.vCPUsByID[c.id] = c

    // Ensure the signal mask is correct.
    if err := c.setSignalMask(); err != nil {
        panic(fmt.Sprintf(&quot;error setting signal mask: %v&quot;, err))
    }

    // Map the run data.
    // &#x5C31;&#x662F;&#x628A;fd mmap&#x6210;&#x5185;&#x5B58;, &#x7528;&#x4E8E;kvm&#x5411;&#x7528;&#x6237;&#x6001;&#x4F20;&#x9012;&#x4FE1;&#x606F;
    runData, err := mapRunData(int(fd))
    if err != nil {
        panic(fmt.Sprintf(&quot;error mapping run data: %v&quot;, err))
    }
    c.runData = runData

    // Initialize architecture state.
    // &#x76F8;&#x5F53;&#x4E8E;
    if err := c.initArchState(); err != nil {
        panic(fmt.Sprintf(&quot;error initialization vCPU state: %v&quot;, err))
    }

    return c // Done.
}
</code></pre>
<p>&#x6BD4;&#x5982;&#x8BBE;&#x7F6E;initArchState&#x4E2D;, &#x5C31;&#x8C03;&#x7528;&#x4E86;<code>setOneRegister</code>&#x5F88;&#x591A;&#x6B21;, &#x7528;<code>_KVM_SET_ONE_REG</code>&#x914D;&#x7F6E;&#x5BC4;&#x5B58;&#x5668;, &#x6BD4;&#x5982;ttbr0</p>
<pre><code class="lang-go">func (c *vCPU) setOneRegister(reg *kvmOneReg) error {
    if _, _, errno := unix.RawSyscall(
        unix.SYS_IOCTL,
        uintptr(c.fd),
        _KVM_SET_ONE_REG,
        uintptr(unsafe.Pointer(reg))); errno != 0 {
        return fmt.Errorf(&quot;error setting one register: %v&quot;, errno)
    }
    return nil
}

// &#x8FD9;&#x4E2A;init&#x662F;&#x8FD0;&#x884C;&#x5728;&#x7528;&#x6237;&#x6001;&#x7684;, &#x6240;&#x4EE5;&#x9700;&#x8981;&#x501F;&#x52A9;KVM&#x7684;`_KVM_SET_ONE_REG`&#x529F;&#x80FD;, &#x901A;&#x8FC7;ioctl&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x65B9;&#x5F0F;, &#x8BA9;KVM&#x6765;&#x8BBE;&#x7F6E;&#x5BC4;&#x5B58;&#x5668;
// initArchState initializes architecture-specific state.
func (c *vCPU) initArchState() error {
    var (
        reg     kvmOneReg
        data    uint64
        regGet  kvmOneReg
        dataGet uint64
    )

    reg.addr = uint64(reflect.ValueOf(&amp;data).Pointer())
    regGet.addr = uint64(reflect.ValueOf(&amp;dataGet).Pointer())

    // &#x5148;&#x662F;KVM&#x7684;ioctl&#x7684;_KVM_ARM_VCPU_INIT
    vcpuInit.features[0] |= (1 &lt;&lt; _KVM_ARM_VCPU_PSCI_0_2)
    if _, _, errno := unix.RawSyscall(
        unix.SYS_IOCTL,
        uintptr(c.fd),
        _KVM_ARM_VCPU_INIT,
        uintptr(unsafe.Pointer(&amp;vcpuInit))); errno != 0 {
        panic(fmt.Sprintf(&quot;error setting KVM_ARM_VCPU_INIT failed: %v&quot;, errno))
    }

    // tcr_el1 Translation Control Register &#x5730;&#x5740;&#x7FFB;&#x8BD1;&#x63A7;&#x5236;&#x5BC4;&#x5B58;&#x5668;
    data = _TCR_TXSZ_VA48 | _TCR_CACHE_FLAGS | _TCR_SHARED | _TCR_TG_FLAGS | _TCR_ASID16 | _TCR_IPS_40BITS
    reg.id = _KVM_ARM64_REGS_TCR_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // mair_el1
    data = _MT_EL1_INIT
    reg.id = _KVM_ARM64_REGS_MAIR_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // ttbr0_el1 ttbr0&#x7BA1;&#x7528;&#x6237;&#x6001;page table&#x57FA;&#x5730;&#x5740;
    // &#x5C06;pagetable&#x7684;rootPhysical&#x52A0;&#x4E0A;asid&#x7684;&#x504F;&#x79FB;&#x91CF;, &#x8FD9;&#x662F;&#x4E2A;&#x7269;&#x7406;&#x5730;&#x5740;
    data = c.machine.kernel.PageTables.TTBR0_EL1(false, 0)

    reg.id = _KVM_ARM64_REGS_TTBR0_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    c.SetTtbr0Kvm(uintptr(data))

    // ttbr1_el1 ttbr1&#x7BA1;&#x5185;&#x6838;&#x6001;page table&#x57FA;&#x5730;&#x5740;
    data = c.machine.kernel.PageTables.TTBR1_EL1(false, 0)

    reg.id = _KVM_ARM64_REGS_TTBR1_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // sp_el1
    // &#x5185;&#x6838;&#x7528;&#x7684;sp, &#x8FD9;&#x662F;&#x6BCF;&#x4E2A;CPU&#x7684;&#x4E2D;&#x65AD;&#x6808;, &#x5B9A;&#x4E49;&#x4E3A;stack [128]byte, &#x8FD9;&#x91CC;&#x53D6;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x7684;&#x5730;&#x5740;, &#x52A0;&#x4E0A;len
    data = c.CPU.StackTop() // uint64(kernelAddr(&amp;c.stack[0])) + uint64(len(c.stack))
    reg.id = _KVM_ARM64_REGS_SP_EL1
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // pc
    reg.id = _KVM_ARM64_REGS_PC
    data = uint64(reflect.ValueOf(ring0.Start).Pointer()) //&#x8FD9;&#x91CC;&#x7684;&#x5B9E;&#x73B0;&#x5F88;&#x5173;&#x952E;!!!! ring0.Start&#x662F;&#x4E2A;&#x51FD;&#x6570;, &#x53D6;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5F53;&#x4F5C;&#x5165;&#x53E3;&#x5730;&#x5740;, &#x914D;&#x5230;PC&#x4E2D;.
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // r8
    reg.id = _KVM_ARM64_REGS_R8
    data = uint64(reflect.ValueOf(&amp;c.CPU).Pointer()) 
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // vbar_el1
    reg.id = _KVM_ARM64_REGS_VBAR_EL1
    vectorLocation := reflect.ValueOf(ring0.Vectors).Pointer() 
    data = uint64(ring0.KernelStartAddress | vectorLocation)
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }

    // Use the address of the exception vector table as
    // the MMIO address base.
    arm64HypercallMMIOBase = vectorLocation

    // Initialize the PCID database.
    if hasGuestPCID {
        // Note that NewPCIDs may return a nil table here, in which
        // case we simply don&apos;t use PCID support (see below). In
        // practice, this should not happen, however.
        c.PCIDs = pagetables.NewPCIDs(fixedKernelPCID+1, poolPCIDs)
    }

    return c.setSystemTime()
}
</code></pre>
<h4 id="kerneladdr&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;eface&#x548C;func&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;"><a name="kerneladdr&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;eface&#x548C;func&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;" class="anchor-navigation-ex-anchor" href="#kerneladdr&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;eface&#x548C;func&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;"><i class="fa fa-link" aria-hidden="true"></i></a>kernelAddr&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;eface&#x548C;func&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;</h4>
<pre><code class="lang-go">package ring0

// eface mirrors runtime.eface.
type eface struct {
    typ  uintptr
    data unsafe.Pointer
}

// kernelAddr returns the kernel virtual address for the given object.
//
//go:nosplit
func kernelAddr(obj interface{}) uintptr {
    e := (*eface)(unsafe.Pointer(&amp;obj))
    return KernelStartAddress | uintptr(e.data)
}

// kernelFunc returns the address of the given function.
// KernelStartAddress&#x662F;ffff000000000000
func kernelFunc(fn uintptr) uintptr {
    return KernelStartAddress | fn
}
</code></pre>
<p>&#x5BF9;arm64&#x6765;&#x8BF4;</p>
<pre><code class="lang-go">type Vector uintptr

// System call vectors.
const (
    Syscall                 Vector = El0SyncSVC
    PageFault               Vector = El0SyncDa
    VirtualizationException Vector = El0ErrBounce
)

// VirtualAddressBits returns the number bits available for virtual addresses.
// &#x865A;&#x62DF;&#x5730;&#x5740;&#x662F;48&#x4F4D;, &#x548C;&#x5B9E;&#x9645;&#x4E00;&#x6837;
func VirtualAddressBits() uint32 {
    return 48
}

// PhysicalAddressBits returns the number of bits available for physical addresses.
func PhysicalAddressBits() uint32 {
    return 40
}

var (
    // UserspaceSize is the total size of userspace.
    UserspaceSize = uintptr(1) &lt;&lt; (VirtualAddressBits())

    // MaximumUserAddress is the largest possible user address.
    MaximumUserAddress = (UserspaceSize - 1) &amp; ^uintptr(hostarch.PageSize-1)

    // KernelStartAddress is the starting kernel address.
    // &#x5B9E;&#x9645;&#x8BA1;&#x7B97;&#x5F97;&#x51FA;ffff000000000000
    KernelStartAddress = ^uintptr(0) - (UserspaceSize - 1)
)
</code></pre>
<h3 id="kvmarmvcpuinit"><a name="kvmarmvcpuinit" class="anchor-navigation-ex-anchor" href="#kvmarmvcpuinit"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.9. KVM_ARM_VCPU_INIT</h3>
<p>&#x5728;ioctl KVM_CREATE_VCPU&#x4E4B;&#x540E;, &#x9700;&#x8981;KVM_ARM_VCPU_INIT</p>
<blockquote>
<p>This tells KVM what type of CPU to present to the guest, and what optional features it should have. This will cause a reset of the cpu registers to their initial values. If this is not called, KVM_RUN will return ENOEXEC for that vcpu.</p>
</blockquote>
<p>KVM_ARM_VCPU_INIT&#x4F1A;&#x628A;cpu&#x91CD;&#x7F6E;&#x4E3A;&#x521D;&#x59CB;&#x503C;. &#x5982;&#x679C;&#x6CA1;&#x6709;&#x8FD9;&#x4E00;&#x6B65;, KVM_RUN&#x5C31;&#x4F1A;&#x9519;&#x8BEF;.
The initial values are defined as:
Processor state:</p>
<ul>
<li>AArch64: EL1h, D, A, I and F bits set. All other bits are cleared.</li>
<li>AArch32: SVC, A, I and F bits set. All other bits are cleared.</li>
<li>General Purpose registers, including PC and SP: set to 0</li>
<li>FPSIMD/NEON registers: set to 0</li>
<li>SVE registers: set to 0</li>
<li>System registers: Reset to their architecturally defined values as for a warm reset to EL1 (resp. SVC)</li>
</ul>
<p>Note that because some registers reflect machine topology, all vcpus should be created before this ioctl is invoked.</p>
<p>Userspace can call this function multiple times for a given vcpu, including after the vcpu has been run. This will reset the vcpu to its initial state. All calls to this function after the initial call must use the same target and same set of feature flags, otherwise EINVAL will be returned.</p>
<h4 id="&#x5165;&#x53E3;&#x4EE3;&#x7801;"><a name="&#x5165;&#x53E3;&#x4EE3;&#x7801;" class="anchor-navigation-ex-anchor" href="#&#x5165;&#x53E3;&#x4EE3;&#x7801;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x5165;&#x53E3;&#x4EE3;&#x7801;</h4>
<p>&#x5728;vCPU&#x521D;&#x59CB;&#x5316;&#x7684;&#x65F6;&#x5019;, &#x5165;&#x53E3;&#x4EE3;&#x7801;<code>ring0.Start()</code>&#x7528;KVM&#x7684;ioctl&#x88AB;&#x5199;&#x5165;PC</p>
<pre><code class="lang-go">    // pc
    reg.id = _KVM_ARM64_REGS_PC
    data = uint64(reflect.ValueOf(ring0.Start).Pointer()) //&#x8FD9;&#x91CC;&#x7684;&#x5B9E;&#x73B0;&#x5F88;&#x5173;&#x952E;!!!! ring0.Start&#x662F;&#x4E2A;&#x51FD;&#x6570;, &#x53D6;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5F53;&#x4F5C;&#x5165;&#x53E3;&#x5730;&#x5740;, &#x914D;&#x5230;PC&#x4E2D;.
    if err := c.setOneRegister(&amp;reg); err != nil {
        return err
    }
</code></pre>
<p>&#x8FD9;&#x4E2A;Start()&#x51FD;&#x6570;&#x5728;
<code>pkg/ring0/entry_arm64.s</code>
&#x5E94;&#x8BE5;&#x662F;&#x8FD0;&#x884C;&#x5728;EL1</p>
<pre><code class="lang-go">// Start is the CPU entrypoint.
TEXT &#xB7;Start(SB),NOSPLIT,$0
    // Init.
    WORD $0xd508871f    // __tlbi(vmalle1)
    DSB $7          // dsb(nsh)

    MOVD $1&lt;&lt;12, R1         // Reset mdscr_el1 and disable
    MSR R1, MDSCR_EL1       // access to the DCC from EL0
    ISB $15

    MRS TTBR1_EL1, R1
    MSR R1, TTBR0_EL1
    ISB $15

    MOVD $CNTKCTL_EL1_DEFAULT, R1
    MSR R1, CNTKCTL_EL1

    MOVD R8, RSV_REG //&#x8FD9;&#x91CC;&#x7684;R8&#x662F;bluepill(*vCPU)&#x51FD;&#x6570;&#x8C03;&#x7528;&#x7684;&#x65F6;&#x5019;&#x4F20;&#x5165;&#x7684;*vCPU
    ORR $0xffff000000000000, RSV_REG, RSV_REG
    WORD $0xd518d092        //MSR R18, TPIDR_EL1

    // Enable trap for accessing fpsimd.
    MSR $0, CPACR_EL1

    // Init.
    MOVD $SCTLR_EL1_DEFAULT, R1 // re-enable the mmu. &#x8BF4;&#x660E;&#x4E4B;&#x524D;&#x7684;MMU&#x662F;&#x5173;&#x95ED;&#x7684;.
    MSR R1, SCTLR_EL1
    ISB $15
    WORD $0xd508751f // ic iallu

    DSB $7          // dsb(nsh)
    ISB $15

    B &#xB7;kernelExitToEl1(SB)
</code></pre>
<h3 id="kvm&#x7684;context&#x5B9E;&#x73B0;"><a name="kvm&#x7684;context&#x5B9E;&#x73B0;" class="anchor-navigation-ex-anchor" href="#kvm&#x7684;context&#x5B9E;&#x73B0;"><i class="fa fa-link" aria-hidden="true"></i></a>4.13.10. KVM&#x7684;context&#x5B9E;&#x73B0;</h3>
<p>&#x4E0A;&#x9762;&#x63D0;&#x5230;platform&#x8981;&#x5B9E;&#x73B0;context&#x65B9;&#x6CD5;:</p>
<pre><code class="lang-go">// Switch resumes execution of the thread specified by the arch.Context
// in the provided address space. This call will block while the thread
// is executing.
// &#x6B63;&#x5E38;&#x5E94;&#x8BE5;&#x662F;&#x6210;&#x529F;&#x8C03;&#x7528;&#x4E00;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;.
// &#x5982;&#x679C;&#x6B63;&#x5728;&#x6267;&#x884C;&#x8FD9;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x65F6;&#x5019;&#x6709;signal, &#x8FD4;&#x56DE;ErrContextSignal
// &#x5982;&#x679C;&#x8C03;&#x7528;&#x4E86;Interrupt()&#x5219;&#x8FD4;&#x56DE;ErrContextInterrupt
Switch(ctx context.Context, mm MemoryManager, ac arch.Context, cpu int32) (*linux.SignalInfo, hostarch.AccessType, error)
</code></pre>
<p>&#x6309;&#x7167;ptrace&#x7684;&#x5B9E;&#x73B0;, Switch&#x51FD;&#x6570;&#x662F;&#x6267;&#x884C;&#x4E00;&#x4E2A;sycle&#x7684;&#x7528;&#x6237;&#x4EE3;&#x7801;&#x76F4;&#x5230;&#x4E0B;&#x4E00;&#x4E2A;syscall.
&#x90A3;&#x4E48;kvm&#x5B9E;&#x73B0;&#x600E;&#x4E48;&#x505A;&#x5230;syscall&#x7EA7;&#x522B;&#x7684;&#x5462;?</p>
<pre><code class="lang-go">// Switch runs the provided context in the given address space.
func (c *context) Switch(ctx pkgcontext.Context, mm platform.MemoryManager, ac arch.Context, _ int32) (*linux.SignalInfo, hostarch.AccessType, error) {
    as := mm.AddressSpace()
    localAS := as.(*addressSpace)

    // Grab a vCPU.
    // machine.Get()&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;vCPU, vCPU&#x662F;&#x548C;TID&#x7ED1;&#x5B9A;&#x7684;, &#x5148;&#x67E5;&#x8868;&#x627E;&#x5DF2;&#x7ECF;&#x7ED1;&#x5B9A;&#x7684;; &#x6CA1;&#x6709;&#x5C31;&#x68C0;&#x67E5;&#x6BCF;&#x4E2A;vCPU&#x7684;&#x72B6;&#x6001;, &#x5C1D;&#x8BD5;&#x4ECE;vCPUReady&#x8F6C;&#x5230;vCPUUser&#x72B6;&#x6001;; &#x6700;&#x540E;&#x5B9E;&#x5728;&#x4E0D;&#x884C;&#x5C31;m.getNewVCPU()&#x4E00;&#x4E2A;
    cpu := c.machine.Get()

    // Enable interrupts (i.e. calls to vCPU.Notify).
    if !c.interrupt.Enable(cpu) {
        c.machine.Put(cpu) // Already preempted.
        return nil, hostarch.NoAccess, platform.ErrContextInterrupt
    }

    // Set the active address space.
    //
    // This must be done prior to the call to Touch below. If the address
    // space is invalidated between this line and the call below, we will
    // flag on entry anyways. When the active address space below is
    // cleared, it indicates that we don&apos;t need an explicit interrupt and
    // that the flush can occur naturally on the next user entry.
    cpu.active.set(localAS)

    // Prepare switch options.
    switchOpts := ring0.SwitchOpts{
        Registers:          &amp;ac.StateData().Regs,
        FloatingPointState: ac.FloatingPointData(),
        PageTables:         localAS.pageTables,
        Flush:              localAS.Touch(cpu),
        FullRestore:        ac.FullRestore(),
    }

    // Take the blue pill. &#x8FD9;&#x91CC;&#x662F;&#x5173;&#x952E;
    at, err := cpu.SwitchToUser(switchOpts, &amp;c.info)

    // Clear the address space.
    cpu.active.set(nil)

    // Increment the number of user exits.
    atomic.AddUint64(&amp;cpu.userExits, 1)

    // Release resources.
    c.machine.Put(cpu)

    // All done.
    c.interrupt.Disable()
    return &amp;c.info, at, err
}
</code></pre>
<h4 id="arm64&#x7684;cpuswitchtouser"><a name="arm64&#x7684;cpuswitchtouser" class="anchor-navigation-ex-anchor" href="#arm64&#x7684;cpuswitchtouser"><i class="fa fa-link" aria-hidden="true"></i></a>arm64&#x7684;cpu.SwitchToUser</h4>
<p>&#x5728;<code>pkg/sentry/platform/kvm/machine_arm64_unsafe.go</code>&#x4E2D;</p>
<pre><code class="lang-go">// SwitchToUser unpacks architectural-details.
func (c *vCPU) SwitchToUser(switchOpts ring0.SwitchOpts, info *linux.SignalInfo) (hostarch.AccessType, error) {
    // Check for canonical addresses.
    if regs := switchOpts.Registers; !ring0.IsCanonical(regs.Pc) {
        return nonCanonical(regs.Pc, int32(unix.SIGSEGV), info)
    } else if !ring0.IsCanonical(regs.Sp) {
        return nonCanonical(regs.Sp, int32(unix.SIGSEGV), info)
    }

    // Assign PCIDs.
    if c.PCIDs != nil {
        var requireFlushPCID bool // Force a flush?
        switchOpts.UserASID, requireFlushPCID = c.PCIDs.Assign(switchOpts.PageTables)
        switchOpts.Flush = switchOpts.Flush || requireFlushPCID
    }

    var vector ring0.Vector
    ttbr0App := switchOpts.PageTables.TTBR0_EL1(false, 0)
    c.SetTtbr0App(uintptr(ttbr0App)) //&#x8FD9;&#x91CC;&#x914D;&#x7F6E;&#x4E86;&#x7528;&#x6237;&#x6001;&#x7684;&#x57FA;&#x5740;&#x5BC4;&#x5B58;&#x5668;

    // Full context-switch supporting for Arm64.
    // The Arm64 user-mode execution state consists of:
    // x0-x30
    // PC, SP, PSTATE
    // V0-V31: 32 128-bit registers for floating point, and simd
    // FPSR, FPCR
    // TPIDR_EL0, used for TLS
    appRegs := switchOpts.Registers
    c.SetAppAddr(ring0.KernelStartAddress | uintptr(unsafe.Pointer(appRegs)))

    entersyscall() //go:linkname entersyscall runtime.entersyscall, &#x8FD9;&#x91CC;&#x66F4;&#x50CF;&#x662F;&#x544A;&#x8BC9;go&#x7684;runtime, &#x6211;&#x8981;&#x8FDB;&#x5165;syscall&#x4E86;, &#x8981;&#x963B;&#x585E;&#x4E86;
    bluepill(c) //bluepill enters guest mode, &#x8FDB;&#x5165;guest&#x6A21;&#x5F0F;; &#x4E0B;&#x9762;&#x4F1A;&#x63D0;&#x5230;, bluepill&#x4F1A;&#x89E6;&#x53D1;&#x975E;&#x6CD5;&#x6307;&#x4EE4;&#x5F02;&#x5E38;, &#x7A0B;&#x5E8F;&#x4F1A;&#x5728;&#x8FD9;&#x91CC;&#x5361;&#x4F4F;, &#x7B49;&#x5F85;bluepillHandler&#x6267;&#x884C;&#x4E00;&#x6B21;ioctl&#x7684;_KVM_RUN
    vector = c.CPU.SwitchToUser(switchOpts)
    exitsyscall()

    switch vector {
    case ring0.Syscall:
        // Fast path: system call executed.
        return hostarch.NoAccess, nil
    case ring0.PageFault:
        return c.fault(int32(unix.SIGSEGV), info)
    case ring0.El0ErrNMI:
        return c.fault(int32(unix.SIGBUS), info)
    case ring0.Vector(bounce): // ring0.VirtualizationException.
        return hostarch.NoAccess, platform.ErrContextInterrupt
    case ring0.El0SyncUndef:
        return c.fault(int32(unix.SIGILL), info)
    case ring0.El0SyncDbg:
        *info = linux.SignalInfo{
            Signo: int32(unix.SIGTRAP),
            Code:  1, // TRAP_BRKPT (breakpoint).
        }
        info.SetAddr(switchOpts.Registers.Pc) // Include address.
        return hostarch.AccessType{}, platform.ErrContextSignal
    case ring0.El0SyncSpPc:
        *info = linux.SignalInfo{
            Signo: int32(unix.SIGBUS),
            Code:  2, // BUS_ADRERR (physical address does not exist).
        }
        return hostarch.NoAccess, platform.ErrContextSignal
    case ring0.El0SyncSys,
        ring0.El0SyncWfx:
        return hostarch.NoAccess, nil // skip for now.
    default:
        panic(fmt.Sprintf(&quot;unexpected vector: 0x%x&quot;, vector))
    }

}
</code></pre>
<h4 id="bluepill&#x6C47;&#x7F16;&#x51FD;&#x6570;"><a name="bluepill&#x6C47;&#x7F16;&#x51FD;&#x6570;" class="anchor-navigation-ex-anchor" href="#bluepill&#x6C47;&#x7F16;&#x51FD;&#x6570;"><i class="fa fa-link" aria-hidden="true"></i></a>bluepill()&#x6C47;&#x7F16;&#x51FD;&#x6570;</h4>
<p>&#x5728;&#x4E0A;&#x9762;&#x7684;SwitchToUser()&#x51FD;&#x6570;&#x4E2D;, &#x5148;&#x662F;entersyscall(), &#x7136;&#x540E;&#x8C03;&#x7528;bluepill()&#x8FDB;&#x5165;guest&#x6A21;&#x5F0F;</p>
<pre><code class="lang-go">// See bluepill.go.
TEXT &#xB7;bluepill(SB),NOSPLIT,$0
begin:
    MOVD    vcpu+0(FP), R8
    MOVD    $VCPU_CPU(R8), R9
    ORR    $0xffff000000000000, R9, R9
    // Trigger sigill.
    // In ring0.Start(), the value of R8 will be stored into tpidr_el1.
    // When the context was loaded into vcpu successfully,
    // we will check if the value of R10 and R9 are the same.
    // &#x6CE8;&#x610F;&#x539F;&#x6CE8;&#x91CA;&#x91CC;&#x7684;MRS TPIDR_EL1, R10, &#x56E0;&#x4E3A;&#x5728;EL0&#x7EA7;&#x522B;&#x4F7F;&#x7528;&#x4E86;&#x9AD8;&#x7EA7;&#x522B;&#x7684;TPIDR_EL1, &#x4F1A;&#x89E6;&#x53D1;&#x6307;&#x4EE4;&#x5F02;&#x5E38;
    // &#x5927;&#x90E8;&#x5206;&#x7CFB;&#x7EDF;&#x5BC4;&#x5B58;&#x5668;&#x90FD;&#x4E0D;&#x80FD;&#x5728;EL0&#x8BBF;&#x95EE;, &#x4E2A;&#x522B;&#x7684;&#x53EF;&#x4EE5;, &#x6BD4;&#x5982;TPIDR_EL0. &#x6CE8;&#x610F;&#x8FD9;&#x91CC;&#x7684;&#x540E;&#x7F00;&#x662F;EL0
    // Any access from EL0 to a System register with the access right disabled causes the instruction to behave as UNDEFINED
    // &#x8FD9;&#x4E2A;&#x975E;&#x6CD5;&#x6307;&#x4EE4;&#x5F02;&#x5E38;&#x5E94;&#x8BE5;&#x4F1A;&#x5BFC;&#x81F4;&#x5F53;&#x524D;CPU&#x8DF3;&#x8F6C;&#x5230;kernel&#x914D;&#x7F6E;&#x597D;&#x7684;&#x5F02;&#x5E38;&#x5411;&#x91CF;
    // &#x7136;&#x540E;kernel&#x4F1A;&#x8DEF;&#x7531;&#x8FD9;&#x4E2A;signal&#x5230;&#x4E0B;&#x9762;&#x7684;sighandler, &#x5728;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x6001;&#x540E;&#x6267;&#x884C;.
    WORD    $0xd538d08a // MRS TPIDR_EL1, R10
    // &#x56E0;&#x4E3A;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5728;&#x6267;&#x884C;&#x4E0B;&#x9762;&#x7684;sighandler, &#x6682;&#x65F6;&#x8FD8;&#x4E0D;&#x4F1A;&#x8D70;&#x5230;&#x8FD9;&#x91CC;. &#x5F85; sighandler&#x6267;&#x884C;&#x5B8C;&#x6210;&#x540E;, &#x518D;&#x6B21;&#x8FD4;&#x56DE;&#x5185;&#x6838;, &#x5185;&#x6838;&#x518D;&#x6B21;&#x8C03;&#x5EA6;&#x8FD9;&#x4E2A;&#x7EBF;&#x7A0B;, &#x624D;&#x8DD1;&#x5230;&#x8FD9;&#x91CC;.
check_vcpu:
    CMP    R10, R9
    BEQ    right_vCPU
wrong_vcpu:
    CALL    &#xB7;redpill(SB)
    B    begin
right_vCPU:
    RET

// &#x5F02;&#x5E38;&#x4F1A;&#x5728;&#x8FD9;&#x91CC;&#x88AB;&#x5904;&#x7406;. &#x4F46;&#x95EE;&#x9898;&#x662F;&#x4E3A;&#x4EC0;&#x4E48;&#x975E;&#x8981;&#x89E6;&#x53D1;&#x4E2A;sigill&#x518D;&#x6765;&#x5904;&#x7406;?
// sighandler: see bluepill.go for documentation.
//
// The arguments are the following:
//
//     R0 - The signal number.
//     R1 - Pointer to siginfo_t structure.
//     R2 - Pointer to ucontext structure.
//
TEXT &#xB7;sighandler(SB),NOSPLIT,$0
    // si_signo should be sigill.
    MOVD    SIGINFO_SIGNO(R1), R7
    CMPW    $4, R7
    BNE    fallback

    MOVD    CONTEXT_PC(R2), R7
    CMPW    $0, R7
    BEQ    fallback

    MOVD    R2, 8(RSP)
    BL    &#xB7;bluepillHandler(SB)   // Call the handler.

    RET
</code></pre>
<p>&#x4E0B;&#x9762;&#x5C31;&#x6765;&#x5230;&#x4E86;bluepillHandler()&#x8FD9;&#x4E2A;&#x51FD;&#x6570;, &#x5728;<code>pkg/sentry/platform/kvm/bluepill_unsafe.go</code><br>&#x7C97;&#x770B;&#x4E0B;&#x6765;, &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x6838;&#x5FC3;&#x662F;&#x8C03;&#x7528;&#x4E00;&#x6B21;<code>unix.RawSyscall(unix.SYS_IOCTL, uintptr(c.fd), _KVM_RUN, 0)</code>, &#x7136;&#x540E;&#x7B49;&#x5F85;guest VM&#x56E0;&#x4E3A;&#x5F02;&#x5E38;&#x7B49;&#x539F;&#x56E0;&#x9000;&#x51FA;&#x8FD9;&#x4E00;&#x6B21;&#x7684;RUN<br>&#x6211;&#x8BA4;&#x4E3A;&#x5728;KVM_RUN syscall&#x671F;&#x95F4;&#x662F;&#x963B;&#x585E;&#x7684;, &#x90A3;&#x4E48;&#x8FD9;&#x91CC;&#x5C31;&#x662F;&#x5728;signal&#x5904;&#x7406;&#x51FD;&#x6570;&#x91CC;&#x963B;&#x585E;.</p>
<pre><code class="lang-go">func bluepillHandler(context unsafe.Pointer) {
    c := bluepillArchEnter(bluepillArchContext(context)) //&#x8FD9;&#x91CC;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;*vCPU
    for {
        _, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(c.fd), _KVM_RUN, 0) // escapes: no.
        //&#x68C0;&#x67E5;errno&#x662F;&#x5426;&#x662F;&#x88AB;&#x6253;&#x65AD;&#x7B49;
        //&#x68C0;&#x67E5;exitReason, &#x6BCF;&#x4E2A;&#x5206;&#x652F;&#x90FD;return(&#x9664;&#x4E86;&#x4E2D;&#x65AD;&#x6CE8;&#x5165;), &#x4E5F;&#x5C31;&#x662F;&#x8BF4;for&#x53EA;&#x7BA1;&#x4E00;&#x6B21;
        // exitReason&#x662F;kvm&#x901A;&#x8FC7;mmap&#x4F20;&#x51FA;&#x6765;&#x7684;&#x503C;
        switch c.runData.exitReason {
        }
    }
}
</code></pre>
<p>&#x5BF9;&#x5E94;&#x4E00;&#x6B21;<code>_KVM_RUN</code>&#x8BA9;VM&#x8FD0;&#x884C;, stop VM&#x662F;&#x901A;&#x8FC7;ioctl&#x7684;<code>_KVM_SET_VCPU_EVENTS</code>&#x6765;&#x5B9E;&#x73B0;&#x7684;.</p>
<pre><code class="lang-go">// bluepillStopGuest is reponsible for injecting sError.
//
//go:nosplit
func bluepillStopGuest(c *vCPU) {
    // vcpuSErrBounce is the event of system error for bouncing KVM.
    vcpuSErrBounce := &amp;kvmVcpuEvents{
        exception: exception{
            sErrPending: 1,
        },
    }

    if _, _, errno := unix.RawSyscall( // escapes: no.
        unix.SYS_IOCTL,
        uintptr(c.fd),
        _KVM_SET_VCPU_EVENTS,
        uintptr(unsafe.Pointer(vcpuSErrBounce))); errno != 0 {
        throw(&quot;bounce sErr injection failed&quot;)
    }
}
</code></pre>
<p>&#x8FD9;&#x4E2A;runData&#x5B9A;&#x4E49;&#x662F;, &#x4F30;&#x8BA1;&#x662F;kvm&#x6807;&#x51C6;&#x5B9A;&#x4E49;&#x7684;</p>
<pre><code class="lang-go">type runData struct {
    requestInterruptWindow uint8
    _                      [7]uint8

    exitReason                 uint32
    readyForInterruptInjection uint8
    ifFlag                     uint8
    _                          [2]uint8

    cr8      uint64
    apicBase uint64

    // This is the union data for exits. Interpretation depends entirely on
    // the exitReason above (see vCPU code for more information).
    data [32]uint64
}
</code></pre>
<p>&#x4E3A;&#x4EC0;&#x4E48;runData&#x7684;exitReason&#x4F1A;&#x53CD;&#x5E94;VM&#x7684;&#x9000;&#x51FA;&#x7801;?<br>&#x56E0;&#x4E3A;&#x5728;newVCPU()&#x91CC;&#x9762;, &#x7528;_KVM_CREATE_VCPU&#x51FA;&#x6765;&#x7684;fd, mmap&#x6210;&#x4E86;<code>*runData</code></p>
<pre><code class="lang-go">func (m *machine) newVCPU() *vCPU {
    fd, _, errno := unix.RawSyscall(unix.SYS_IOCTL, uintptr(m.fd), _KVM_CREATE_VCPU, uintptr(id))
    // Map the run data.
    runData, err := mapRunData(int(fd))
    c.runData = runData
}

// mapRunData maps the vCPU run data.
func mapRunData(fd int) (*runData, error) {
    r, _, errno := unix.RawSyscall6(
        unix.SYS_MMAP,
        0,
        uintptr(runDataSize),
        unix.PROT_READ|unix.PROT_WRITE,
        unix.MAP_SHARED,
        uintptr(fd),
        0)
    if errno != 0 {
        return nil, fmt.Errorf(&quot;error mapping runData: %v&quot;, errno)
    }
    return (*runData)(unsafe.Pointer(r)), nil
}
</code></pre>
<h4 id="vcpucpuswitchtouser&#x51FD;&#x6570;"><a name="vcpucpuswitchtouser&#x51FD;&#x6570;" class="anchor-navigation-ex-anchor" href="#vcpucpuswitchtouser&#x51FD;&#x6570;"><i class="fa fa-link" aria-hidden="true"></i></a>vCPU.CPU.SwitchToUser&#x51FD;&#x6570;</h4>
<p>&#x4F4D;&#x4E8E;<code>pkg/ring0/kernel_arm64.go</code></p>
<pre><code class="lang-go">// SwitchToUser performs an eret.
//
// The return value is the exception vector.
//
// +checkescape:all
//
//go:nosplit
func (c *CPU) SwitchToUser(switchOpts SwitchOpts) (vector Vector) {
    storeAppASID(uintptr(switchOpts.UserASID))
    storeEl0Fpstate(switchOpts.FloatingPointState.BytePointer())

    if switchOpts.Flush {
        LocalFlushTlbByASID(uintptr(switchOpts.UserASID))
    }

    regs := switchOpts.Registers

    regs.Pstate &amp;= ^uint64(PsrFlagsClear)
    regs.Pstate |= UserFlagsSet

    fpDisableTrap := CPACREL1()
    if fpDisableTrap != 0 {
        FPSIMDEnableTrap()
    }

    kernelExitToEl0()

    fpDisableTrap = CPACREL1()
    if fpDisableTrap != 0 {
        SaveFloatingPoint(switchOpts.FloatingPointState.BytePointer())
    }

    vector = c.vecCode

    return
}
</code></pre>
<h4 id="&#x8865;&#x5145;-go-linkname&#x7528;&#x6CD5;"><a name="&#x8865;&#x5145;-go-linkname&#x7528;&#x6CD5;" class="anchor-navigation-ex-anchor" href="#&#x8865;&#x5145;-go-linkname&#x7528;&#x6CD5;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x8865;&#x5145; go linkname&#x7528;&#x6CD5;</h4>
<p><code>pkg/sentry/platform/kvm/machine_unsafe.go</code>&#x4E2D;, &#x5F15;&#x7528;&#x4E86;2&#x4E2A;runtime&#x7684;&#x5C0F;&#x5199;&#x51FD;&#x6570;:</p>
<pre><code class="lang-go">//go:linkname entersyscall runtime.entersyscall
func entersyscall()

//go:linkname exitsyscall runtime.exitsyscall
func exitsyscall()
</code></pre>
<blockquote>
<p>The //go:nosplit directive must be followed by a function declaration. It specifies that the function must omit its usual stack overflow check. This is most commonly used by low-level runtime code invoked at times when it is unsafe for the calling goroutine to be preempted.</p>
<p>//go:linkname localname [importpath.name] This special directive does not apply to the Go code that follows it. Instead, the //go:linkname directive instructs the compiler to use &#x201C;importpath.name&#x201D; as the object file symbol name for the variable or function declared as &#x201C;localname&#x201D; in the source code. If the &#x201C;importpath.name&#x201D; argument is omitted, the directive uses the symbol&apos;s default object file symbol name and only has the effect of making the symbol accessible to other packages. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported &quot;unsafe&quot;.</p>
</blockquote>
<p><code>go:linkname</code>&#x6709;&#x4E09;&#x79CD;&#x7528;&#x6CD5;:</p>
<ul>
<li>export: localname&#x662F;&#x672C;&#x5730;(pkgA)&#x7684;&#x6709;&#x51FD;&#x6570;&#x4F53;&#x7684;&#x5B9E;&#x73B0;, export&#x6210;pkgB.name. pkgB&#x6CA1;&#x6709;name&#x7684;&#x5B9E;&#x73B0;</li>
<li>import: localname&#x662F;&#x672C;&#x5730;(pkgA)&#x7684;&#x6CA1;&#x6709;&#x51FD;&#x6570;&#x4F53;&#x7684;&#x58F0;&#x660E;, &#x5B83;import pkgB.name&#x7684;&#x5177;&#x4F53;&#x5B9E;&#x73B0;.</li>
<li>&#x540C;&#x540D;export: &#x4E0D;&#x6307;&#x5B9A;importpath.name, &#x8BA9;&#x672C;&#x6765;&#x5C0F;&#x5199;&#x7684;&#x7B26;&#x53F7;&#x80FD;&#x88AB;&#x5916;&#x90E8;&#x8BBF;&#x95EE;.</li>
</ul>
<p>runtime.entersyscall&#x5728;<code>src/runtime/proc.go</code>&#x4E2D;&#x5B9A;&#x4E49;</p>
<pre><code class="lang-go">// Standard syscall entry used by the go syscall library and normal cgo calls.
//
// This is exported via linkname to assembly in the syscall package.
//
//go:nosplit
//go:linkname entersyscall
func entersyscall() {
    reentersyscall(getcallerpc(), getcallersp())
}

// reentersyscall&#x6BD4;&#x8F83;&#x6666;&#x6DA9;, &#x8FD9;&#x91CC;&#x53EA;&#x8D34;&#x4E86;&#x6CE8;&#x91CA;

// The goroutine g is about to enter a system call.
// Record that it&apos;s not using the cpu anymore.
// This is called only from the go syscall library and cgocall,
// not from the low-level system calls used by the runtime.
//
// Entersyscall cannot split the stack: the gosave must
// make g-&gt;sched refer to the caller&apos;s stack segment, because
// entersyscall is going to return immediately after.
//
// Nothing entersyscall calls can split the stack either.
// We cannot safely move the stack during an active call to syscall,
// because we do not know which of the uintptr arguments are
// really pointers (back into the stack).
// In practice, this means that we make the fast path run through
// entersyscall doing no-split things, and the slow path has to use systemstack
// to run bigger things on the system stack.
//
// reentersyscall is the entry point used by cgo callbacks, where explicitly
// saved SP and PC are restored. This is needed when exitsyscall will be called
// from a function further up in the call stack than the parent, as g-&gt;syscallsp
// must always point to a valid stack frame. entersyscall below is the normal
// entry point for syscalls, which obtains the SP and PC from the caller.
//
// Syscall tracing:
// At the start of a syscall we emit traceGoSysCall to capture the stack trace.
// If the syscall does not block, that is it, we do not emit any other events.
// If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock;
// when syscall returns we emit traceGoSysExit and when the goroutine starts running
// (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart.
// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,
// we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick),
// whoever emits traceGoSysBlock increments p.syscalltick afterwards;
// and we wait for the increment before emitting traceGoSysExit.
// Note that the increment is done even if tracing is not enabled,
// because tracing can be enabled in the middle of syscall. We don&apos;t want the wait to hang.
//
//go:nosplit
func reentersyscall(pc, sp uintptr) {
    ...
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="as_title.html" class="navigation navigation-prev " aria-label="Previous page: gvisor">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="golang_gvisor调试.html" class="navigation navigation-next " aria-label="Next page: gvisor调试">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"gvisor KVM模式代码","level":"1.13.1.1","depth":3,"next":{"title":"gvisor调试","level":"1.13.1.2","depth":3,"path":"notes/golang_gvisor调试.md","ref":"notes/golang_gvisor调试.md","articles":[]},"previous":{"title":"gvisor","level":"1.13.1","depth":2,"path":"notes/as_title.md","ref":"notes/as_title.md","articles":[{"title":"gvisor KVM模式代码","level":"1.13.1.1","depth":3,"path":"notes/golang_gvisor代码_KVM.md","ref":"notes/golang_gvisor代码_KVM.md","articles":[]},{"title":"gvisor调试","level":"1.13.1.2","depth":3,"path":"notes/golang_gvisor调试.md","ref":"notes/golang_gvisor调试.md","articles":[]},{"title":"gvisor ptrace模式介绍(网摘)","level":"1.13.1.3","depth":3,"path":"notes/golang_gvisor_ptrace.md","ref":"notes/golang_gvisor_ptrace.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["-sharing","-lunr","-search","search-plus","-highlight","theme-code","expandable-chapters-small","github","disqus","splitter","wide-page","hide-navigation-buttons","anchor-navigation-ex","sequence"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"disqus":{"useIdentifier":false,"shortName":"bai-yingjie-notes"},"sequence":{"theme":"simple"},"github":{"url":"https://github.com/Bai-Yingjie/Bai-Yingjie.github.io"},"splitter":{},"wide-page":{},"theme-code":{"showLevel":false,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"}},"fontsettings":{"theme":"white","family":"sans","size":2},"hide-navigation-buttons":{},"anchor-navigation-ex":{"mode":"float","pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"isRewritePageTitle":true,"showLevel":true,"tocLevel1Icon":"fa fa-hand-o-right","tocLevel2Icon":"fa fa-hand-o-right","tocLevel3Icon":"fa fa-hand-o-right","showGoTop":true,"isShowTocTitleIcon":true,"printLog":false,"multipleH1":true,"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false}},"expandable-chapters-small":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"search-plus":{}},"theme":"default","author":"Bai Yingjie","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"My Notes","language":"zh-hans","gitbook":"*"},"file":{"path":"notes/golang_gvisor代码_KVM.md","mtime":"2022-10-11T15:10:42.534Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-10-11T15:11:40.551Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>


        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

        
    </body>
</html>

